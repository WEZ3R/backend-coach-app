
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CoachProfile
 * 
 */
export type CoachProfile = $Result.DefaultSelection<Prisma.$CoachProfilePayload>
/**
 * Model ClientProfile
 * 
 */
export type ClientProfile = $Result.DefaultSelection<Prisma.$ClientProfilePayload>
/**
 * Model ClientCoach
 * 
 */
export type ClientCoach = $Result.DefaultSelection<Prisma.$ClientCoachPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model ProgramTemplate
 * 
 */
export type ProgramTemplate = $Result.DefaultSelection<Prisma.$ProgramTemplatePayload>
/**
 * Model CustomGoal
 * 
 */
export type CustomGoal = $Result.DefaultSelection<Prisma.$CustomGoalPayload>
/**
 * Model GoalCompletion
 * 
 */
export type GoalCompletion = $Result.DefaultSelection<Prisma.$GoalCompletionPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model SetCompletion
 * 
 */
export type SetCompletion = $Result.DefaultSelection<Prisma.$SetCompletionPayload>
/**
 * Model MealPlan
 * 
 */
export type MealPlan = $Result.DefaultSelection<Prisma.$MealPlanPayload>
/**
 * Model MenuItem
 * 
 */
export type MenuItem = $Result.DefaultSelection<Prisma.$MenuItemPayload>
/**
 * Model Meal
 * 
 */
export type Meal = $Result.DefaultSelection<Prisma.$MealPayload>
/**
 * Model DailyStat
 * 
 */
export type DailyStat = $Result.DefaultSelection<Prisma.$DailyStatPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model CoachRequest
 * 
 */
export type CoachRequest = $Result.DefaultSelection<Prisma.$CoachRequestPayload>
/**
 * Model CoachPost
 * 
 */
export type CoachPost = $Result.DefaultSelection<Prisma.$CoachPostPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  COACH: 'COACH',
  CLIENT: 'CLIENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SessionStatus: {
  EMPTY: 'EMPTY',
  DRAFT: 'DRAFT',
  DONE: 'DONE'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const ExerciseCategory: {
  WARMUP: 'WARMUP',
  MAIN: 'MAIN',
  CARDIO: 'CARDIO',
  STRETCHING: 'STRETCHING'
};

export type ExerciseCategory = (typeof ExerciseCategory)[keyof typeof ExerciseCategory]


export const MessageType: {
  CHAT: 'CHAT',
  TIP: 'TIP'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type ExerciseCategory = $Enums.ExerciseCategory

export const ExerciseCategory: typeof $Enums.ExerciseCategory

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.coachProfile`: Exposes CRUD operations for the **CoachProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachProfiles
    * const coachProfiles = await prisma.coachProfile.findMany()
    * ```
    */
  get coachProfile(): Prisma.CoachProfileDelegate<ExtArgs>;

  /**
   * `prisma.clientProfile`: Exposes CRUD operations for the **ClientProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientProfiles
    * const clientProfiles = await prisma.clientProfile.findMany()
    * ```
    */
  get clientProfile(): Prisma.ClientProfileDelegate<ExtArgs>;

  /**
   * `prisma.clientCoach`: Exposes CRUD operations for the **ClientCoach** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientCoaches
    * const clientCoaches = await prisma.clientCoach.findMany()
    * ```
    */
  get clientCoach(): Prisma.ClientCoachDelegate<ExtArgs>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs>;

  /**
   * `prisma.programTemplate`: Exposes CRUD operations for the **ProgramTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramTemplates
    * const programTemplates = await prisma.programTemplate.findMany()
    * ```
    */
  get programTemplate(): Prisma.ProgramTemplateDelegate<ExtArgs>;

  /**
   * `prisma.customGoal`: Exposes CRUD operations for the **CustomGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomGoals
    * const customGoals = await prisma.customGoal.findMany()
    * ```
    */
  get customGoal(): Prisma.CustomGoalDelegate<ExtArgs>;

  /**
   * `prisma.goalCompletion`: Exposes CRUD operations for the **GoalCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoalCompletions
    * const goalCompletions = await prisma.goalCompletion.findMany()
    * ```
    */
  get goalCompletion(): Prisma.GoalCompletionDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs>;

  /**
   * `prisma.setCompletion`: Exposes CRUD operations for the **SetCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SetCompletions
    * const setCompletions = await prisma.setCompletion.findMany()
    * ```
    */
  get setCompletion(): Prisma.SetCompletionDelegate<ExtArgs>;

  /**
   * `prisma.mealPlan`: Exposes CRUD operations for the **MealPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MealPlans
    * const mealPlans = await prisma.mealPlan.findMany()
    * ```
    */
  get mealPlan(): Prisma.MealPlanDelegate<ExtArgs>;

  /**
   * `prisma.menuItem`: Exposes CRUD operations for the **MenuItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItems
    * const menuItems = await prisma.menuItem.findMany()
    * ```
    */
  get menuItem(): Prisma.MenuItemDelegate<ExtArgs>;

  /**
   * `prisma.meal`: Exposes CRUD operations for the **Meal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meals
    * const meals = await prisma.meal.findMany()
    * ```
    */
  get meal(): Prisma.MealDelegate<ExtArgs>;

  /**
   * `prisma.dailyStat`: Exposes CRUD operations for the **DailyStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyStats
    * const dailyStats = await prisma.dailyStat.findMany()
    * ```
    */
  get dailyStat(): Prisma.DailyStatDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.coachRequest`: Exposes CRUD operations for the **CoachRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachRequests
    * const coachRequests = await prisma.coachRequest.findMany()
    * ```
    */
  get coachRequest(): Prisma.CoachRequestDelegate<ExtArgs>;

  /**
   * `prisma.coachPost`: Exposes CRUD operations for the **CoachPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachPosts
    * const coachPosts = await prisma.coachPost.findMany()
    * ```
    */
  get coachPost(): Prisma.CoachPostDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    CoachProfile: 'CoachProfile',
    ClientProfile: 'ClientProfile',
    ClientCoach: 'ClientCoach',
    Program: 'Program',
    ProgramTemplate: 'ProgramTemplate',
    CustomGoal: 'CustomGoal',
    GoalCompletion: 'GoalCompletion',
    Session: 'Session',
    Exercise: 'Exercise',
    SetCompletion: 'SetCompletion',
    MealPlan: 'MealPlan',
    MenuItem: 'MenuItem',
    Meal: 'Meal',
    DailyStat: 'DailyStat',
    Comment: 'Comment',
    Message: 'Message',
    Channel: 'Channel',
    Review: 'Review',
    CoachRequest: 'CoachRequest',
    CoachPost: 'CoachPost'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "coachProfile" | "clientProfile" | "clientCoach" | "program" | "programTemplate" | "customGoal" | "goalCompletion" | "session" | "exercise" | "setCompletion" | "mealPlan" | "menuItem" | "meal" | "dailyStat" | "comment" | "message" | "channel" | "review" | "coachRequest" | "coachPost"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CoachProfile: {
        payload: Prisma.$CoachProfilePayload<ExtArgs>
        fields: Prisma.CoachProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>
          }
          findFirst: {
            args: Prisma.CoachProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>
          }
          findMany: {
            args: Prisma.CoachProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>[]
          }
          create: {
            args: Prisma.CoachProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>
          }
          createMany: {
            args: Prisma.CoachProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>[]
          }
          delete: {
            args: Prisma.CoachProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>
          }
          update: {
            args: Prisma.CoachProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>
          }
          deleteMany: {
            args: Prisma.CoachProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachProfilePayload>
          }
          aggregate: {
            args: Prisma.CoachProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachProfile>
          }
          groupBy: {
            args: Prisma.CoachProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachProfileCountArgs<ExtArgs>
            result: $Utils.Optional<CoachProfileCountAggregateOutputType> | number
          }
        }
      }
      ClientProfile: {
        payload: Prisma.$ClientProfilePayload<ExtArgs>
        fields: Prisma.ClientProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findFirst: {
            args: Prisma.ClientProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          findMany: {
            args: Prisma.ClientProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          create: {
            args: Prisma.ClientProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          createMany: {
            args: Prisma.ClientProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>[]
          }
          delete: {
            args: Prisma.ClientProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          update: {
            args: Prisma.ClientProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          deleteMany: {
            args: Prisma.ClientProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientProfilePayload>
          }
          aggregate: {
            args: Prisma.ClientProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientProfile>
          }
          groupBy: {
            args: Prisma.ClientProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ClientProfileCountAggregateOutputType> | number
          }
        }
      }
      ClientCoach: {
        payload: Prisma.$ClientCoachPayload<ExtArgs>
        fields: Prisma.ClientCoachFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientCoachFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientCoachFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>
          }
          findFirst: {
            args: Prisma.ClientCoachFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientCoachFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>
          }
          findMany: {
            args: Prisma.ClientCoachFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>[]
          }
          create: {
            args: Prisma.ClientCoachCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>
          }
          createMany: {
            args: Prisma.ClientCoachCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCoachCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>[]
          }
          delete: {
            args: Prisma.ClientCoachDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>
          }
          update: {
            args: Prisma.ClientCoachUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>
          }
          deleteMany: {
            args: Prisma.ClientCoachDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientCoachUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientCoachUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientCoachPayload>
          }
          aggregate: {
            args: Prisma.ClientCoachAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientCoach>
          }
          groupBy: {
            args: Prisma.ClientCoachGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientCoachGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCoachCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCoachCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      ProgramTemplate: {
        payload: Prisma.$ProgramTemplatePayload<ExtArgs>
        fields: Prisma.ProgramTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>
          }
          findFirst: {
            args: Prisma.ProgramTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>
          }
          findMany: {
            args: Prisma.ProgramTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>[]
          }
          create: {
            args: Prisma.ProgramTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>
          }
          createMany: {
            args: Prisma.ProgramTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>[]
          }
          delete: {
            args: Prisma.ProgramTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>
          }
          update: {
            args: Prisma.ProgramTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ProgramTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramTemplatePayload>
          }
          aggregate: {
            args: Prisma.ProgramTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramTemplate>
          }
          groupBy: {
            args: Prisma.ProgramTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramTemplateCountAggregateOutputType> | number
          }
        }
      }
      CustomGoal: {
        payload: Prisma.$CustomGoalPayload<ExtArgs>
        fields: Prisma.CustomGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>
          }
          findFirst: {
            args: Prisma.CustomGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>
          }
          findMany: {
            args: Prisma.CustomGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>[]
          }
          create: {
            args: Prisma.CustomGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>
          }
          createMany: {
            args: Prisma.CustomGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>[]
          }
          delete: {
            args: Prisma.CustomGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>
          }
          update: {
            args: Prisma.CustomGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>
          }
          deleteMany: {
            args: Prisma.CustomGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomGoalPayload>
          }
          aggregate: {
            args: Prisma.CustomGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomGoal>
          }
          groupBy: {
            args: Prisma.CustomGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomGoalCountArgs<ExtArgs>
            result: $Utils.Optional<CustomGoalCountAggregateOutputType> | number
          }
        }
      }
      GoalCompletion: {
        payload: Prisma.$GoalCompletionPayload<ExtArgs>
        fields: Prisma.GoalCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoalCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoalCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>
          }
          findFirst: {
            args: Prisma.GoalCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoalCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>
          }
          findMany: {
            args: Prisma.GoalCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>[]
          }
          create: {
            args: Prisma.GoalCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>
          }
          createMany: {
            args: Prisma.GoalCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoalCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>[]
          }
          delete: {
            args: Prisma.GoalCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>
          }
          update: {
            args: Prisma.GoalCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>
          }
          deleteMany: {
            args: Prisma.GoalCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoalCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoalCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoalCompletionPayload>
          }
          aggregate: {
            args: Prisma.GoalCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoalCompletion>
          }
          groupBy: {
            args: Prisma.GoalCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoalCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoalCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<GoalCompletionCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      SetCompletion: {
        payload: Prisma.$SetCompletionPayload<ExtArgs>
        fields: Prisma.SetCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SetCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SetCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>
          }
          findFirst: {
            args: Prisma.SetCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SetCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>
          }
          findMany: {
            args: Prisma.SetCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>[]
          }
          create: {
            args: Prisma.SetCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>
          }
          createMany: {
            args: Prisma.SetCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SetCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>[]
          }
          delete: {
            args: Prisma.SetCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>
          }
          update: {
            args: Prisma.SetCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>
          }
          deleteMany: {
            args: Prisma.SetCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SetCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SetCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetCompletionPayload>
          }
          aggregate: {
            args: Prisma.SetCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetCompletion>
          }
          groupBy: {
            args: Prisma.SetCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SetCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SetCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<SetCompletionCountAggregateOutputType> | number
          }
        }
      }
      MealPlan: {
        payload: Prisma.$MealPlanPayload<ExtArgs>
        fields: Prisma.MealPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          findFirst: {
            args: Prisma.MealPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          findMany: {
            args: Prisma.MealPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>[]
          }
          create: {
            args: Prisma.MealPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          createMany: {
            args: Prisma.MealPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>[]
          }
          delete: {
            args: Prisma.MealPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          update: {
            args: Prisma.MealPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          deleteMany: {
            args: Prisma.MealPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MealPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          aggregate: {
            args: Prisma.MealPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMealPlan>
          }
          groupBy: {
            args: Prisma.MealPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealPlanCountArgs<ExtArgs>
            result: $Utils.Optional<MealPlanCountAggregateOutputType> | number
          }
        }
      }
      MenuItem: {
        payload: Prisma.$MenuItemPayload<ExtArgs>
        fields: Prisma.MenuItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findFirst: {
            args: Prisma.MenuItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findMany: {
            args: Prisma.MenuItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          create: {
            args: Prisma.MenuItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          createMany: {
            args: Prisma.MenuItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          delete: {
            args: Prisma.MenuItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          update: {
            args: Prisma.MenuItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItem>
          }
          groupBy: {
            args: Prisma.MenuItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemCountAggregateOutputType> | number
          }
        }
      }
      Meal: {
        payload: Prisma.$MealPayload<ExtArgs>
        fields: Prisma.MealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          findFirst: {
            args: Prisma.MealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          findMany: {
            args: Prisma.MealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          create: {
            args: Prisma.MealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          createMany: {
            args: Prisma.MealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          delete: {
            args: Prisma.MealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          update: {
            args: Prisma.MealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          deleteMany: {
            args: Prisma.MealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          aggregate: {
            args: Prisma.MealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeal>
          }
          groupBy: {
            args: Prisma.MealGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealCountArgs<ExtArgs>
            result: $Utils.Optional<MealCountAggregateOutputType> | number
          }
        }
      }
      DailyStat: {
        payload: Prisma.$DailyStatPayload<ExtArgs>
        fields: Prisma.DailyStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          findFirst: {
            args: Prisma.DailyStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          findMany: {
            args: Prisma.DailyStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>[]
          }
          create: {
            args: Prisma.DailyStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          createMany: {
            args: Prisma.DailyStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>[]
          }
          delete: {
            args: Prisma.DailyStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          update: {
            args: Prisma.DailyStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          deleteMany: {
            args: Prisma.DailyStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          aggregate: {
            args: Prisma.DailyStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyStat>
          }
          groupBy: {
            args: Prisma.DailyStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyStatCountArgs<ExtArgs>
            result: $Utils.Optional<DailyStatCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      CoachRequest: {
        payload: Prisma.$CoachRequestPayload<ExtArgs>
        fields: Prisma.CoachRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          findFirst: {
            args: Prisma.CoachRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          findMany: {
            args: Prisma.CoachRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>[]
          }
          create: {
            args: Prisma.CoachRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          createMany: {
            args: Prisma.CoachRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>[]
          }
          delete: {
            args: Prisma.CoachRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          update: {
            args: Prisma.CoachRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          deleteMany: {
            args: Prisma.CoachRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachRequestPayload>
          }
          aggregate: {
            args: Prisma.CoachRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachRequest>
          }
          groupBy: {
            args: Prisma.CoachRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachRequestCountArgs<ExtArgs>
            result: $Utils.Optional<CoachRequestCountAggregateOutputType> | number
          }
        }
      }
      CoachPost: {
        payload: Prisma.$CoachPostPayload<ExtArgs>
        fields: Prisma.CoachPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>
          }
          findFirst: {
            args: Prisma.CoachPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>
          }
          findMany: {
            args: Prisma.CoachPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>[]
          }
          create: {
            args: Prisma.CoachPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>
          }
          createMany: {
            args: Prisma.CoachPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>[]
          }
          delete: {
            args: Prisma.CoachPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>
          }
          update: {
            args: Prisma.CoachPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>
          }
          deleteMany: {
            args: Prisma.CoachPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachPostPayload>
          }
          aggregate: {
            args: Prisma.CoachPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachPost>
          }
          groupBy: {
            args: Prisma.CoachPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachPostCountArgs<ExtArgs>
            result: $Utils.Optional<CoachPostCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CoachProfileCountOutputType
   */

  export type CoachProfileCountOutputType = {
    clients: number
    clientCoaches: number
    programs: number
    programTemplates: number
    sentMessages: number
    channels: number
    reviews: number
    posts: number
    coachRequests: number
  }

  export type CoachProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | CoachProfileCountOutputTypeCountClientsArgs
    clientCoaches?: boolean | CoachProfileCountOutputTypeCountClientCoachesArgs
    programs?: boolean | CoachProfileCountOutputTypeCountProgramsArgs
    programTemplates?: boolean | CoachProfileCountOutputTypeCountProgramTemplatesArgs
    sentMessages?: boolean | CoachProfileCountOutputTypeCountSentMessagesArgs
    channels?: boolean | CoachProfileCountOutputTypeCountChannelsArgs
    reviews?: boolean | CoachProfileCountOutputTypeCountReviewsArgs
    posts?: boolean | CoachProfileCountOutputTypeCountPostsArgs
    coachRequests?: boolean | CoachProfileCountOutputTypeCountCoachRequestsArgs
  }

  // Custom InputTypes
  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfileCountOutputType
     */
    select?: CoachProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientProfileWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountClientCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCoachWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountProgramTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramTemplateWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachPostWhereInput
  }

  /**
   * CoachProfileCountOutputType without action
   */
  export type CoachProfileCountOutputTypeCountCoachRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachRequestWhereInput
  }


  /**
   * Count Type ClientProfileCountOutputType
   */

  export type ClientProfileCountOutputType = {
    coaches: number
    stats: number
    meals: number
    receivedMessages: number
    reviews: number
    coachRequests: number
  }

  export type ClientProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coaches?: boolean | ClientProfileCountOutputTypeCountCoachesArgs
    stats?: boolean | ClientProfileCountOutputTypeCountStatsArgs
    meals?: boolean | ClientProfileCountOutputTypeCountMealsArgs
    receivedMessages?: boolean | ClientProfileCountOutputTypeCountReceivedMessagesArgs
    reviews?: boolean | ClientProfileCountOutputTypeCountReviewsArgs
    coachRequests?: boolean | ClientProfileCountOutputTypeCountCoachRequestsArgs
  }

  // Custom InputTypes
  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfileCountOutputType
     */
    select?: ClientProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCoachWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyStatWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ClientProfileCountOutputType without action
   */
  export type ClientProfileCountOutputTypeCountCoachRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachRequestWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    sessions: number
    mealPlans: number
    customGoals: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ProgramCountOutputTypeCountSessionsArgs
    mealPlans?: boolean | ProgramCountOutputTypeCountMealPlansArgs
    customGoals?: boolean | ProgramCountOutputTypeCountCustomGoalsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountMealPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountCustomGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomGoalWhereInput
  }


  /**
   * Count Type CustomGoalCountOutputType
   */

  export type CustomGoalCountOutputType = {
    completions: number
  }

  export type CustomGoalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | CustomGoalCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * CustomGoalCountOutputType without action
   */
  export type CustomGoalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoalCountOutputType
     */
    select?: CustomGoalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomGoalCountOutputType without action
   */
  export type CustomGoalCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalCompletionWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    exercises: number
    comments: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | SessionCountOutputTypeCountExercisesArgs
    comments?: boolean | SessionCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    setCompletions: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    setCompletions?: boolean | ExerciseCountOutputTypeCountSetCompletionsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountSetCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SetCompletionWhereInput
  }


  /**
   * Count Type MealPlanCountOutputType
   */

  export type MealPlanCountOutputType = {
    menuItems: number
  }

  export type MealPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItems?: boolean | MealPlanCountOutputTypeCountMenuItemsArgs
  }

  // Custom InputTypes
  /**
   * MealPlanCountOutputType without action
   */
  export type MealPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanCountOutputType
     */
    select?: MealPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MealPlanCountOutputType without action
   */
  export type MealPlanCountOutputTypeCountMenuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    birthDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    birthDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    firstName: number
    lastName: number
    phone: number
    birthDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    firstName?: true
    lastName?: true
    phone?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    firstName?: true
    lastName?: true
    phone?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    firstName?: true
    lastName?: true
    phone?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName: string | null
    lastName: string | null
    phone: string | null
    birthDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coachProfile?: boolean | User$coachProfileArgs<ExtArgs>
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coachProfile?: boolean | User$coachProfileArgs<ExtArgs>
    clientProfile?: boolean | User$clientProfileArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      coachProfile: Prisma.$CoachProfilePayload<ExtArgs> | null
      clientProfile: Prisma.$ClientProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: $Enums.UserRole
      firstName: string | null
      lastName: string | null
      phone: string | null
      birthDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coachProfile<T extends User$coachProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$coachProfileArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    clientProfile<T extends User$clientProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$clientProfileArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.coachProfile
   */
  export type User$coachProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    where?: CoachProfileWhereInput
  }

  /**
   * User.clientProfile
   */
  export type User$clientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    where?: ClientProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CoachProfile
   */

  export type AggregateCoachProfile = {
    _count: CoachProfileCountAggregateOutputType | null
    _avg: CoachProfileAvgAggregateOutputType | null
    _sum: CoachProfileSumAggregateOutputType | null
    _min: CoachProfileMinAggregateOutputType | null
    _max: CoachProfileMaxAggregateOutputType | null
  }

  export type CoachProfileAvgAggregateOutputType = {
    rating: number | null
    ratingCount: number | null
  }

  export type CoachProfileSumAggregateOutputType = {
    rating: number | null
    ratingCount: number | null
  }

  export type CoachProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    experience: string | null
    rating: number | null
    ratingCount: number | null
    profilePicture: string | null
    city: string | null
    isRemote: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    experience: string | null
    rating: number | null
    ratingCount: number | null
    profilePicture: string | null
    city: string | null
    isRemote: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachProfileCountAggregateOutputType = {
    id: number
    userId: number
    bio: number
    experience: number
    rating: number
    ratingCount: number
    profilePicture: number
    city: number
    isRemote: number
    trainingLocations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachProfileAvgAggregateInputType = {
    rating?: true
    ratingCount?: true
  }

  export type CoachProfileSumAggregateInputType = {
    rating?: true
    ratingCount?: true
  }

  export type CoachProfileMinAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    experience?: true
    rating?: true
    ratingCount?: true
    profilePicture?: true
    city?: true
    isRemote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    experience?: true
    rating?: true
    ratingCount?: true
    profilePicture?: true
    city?: true
    isRemote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachProfileCountAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    experience?: true
    rating?: true
    ratingCount?: true
    profilePicture?: true
    city?: true
    isRemote?: true
    trainingLocations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachProfile to aggregate.
     */
    where?: CoachProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachProfiles to fetch.
     */
    orderBy?: CoachProfileOrderByWithRelationInput | CoachProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachProfiles
    **/
    _count?: true | CoachProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoachProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoachProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachProfileMaxAggregateInputType
  }

  export type GetCoachProfileAggregateType<T extends CoachProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachProfile[P]>
      : GetScalarType<T[P], AggregateCoachProfile[P]>
  }




  export type CoachProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachProfileWhereInput
    orderBy?: CoachProfileOrderByWithAggregationInput | CoachProfileOrderByWithAggregationInput[]
    by: CoachProfileScalarFieldEnum[] | CoachProfileScalarFieldEnum
    having?: CoachProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachProfileCountAggregateInputType | true
    _avg?: CoachProfileAvgAggregateInputType
    _sum?: CoachProfileSumAggregateInputType
    _min?: CoachProfileMinAggregateInputType
    _max?: CoachProfileMaxAggregateInputType
  }

  export type CoachProfileGroupByOutputType = {
    id: string
    userId: string
    bio: string | null
    experience: string | null
    rating: number
    ratingCount: number
    profilePicture: string | null
    city: string | null
    isRemote: boolean
    trainingLocations: string[]
    createdAt: Date
    updatedAt: Date
    _count: CoachProfileCountAggregateOutputType | null
    _avg: CoachProfileAvgAggregateOutputType | null
    _sum: CoachProfileSumAggregateOutputType | null
    _min: CoachProfileMinAggregateOutputType | null
    _max: CoachProfileMaxAggregateOutputType | null
  }

  type GetCoachProfileGroupByPayload<T extends CoachProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CoachProfileGroupByOutputType[P]>
        }
      >
    >


  export type CoachProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    experience?: boolean
    rating?: boolean
    ratingCount?: boolean
    profilePicture?: boolean
    city?: boolean
    isRemote?: boolean
    trainingLocations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clients?: boolean | CoachProfile$clientsArgs<ExtArgs>
    clientCoaches?: boolean | CoachProfile$clientCoachesArgs<ExtArgs>
    programs?: boolean | CoachProfile$programsArgs<ExtArgs>
    programTemplates?: boolean | CoachProfile$programTemplatesArgs<ExtArgs>
    sentMessages?: boolean | CoachProfile$sentMessagesArgs<ExtArgs>
    channels?: boolean | CoachProfile$channelsArgs<ExtArgs>
    reviews?: boolean | CoachProfile$reviewsArgs<ExtArgs>
    posts?: boolean | CoachProfile$postsArgs<ExtArgs>
    coachRequests?: boolean | CoachProfile$coachRequestsArgs<ExtArgs>
    _count?: boolean | CoachProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachProfile"]>

  export type CoachProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    experience?: boolean
    rating?: boolean
    ratingCount?: boolean
    profilePicture?: boolean
    city?: boolean
    isRemote?: boolean
    trainingLocations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachProfile"]>

  export type CoachProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    bio?: boolean
    experience?: boolean
    rating?: boolean
    ratingCount?: boolean
    profilePicture?: boolean
    city?: boolean
    isRemote?: boolean
    trainingLocations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clients?: boolean | CoachProfile$clientsArgs<ExtArgs>
    clientCoaches?: boolean | CoachProfile$clientCoachesArgs<ExtArgs>
    programs?: boolean | CoachProfile$programsArgs<ExtArgs>
    programTemplates?: boolean | CoachProfile$programTemplatesArgs<ExtArgs>
    sentMessages?: boolean | CoachProfile$sentMessagesArgs<ExtArgs>
    channels?: boolean | CoachProfile$channelsArgs<ExtArgs>
    reviews?: boolean | CoachProfile$reviewsArgs<ExtArgs>
    posts?: boolean | CoachProfile$postsArgs<ExtArgs>
    coachRequests?: boolean | CoachProfile$coachRequestsArgs<ExtArgs>
    _count?: boolean | CoachProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoachProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoachProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clients: Prisma.$ClientProfilePayload<ExtArgs>[]
      clientCoaches: Prisma.$ClientCoachPayload<ExtArgs>[]
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      programTemplates: Prisma.$ProgramTemplatePayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      posts: Prisma.$CoachPostPayload<ExtArgs>[]
      coachRequests: Prisma.$CoachRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bio: string | null
      experience: string | null
      rating: number
      ratingCount: number
      profilePicture: string | null
      city: string | null
      isRemote: boolean
      trainingLocations: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachProfile"]>
    composites: {}
  }

  type CoachProfileGetPayload<S extends boolean | null | undefined | CoachProfileDefaultArgs> = $Result.GetResult<Prisma.$CoachProfilePayload, S>

  type CoachProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachProfileCountAggregateInputType | true
    }

  export interface CoachProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachProfile'], meta: { name: 'CoachProfile' } }
    /**
     * Find zero or one CoachProfile that matches the filter.
     * @param {CoachProfileFindUniqueArgs} args - Arguments to find a CoachProfile
     * @example
     * // Get one CoachProfile
     * const coachProfile = await prisma.coachProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachProfileFindUniqueArgs>(args: SelectSubset<T, CoachProfileFindUniqueArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachProfileFindUniqueOrThrowArgs} args - Arguments to find a CoachProfile
     * @example
     * // Get one CoachProfile
     * const coachProfile = await prisma.coachProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileFindFirstArgs} args - Arguments to find a CoachProfile
     * @example
     * // Get one CoachProfile
     * const coachProfile = await prisma.coachProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachProfileFindFirstArgs>(args?: SelectSubset<T, CoachProfileFindFirstArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileFindFirstOrThrowArgs} args - Arguments to find a CoachProfile
     * @example
     * // Get one CoachProfile
     * const coachProfile = await prisma.coachProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachProfiles
     * const coachProfiles = await prisma.coachProfile.findMany()
     * 
     * // Get first 10 CoachProfiles
     * const coachProfiles = await prisma.coachProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachProfileWithIdOnly = await prisma.coachProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachProfileFindManyArgs>(args?: SelectSubset<T, CoachProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachProfile.
     * @param {CoachProfileCreateArgs} args - Arguments to create a CoachProfile.
     * @example
     * // Create one CoachProfile
     * const CoachProfile = await prisma.coachProfile.create({
     *   data: {
     *     // ... data to create a CoachProfile
     *   }
     * })
     * 
     */
    create<T extends CoachProfileCreateArgs>(args: SelectSubset<T, CoachProfileCreateArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachProfiles.
     * @param {CoachProfileCreateManyArgs} args - Arguments to create many CoachProfiles.
     * @example
     * // Create many CoachProfiles
     * const coachProfile = await prisma.coachProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachProfileCreateManyArgs>(args?: SelectSubset<T, CoachProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachProfiles and returns the data saved in the database.
     * @param {CoachProfileCreateManyAndReturnArgs} args - Arguments to create many CoachProfiles.
     * @example
     * // Create many CoachProfiles
     * const coachProfile = await prisma.coachProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachProfiles and only return the `id`
     * const coachProfileWithIdOnly = await prisma.coachProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachProfile.
     * @param {CoachProfileDeleteArgs} args - Arguments to delete one CoachProfile.
     * @example
     * // Delete one CoachProfile
     * const CoachProfile = await prisma.coachProfile.delete({
     *   where: {
     *     // ... filter to delete one CoachProfile
     *   }
     * })
     * 
     */
    delete<T extends CoachProfileDeleteArgs>(args: SelectSubset<T, CoachProfileDeleteArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachProfile.
     * @param {CoachProfileUpdateArgs} args - Arguments to update one CoachProfile.
     * @example
     * // Update one CoachProfile
     * const coachProfile = await prisma.coachProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachProfileUpdateArgs>(args: SelectSubset<T, CoachProfileUpdateArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachProfiles.
     * @param {CoachProfileDeleteManyArgs} args - Arguments to filter CoachProfiles to delete.
     * @example
     * // Delete a few CoachProfiles
     * const { count } = await prisma.coachProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachProfileDeleteManyArgs>(args?: SelectSubset<T, CoachProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachProfiles
     * const coachProfile = await prisma.coachProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachProfileUpdateManyArgs>(args: SelectSubset<T, CoachProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachProfile.
     * @param {CoachProfileUpsertArgs} args - Arguments to update or create a CoachProfile.
     * @example
     * // Update or create a CoachProfile
     * const coachProfile = await prisma.coachProfile.upsert({
     *   create: {
     *     // ... data to create a CoachProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachProfile we want to update
     *   }
     * })
     */
    upsert<T extends CoachProfileUpsertArgs>(args: SelectSubset<T, CoachProfileUpsertArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileCountArgs} args - Arguments to filter CoachProfiles to count.
     * @example
     * // Count the number of CoachProfiles
     * const count = await prisma.coachProfile.count({
     *   where: {
     *     // ... the filter for the CoachProfiles we want to count
     *   }
     * })
    **/
    count<T extends CoachProfileCountArgs>(
      args?: Subset<T, CoachProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachProfileAggregateArgs>(args: Subset<T, CoachProfileAggregateArgs>): Prisma.PrismaPromise<GetCoachProfileAggregateType<T>>

    /**
     * Group by CoachProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachProfileGroupByArgs['orderBy'] }
        : { orderBy?: CoachProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachProfile model
   */
  readonly fields: CoachProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clients<T extends CoachProfile$clientsArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findMany"> | Null>
    clientCoaches<T extends CoachProfile$clientCoachesArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$clientCoachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findMany"> | Null>
    programs<T extends CoachProfile$programsArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany"> | Null>
    programTemplates<T extends CoachProfile$programTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$programTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends CoachProfile$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends CoachProfile$channelsArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends CoachProfile$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends CoachProfile$postsArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "findMany"> | Null>
    coachRequests<T extends CoachProfile$coachRequestsArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfile$coachRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachProfile model
   */ 
  interface CoachProfileFieldRefs {
    readonly id: FieldRef<"CoachProfile", 'String'>
    readonly userId: FieldRef<"CoachProfile", 'String'>
    readonly bio: FieldRef<"CoachProfile", 'String'>
    readonly experience: FieldRef<"CoachProfile", 'String'>
    readonly rating: FieldRef<"CoachProfile", 'Float'>
    readonly ratingCount: FieldRef<"CoachProfile", 'Int'>
    readonly profilePicture: FieldRef<"CoachProfile", 'String'>
    readonly city: FieldRef<"CoachProfile", 'String'>
    readonly isRemote: FieldRef<"CoachProfile", 'Boolean'>
    readonly trainingLocations: FieldRef<"CoachProfile", 'String[]'>
    readonly createdAt: FieldRef<"CoachProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachProfile findUnique
   */
  export type CoachProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * Filter, which CoachProfile to fetch.
     */
    where: CoachProfileWhereUniqueInput
  }

  /**
   * CoachProfile findUniqueOrThrow
   */
  export type CoachProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * Filter, which CoachProfile to fetch.
     */
    where: CoachProfileWhereUniqueInput
  }

  /**
   * CoachProfile findFirst
   */
  export type CoachProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * Filter, which CoachProfile to fetch.
     */
    where?: CoachProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachProfiles to fetch.
     */
    orderBy?: CoachProfileOrderByWithRelationInput | CoachProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachProfiles.
     */
    cursor?: CoachProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachProfiles.
     */
    distinct?: CoachProfileScalarFieldEnum | CoachProfileScalarFieldEnum[]
  }

  /**
   * CoachProfile findFirstOrThrow
   */
  export type CoachProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * Filter, which CoachProfile to fetch.
     */
    where?: CoachProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachProfiles to fetch.
     */
    orderBy?: CoachProfileOrderByWithRelationInput | CoachProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachProfiles.
     */
    cursor?: CoachProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachProfiles.
     */
    distinct?: CoachProfileScalarFieldEnum | CoachProfileScalarFieldEnum[]
  }

  /**
   * CoachProfile findMany
   */
  export type CoachProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * Filter, which CoachProfiles to fetch.
     */
    where?: CoachProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachProfiles to fetch.
     */
    orderBy?: CoachProfileOrderByWithRelationInput | CoachProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachProfiles.
     */
    cursor?: CoachProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachProfiles.
     */
    skip?: number
    distinct?: CoachProfileScalarFieldEnum | CoachProfileScalarFieldEnum[]
  }

  /**
   * CoachProfile create
   */
  export type CoachProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachProfile.
     */
    data: XOR<CoachProfileCreateInput, CoachProfileUncheckedCreateInput>
  }

  /**
   * CoachProfile createMany
   */
  export type CoachProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachProfiles.
     */
    data: CoachProfileCreateManyInput | CoachProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachProfile createManyAndReturn
   */
  export type CoachProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachProfiles.
     */
    data: CoachProfileCreateManyInput | CoachProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachProfile update
   */
  export type CoachProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachProfile.
     */
    data: XOR<CoachProfileUpdateInput, CoachProfileUncheckedUpdateInput>
    /**
     * Choose, which CoachProfile to update.
     */
    where: CoachProfileWhereUniqueInput
  }

  /**
   * CoachProfile updateMany
   */
  export type CoachProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachProfiles.
     */
    data: XOR<CoachProfileUpdateManyMutationInput, CoachProfileUncheckedUpdateManyInput>
    /**
     * Filter which CoachProfiles to update
     */
    where?: CoachProfileWhereInput
  }

  /**
   * CoachProfile upsert
   */
  export type CoachProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachProfile to update in case it exists.
     */
    where: CoachProfileWhereUniqueInput
    /**
     * In case the CoachProfile found by the `where` argument doesn't exist, create a new CoachProfile with this data.
     */
    create: XOR<CoachProfileCreateInput, CoachProfileUncheckedCreateInput>
    /**
     * In case the CoachProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachProfileUpdateInput, CoachProfileUncheckedUpdateInput>
  }

  /**
   * CoachProfile delete
   */
  export type CoachProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    /**
     * Filter which CoachProfile to delete.
     */
    where: CoachProfileWhereUniqueInput
  }

  /**
   * CoachProfile deleteMany
   */
  export type CoachProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachProfiles to delete
     */
    where?: CoachProfileWhereInput
  }

  /**
   * CoachProfile.clients
   */
  export type CoachProfile$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    where?: ClientProfileWhereInput
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    cursor?: ClientProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * CoachProfile.clientCoaches
   */
  export type CoachProfile$clientCoachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    where?: ClientCoachWhereInput
    orderBy?: ClientCoachOrderByWithRelationInput | ClientCoachOrderByWithRelationInput[]
    cursor?: ClientCoachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientCoachScalarFieldEnum | ClientCoachScalarFieldEnum[]
  }

  /**
   * CoachProfile.programs
   */
  export type CoachProfile$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * CoachProfile.programTemplates
   */
  export type CoachProfile$programTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    where?: ProgramTemplateWhereInput
    orderBy?: ProgramTemplateOrderByWithRelationInput | ProgramTemplateOrderByWithRelationInput[]
    cursor?: ProgramTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramTemplateScalarFieldEnum | ProgramTemplateScalarFieldEnum[]
  }

  /**
   * CoachProfile.sentMessages
   */
  export type CoachProfile$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * CoachProfile.channels
   */
  export type CoachProfile$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * CoachProfile.reviews
   */
  export type CoachProfile$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * CoachProfile.posts
   */
  export type CoachProfile$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    where?: CoachPostWhereInput
    orderBy?: CoachPostOrderByWithRelationInput | CoachPostOrderByWithRelationInput[]
    cursor?: CoachPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachPostScalarFieldEnum | CoachPostScalarFieldEnum[]
  }

  /**
   * CoachProfile.coachRequests
   */
  export type CoachProfile$coachRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    where?: CoachRequestWhereInput
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    cursor?: CoachRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachProfile without action
   */
  export type CoachProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
  }


  /**
   * Model ClientProfile
   */

  export type AggregateClientProfile = {
    _count: ClientProfileCountAggregateOutputType | null
    _avg: ClientProfileAvgAggregateOutputType | null
    _sum: ClientProfileSumAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  export type ClientProfileAvgAggregateOutputType = {
    weight: number | null
    height: number | null
  }

  export type ClientProfileSumAggregateOutputType = {
    weight: number | null
    height: number | null
  }

  export type ClientProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coachId: string | null
    weight: number | null
    height: number | null
    dateOfBirth: Date | null
    gender: string | null
    goals: string | null
    level: string | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coachId: string | null
    weight: number | null
    height: number | null
    dateOfBirth: Date | null
    gender: string | null
    goals: string | null
    level: string | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientProfileCountAggregateOutputType = {
    id: number
    userId: number
    coachId: number
    weight: number
    height: number
    dateOfBirth: number
    gender: number
    goals: number
    level: number
    profilePicture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientProfileAvgAggregateInputType = {
    weight?: true
    height?: true
  }

  export type ClientProfileSumAggregateInputType = {
    weight?: true
    height?: true
  }

  export type ClientProfileMinAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    weight?: true
    height?: true
    dateOfBirth?: true
    gender?: true
    goals?: true
    level?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    weight?: true
    height?: true
    dateOfBirth?: true
    gender?: true
    goals?: true
    level?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientProfileCountAggregateInputType = {
    id?: true
    userId?: true
    coachId?: true
    weight?: true
    height?: true
    dateOfBirth?: true
    gender?: true
    goals?: true
    level?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfile to aggregate.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientProfiles
    **/
    _count?: true | ClientProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientProfileMaxAggregateInputType
  }

  export type GetClientProfileAggregateType<T extends ClientProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateClientProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientProfile[P]>
      : GetScalarType<T[P], AggregateClientProfile[P]>
  }




  export type ClientProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientProfileWhereInput
    orderBy?: ClientProfileOrderByWithAggregationInput | ClientProfileOrderByWithAggregationInput[]
    by: ClientProfileScalarFieldEnum[] | ClientProfileScalarFieldEnum
    having?: ClientProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientProfileCountAggregateInputType | true
    _avg?: ClientProfileAvgAggregateInputType
    _sum?: ClientProfileSumAggregateInputType
    _min?: ClientProfileMinAggregateInputType
    _max?: ClientProfileMaxAggregateInputType
  }

  export type ClientProfileGroupByOutputType = {
    id: string
    userId: string
    coachId: string | null
    weight: number | null
    height: number | null
    dateOfBirth: Date | null
    gender: string | null
    goals: string | null
    level: string | null
    profilePicture: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientProfileCountAggregateOutputType | null
    _avg: ClientProfileAvgAggregateOutputType | null
    _sum: ClientProfileSumAggregateOutputType | null
    _min: ClientProfileMinAggregateOutputType | null
    _max: ClientProfileMaxAggregateOutputType | null
  }

  type GetClientProfileGroupByPayload<T extends ClientProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ClientProfileGroupByOutputType[P]>
        }
      >
    >


  export type ClientProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coachId?: boolean
    weight?: boolean
    height?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    level?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | ClientProfile$coachArgs<ExtArgs>
    coaches?: boolean | ClientProfile$coachesArgs<ExtArgs>
    stats?: boolean | ClientProfile$statsArgs<ExtArgs>
    meals?: boolean | ClientProfile$mealsArgs<ExtArgs>
    receivedMessages?: boolean | ClientProfile$receivedMessagesArgs<ExtArgs>
    reviews?: boolean | ClientProfile$reviewsArgs<ExtArgs>
    coachRequests?: boolean | ClientProfile$coachRequestsArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coachId?: boolean
    weight?: boolean
    height?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    level?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | ClientProfile$coachArgs<ExtArgs>
  }, ExtArgs["result"]["clientProfile"]>

  export type ClientProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    coachId?: boolean
    weight?: boolean
    height?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    goals?: boolean
    level?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | ClientProfile$coachArgs<ExtArgs>
    coaches?: boolean | ClientProfile$coachesArgs<ExtArgs>
    stats?: boolean | ClientProfile$statsArgs<ExtArgs>
    meals?: boolean | ClientProfile$mealsArgs<ExtArgs>
    receivedMessages?: boolean | ClientProfile$receivedMessagesArgs<ExtArgs>
    reviews?: boolean | ClientProfile$reviewsArgs<ExtArgs>
    coachRequests?: boolean | ClientProfile$coachRequestsArgs<ExtArgs>
    _count?: boolean | ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coach?: boolean | ClientProfile$coachArgs<ExtArgs>
  }

  export type $ClientProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coach: Prisma.$CoachProfilePayload<ExtArgs> | null
      coaches: Prisma.$ClientCoachPayload<ExtArgs>[]
      stats: Prisma.$DailyStatPayload<ExtArgs>[]
      meals: Prisma.$MealPayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      coachRequests: Prisma.$CoachRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coachId: string | null
      weight: number | null
      height: number | null
      dateOfBirth: Date | null
      gender: string | null
      goals: string | null
      level: string | null
      profilePicture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientProfile"]>
    composites: {}
  }

  type ClientProfileGetPayload<S extends boolean | null | undefined | ClientProfileDefaultArgs> = $Result.GetResult<Prisma.$ClientProfilePayload, S>

  type ClientProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientProfileCountAggregateInputType | true
    }

  export interface ClientProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientProfile'], meta: { name: 'ClientProfile' } }
    /**
     * Find zero or one ClientProfile that matches the filter.
     * @param {ClientProfileFindUniqueArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientProfileFindUniqueArgs>(args: SelectSubset<T, ClientProfileFindUniqueArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientProfileFindUniqueOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientProfileFindFirstArgs>(args?: SelectSubset<T, ClientProfileFindFirstArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindFirstOrThrowArgs} args - Arguments to find a ClientProfile
     * @example
     * // Get one ClientProfile
     * const clientProfile = await prisma.clientProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany()
     * 
     * // Get first 10 ClientProfiles
     * const clientProfiles = await prisma.clientProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientProfileFindManyArgs>(args?: SelectSubset<T, ClientProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientProfile.
     * @param {ClientProfileCreateArgs} args - Arguments to create a ClientProfile.
     * @example
     * // Create one ClientProfile
     * const ClientProfile = await prisma.clientProfile.create({
     *   data: {
     *     // ... data to create a ClientProfile
     *   }
     * })
     * 
     */
    create<T extends ClientProfileCreateArgs>(args: SelectSubset<T, ClientProfileCreateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientProfiles.
     * @param {ClientProfileCreateManyArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientProfileCreateManyArgs>(args?: SelectSubset<T, ClientProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientProfiles and returns the data saved in the database.
     * @param {ClientProfileCreateManyAndReturnArgs} args - Arguments to create many ClientProfiles.
     * @example
     * // Create many ClientProfiles
     * const clientProfile = await prisma.clientProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientProfiles and only return the `id`
     * const clientProfileWithIdOnly = await prisma.clientProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientProfile.
     * @param {ClientProfileDeleteArgs} args - Arguments to delete one ClientProfile.
     * @example
     * // Delete one ClientProfile
     * const ClientProfile = await prisma.clientProfile.delete({
     *   where: {
     *     // ... filter to delete one ClientProfile
     *   }
     * })
     * 
     */
    delete<T extends ClientProfileDeleteArgs>(args: SelectSubset<T, ClientProfileDeleteArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientProfile.
     * @param {ClientProfileUpdateArgs} args - Arguments to update one ClientProfile.
     * @example
     * // Update one ClientProfile
     * const clientProfile = await prisma.clientProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientProfileUpdateArgs>(args: SelectSubset<T, ClientProfileUpdateArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientProfiles.
     * @param {ClientProfileDeleteManyArgs} args - Arguments to filter ClientProfiles to delete.
     * @example
     * // Delete a few ClientProfiles
     * const { count } = await prisma.clientProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientProfileDeleteManyArgs>(args?: SelectSubset<T, ClientProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientProfiles
     * const clientProfile = await prisma.clientProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientProfileUpdateManyArgs>(args: SelectSubset<T, ClientProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientProfile.
     * @param {ClientProfileUpsertArgs} args - Arguments to update or create a ClientProfile.
     * @example
     * // Update or create a ClientProfile
     * const clientProfile = await prisma.clientProfile.upsert({
     *   create: {
     *     // ... data to create a ClientProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientProfile we want to update
     *   }
     * })
     */
    upsert<T extends ClientProfileUpsertArgs>(args: SelectSubset<T, ClientProfileUpsertArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileCountArgs} args - Arguments to filter ClientProfiles to count.
     * @example
     * // Count the number of ClientProfiles
     * const count = await prisma.clientProfile.count({
     *   where: {
     *     // ... the filter for the ClientProfiles we want to count
     *   }
     * })
    **/
    count<T extends ClientProfileCountArgs>(
      args?: Subset<T, ClientProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientProfileAggregateArgs>(args: Subset<T, ClientProfileAggregateArgs>): Prisma.PrismaPromise<GetClientProfileAggregateType<T>>

    /**
     * Group by ClientProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientProfileGroupByArgs['orderBy'] }
        : { orderBy?: ClientProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientProfile model
   */
  readonly fields: ClientProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    coach<T extends ClientProfile$coachArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$coachArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    coaches<T extends ClientProfile$coachesArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$coachesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findMany"> | Null>
    stats<T extends ClientProfile$statsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findMany"> | Null>
    meals<T extends ClientProfile$mealsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$mealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends ClientProfile$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends ClientProfile$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    coachRequests<T extends ClientProfile$coachRequestsArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfile$coachRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientProfile model
   */ 
  interface ClientProfileFieldRefs {
    readonly id: FieldRef<"ClientProfile", 'String'>
    readonly userId: FieldRef<"ClientProfile", 'String'>
    readonly coachId: FieldRef<"ClientProfile", 'String'>
    readonly weight: FieldRef<"ClientProfile", 'Float'>
    readonly height: FieldRef<"ClientProfile", 'Float'>
    readonly dateOfBirth: FieldRef<"ClientProfile", 'DateTime'>
    readonly gender: FieldRef<"ClientProfile", 'String'>
    readonly goals: FieldRef<"ClientProfile", 'String'>
    readonly level: FieldRef<"ClientProfile", 'String'>
    readonly profilePicture: FieldRef<"ClientProfile", 'String'>
    readonly createdAt: FieldRef<"ClientProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientProfile findUnique
   */
  export type ClientProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findUniqueOrThrow
   */
  export type ClientProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile findFirst
   */
  export type ClientProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findFirstOrThrow
   */
  export type ClientProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfile to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientProfiles.
     */
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile findMany
   */
  export type ClientProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter, which ClientProfiles to fetch.
     */
    where?: ClientProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientProfiles to fetch.
     */
    orderBy?: ClientProfileOrderByWithRelationInput | ClientProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientProfiles.
     */
    cursor?: ClientProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientProfiles.
     */
    skip?: number
    distinct?: ClientProfileScalarFieldEnum | ClientProfileScalarFieldEnum[]
  }

  /**
   * ClientProfile create
   */
  export type ClientProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientProfile.
     */
    data: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
  }

  /**
   * ClientProfile createMany
   */
  export type ClientProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientProfile createManyAndReturn
   */
  export type ClientProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientProfiles.
     */
    data: ClientProfileCreateManyInput | ClientProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientProfile update
   */
  export type ClientProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientProfile.
     */
    data: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
    /**
     * Choose, which ClientProfile to update.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile updateMany
   */
  export type ClientProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientProfiles.
     */
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyInput>
    /**
     * Filter which ClientProfiles to update
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile upsert
   */
  export type ClientProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientProfile to update in case it exists.
     */
    where: ClientProfileWhereUniqueInput
    /**
     * In case the ClientProfile found by the `where` argument doesn't exist, create a new ClientProfile with this data.
     */
    create: XOR<ClientProfileCreateInput, ClientProfileUncheckedCreateInput>
    /**
     * In case the ClientProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientProfileUpdateInput, ClientProfileUncheckedUpdateInput>
  }

  /**
   * ClientProfile delete
   */
  export type ClientProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
    /**
     * Filter which ClientProfile to delete.
     */
    where: ClientProfileWhereUniqueInput
  }

  /**
   * ClientProfile deleteMany
   */
  export type ClientProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientProfiles to delete
     */
    where?: ClientProfileWhereInput
  }

  /**
   * ClientProfile.coach
   */
  export type ClientProfile$coachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachProfile
     */
    select?: CoachProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachProfileInclude<ExtArgs> | null
    where?: CoachProfileWhereInput
  }

  /**
   * ClientProfile.coaches
   */
  export type ClientProfile$coachesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    where?: ClientCoachWhereInput
    orderBy?: ClientCoachOrderByWithRelationInput | ClientCoachOrderByWithRelationInput[]
    cursor?: ClientCoachWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientCoachScalarFieldEnum | ClientCoachScalarFieldEnum[]
  }

  /**
   * ClientProfile.stats
   */
  export type ClientProfile$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    where?: DailyStatWhereInput
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    cursor?: DailyStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * ClientProfile.meals
   */
  export type ClientProfile$mealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    where?: MealWhereInput
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    cursor?: MealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * ClientProfile.receivedMessages
   */
  export type ClientProfile$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * ClientProfile.reviews
   */
  export type ClientProfile$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * ClientProfile.coachRequests
   */
  export type ClientProfile$coachRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    where?: CoachRequestWhereInput
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    cursor?: CoachRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * ClientProfile without action
   */
  export type ClientProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientProfile
     */
    select?: ClientProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientProfileInclude<ExtArgs> | null
  }


  /**
   * Model ClientCoach
   */

  export type AggregateClientCoach = {
    _count: ClientCoachCountAggregateOutputType | null
    _min: ClientCoachMinAggregateOutputType | null
    _max: ClientCoachMaxAggregateOutputType | null
  }

  export type ClientCoachMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    coachId: string | null
    isPrimary: boolean | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCoachMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    coachId: string | null
    isPrimary: boolean | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCoachCountAggregateOutputType = {
    id: number
    clientId: number
    coachId: number
    isPrimary: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientCoachMinAggregateInputType = {
    id?: true
    clientId?: true
    coachId?: true
    isPrimary?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCoachMaxAggregateInputType = {
    id?: true
    clientId?: true
    coachId?: true
    isPrimary?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCoachCountAggregateInputType = {
    id?: true
    clientId?: true
    coachId?: true
    isPrimary?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientCoachAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCoach to aggregate.
     */
    where?: ClientCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCoaches to fetch.
     */
    orderBy?: ClientCoachOrderByWithRelationInput | ClientCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientCoaches
    **/
    _count?: true | ClientCoachCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientCoachMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientCoachMaxAggregateInputType
  }

  export type GetClientCoachAggregateType<T extends ClientCoachAggregateArgs> = {
        [P in keyof T & keyof AggregateClientCoach]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientCoach[P]>
      : GetScalarType<T[P], AggregateClientCoach[P]>
  }




  export type ClientCoachGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientCoachWhereInput
    orderBy?: ClientCoachOrderByWithAggregationInput | ClientCoachOrderByWithAggregationInput[]
    by: ClientCoachScalarFieldEnum[] | ClientCoachScalarFieldEnum
    having?: ClientCoachScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCoachCountAggregateInputType | true
    _min?: ClientCoachMinAggregateInputType
    _max?: ClientCoachMaxAggregateInputType
  }

  export type ClientCoachGroupByOutputType = {
    id: string
    clientId: string
    coachId: string
    isPrimary: boolean
    startDate: Date
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClientCoachCountAggregateOutputType | null
    _min: ClientCoachMinAggregateOutputType | null
    _max: ClientCoachMaxAggregateOutputType | null
  }

  type GetClientCoachGroupByPayload<T extends ClientCoachGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientCoachGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientCoachGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientCoachGroupByOutputType[P]>
            : GetScalarType<T[P], ClientCoachGroupByOutputType[P]>
        }
      >
    >


  export type ClientCoachSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    coachId?: boolean
    isPrimary?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientCoach"]>

  export type ClientCoachSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    coachId?: boolean
    isPrimary?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientCoach"]>

  export type ClientCoachSelectScalar = {
    id?: boolean
    clientId?: boolean
    coachId?: boolean
    isPrimary?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientCoachInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }
  export type ClientCoachIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }

  export type $ClientCoachPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientCoach"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
      coach: Prisma.$CoachProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      coachId: string
      isPrimary: boolean
      startDate: Date
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientCoach"]>
    composites: {}
  }

  type ClientCoachGetPayload<S extends boolean | null | undefined | ClientCoachDefaultArgs> = $Result.GetResult<Prisma.$ClientCoachPayload, S>

  type ClientCoachCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientCoachFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCoachCountAggregateInputType | true
    }

  export interface ClientCoachDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientCoach'], meta: { name: 'ClientCoach' } }
    /**
     * Find zero or one ClientCoach that matches the filter.
     * @param {ClientCoachFindUniqueArgs} args - Arguments to find a ClientCoach
     * @example
     * // Get one ClientCoach
     * const clientCoach = await prisma.clientCoach.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientCoachFindUniqueArgs>(args: SelectSubset<T, ClientCoachFindUniqueArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClientCoach that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientCoachFindUniqueOrThrowArgs} args - Arguments to find a ClientCoach
     * @example
     * // Get one ClientCoach
     * const clientCoach = await prisma.clientCoach.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientCoachFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientCoachFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClientCoach that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachFindFirstArgs} args - Arguments to find a ClientCoach
     * @example
     * // Get one ClientCoach
     * const clientCoach = await prisma.clientCoach.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientCoachFindFirstArgs>(args?: SelectSubset<T, ClientCoachFindFirstArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClientCoach that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachFindFirstOrThrowArgs} args - Arguments to find a ClientCoach
     * @example
     * // Get one ClientCoach
     * const clientCoach = await prisma.clientCoach.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientCoachFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientCoachFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClientCoaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientCoaches
     * const clientCoaches = await prisma.clientCoach.findMany()
     * 
     * // Get first 10 ClientCoaches
     * const clientCoaches = await prisma.clientCoach.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientCoachWithIdOnly = await prisma.clientCoach.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientCoachFindManyArgs>(args?: SelectSubset<T, ClientCoachFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClientCoach.
     * @param {ClientCoachCreateArgs} args - Arguments to create a ClientCoach.
     * @example
     * // Create one ClientCoach
     * const ClientCoach = await prisma.clientCoach.create({
     *   data: {
     *     // ... data to create a ClientCoach
     *   }
     * })
     * 
     */
    create<T extends ClientCoachCreateArgs>(args: SelectSubset<T, ClientCoachCreateArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClientCoaches.
     * @param {ClientCoachCreateManyArgs} args - Arguments to create many ClientCoaches.
     * @example
     * // Create many ClientCoaches
     * const clientCoach = await prisma.clientCoach.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCoachCreateManyArgs>(args?: SelectSubset<T, ClientCoachCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientCoaches and returns the data saved in the database.
     * @param {ClientCoachCreateManyAndReturnArgs} args - Arguments to create many ClientCoaches.
     * @example
     * // Create many ClientCoaches
     * const clientCoach = await prisma.clientCoach.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientCoaches and only return the `id`
     * const clientCoachWithIdOnly = await prisma.clientCoach.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCoachCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCoachCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClientCoach.
     * @param {ClientCoachDeleteArgs} args - Arguments to delete one ClientCoach.
     * @example
     * // Delete one ClientCoach
     * const ClientCoach = await prisma.clientCoach.delete({
     *   where: {
     *     // ... filter to delete one ClientCoach
     *   }
     * })
     * 
     */
    delete<T extends ClientCoachDeleteArgs>(args: SelectSubset<T, ClientCoachDeleteArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClientCoach.
     * @param {ClientCoachUpdateArgs} args - Arguments to update one ClientCoach.
     * @example
     * // Update one ClientCoach
     * const clientCoach = await prisma.clientCoach.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientCoachUpdateArgs>(args: SelectSubset<T, ClientCoachUpdateArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClientCoaches.
     * @param {ClientCoachDeleteManyArgs} args - Arguments to filter ClientCoaches to delete.
     * @example
     * // Delete a few ClientCoaches
     * const { count } = await prisma.clientCoach.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientCoachDeleteManyArgs>(args?: SelectSubset<T, ClientCoachDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientCoaches
     * const clientCoach = await prisma.clientCoach.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientCoachUpdateManyArgs>(args: SelectSubset<T, ClientCoachUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientCoach.
     * @param {ClientCoachUpsertArgs} args - Arguments to update or create a ClientCoach.
     * @example
     * // Update or create a ClientCoach
     * const clientCoach = await prisma.clientCoach.upsert({
     *   create: {
     *     // ... data to create a ClientCoach
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientCoach we want to update
     *   }
     * })
     */
    upsert<T extends ClientCoachUpsertArgs>(args: SelectSubset<T, ClientCoachUpsertArgs<ExtArgs>>): Prisma__ClientCoachClient<$Result.GetResult<Prisma.$ClientCoachPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClientCoaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachCountArgs} args - Arguments to filter ClientCoaches to count.
     * @example
     * // Count the number of ClientCoaches
     * const count = await prisma.clientCoach.count({
     *   where: {
     *     // ... the filter for the ClientCoaches we want to count
     *   }
     * })
    **/
    count<T extends ClientCoachCountArgs>(
      args?: Subset<T, ClientCoachCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCoachCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientCoachAggregateArgs>(args: Subset<T, ClientCoachAggregateArgs>): Prisma.PrismaPromise<GetClientCoachAggregateType<T>>

    /**
     * Group by ClientCoach.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCoachGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientCoachGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientCoachGroupByArgs['orderBy'] }
        : { orderBy?: ClientCoachGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientCoachGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientCoachGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientCoach model
   */
  readonly fields: ClientCoachFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientCoach.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientCoachClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientCoach model
   */ 
  interface ClientCoachFieldRefs {
    readonly id: FieldRef<"ClientCoach", 'String'>
    readonly clientId: FieldRef<"ClientCoach", 'String'>
    readonly coachId: FieldRef<"ClientCoach", 'String'>
    readonly isPrimary: FieldRef<"ClientCoach", 'Boolean'>
    readonly startDate: FieldRef<"ClientCoach", 'DateTime'>
    readonly endDate: FieldRef<"ClientCoach", 'DateTime'>
    readonly isActive: FieldRef<"ClientCoach", 'Boolean'>
    readonly createdAt: FieldRef<"ClientCoach", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientCoach", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientCoach findUnique
   */
  export type ClientCoachFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * Filter, which ClientCoach to fetch.
     */
    where: ClientCoachWhereUniqueInput
  }

  /**
   * ClientCoach findUniqueOrThrow
   */
  export type ClientCoachFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * Filter, which ClientCoach to fetch.
     */
    where: ClientCoachWhereUniqueInput
  }

  /**
   * ClientCoach findFirst
   */
  export type ClientCoachFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * Filter, which ClientCoach to fetch.
     */
    where?: ClientCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCoaches to fetch.
     */
    orderBy?: ClientCoachOrderByWithRelationInput | ClientCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCoaches.
     */
    cursor?: ClientCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCoaches.
     */
    distinct?: ClientCoachScalarFieldEnum | ClientCoachScalarFieldEnum[]
  }

  /**
   * ClientCoach findFirstOrThrow
   */
  export type ClientCoachFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * Filter, which ClientCoach to fetch.
     */
    where?: ClientCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCoaches to fetch.
     */
    orderBy?: ClientCoachOrderByWithRelationInput | ClientCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientCoaches.
     */
    cursor?: ClientCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCoaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientCoaches.
     */
    distinct?: ClientCoachScalarFieldEnum | ClientCoachScalarFieldEnum[]
  }

  /**
   * ClientCoach findMany
   */
  export type ClientCoachFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * Filter, which ClientCoaches to fetch.
     */
    where?: ClientCoachWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientCoaches to fetch.
     */
    orderBy?: ClientCoachOrderByWithRelationInput | ClientCoachOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientCoaches.
     */
    cursor?: ClientCoachWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientCoaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientCoaches.
     */
    skip?: number
    distinct?: ClientCoachScalarFieldEnum | ClientCoachScalarFieldEnum[]
  }

  /**
   * ClientCoach create
   */
  export type ClientCoachCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientCoach.
     */
    data: XOR<ClientCoachCreateInput, ClientCoachUncheckedCreateInput>
  }

  /**
   * ClientCoach createMany
   */
  export type ClientCoachCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientCoaches.
     */
    data: ClientCoachCreateManyInput | ClientCoachCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientCoach createManyAndReturn
   */
  export type ClientCoachCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClientCoaches.
     */
    data: ClientCoachCreateManyInput | ClientCoachCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientCoach update
   */
  export type ClientCoachUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientCoach.
     */
    data: XOR<ClientCoachUpdateInput, ClientCoachUncheckedUpdateInput>
    /**
     * Choose, which ClientCoach to update.
     */
    where: ClientCoachWhereUniqueInput
  }

  /**
   * ClientCoach updateMany
   */
  export type ClientCoachUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientCoaches.
     */
    data: XOR<ClientCoachUpdateManyMutationInput, ClientCoachUncheckedUpdateManyInput>
    /**
     * Filter which ClientCoaches to update
     */
    where?: ClientCoachWhereInput
  }

  /**
   * ClientCoach upsert
   */
  export type ClientCoachUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientCoach to update in case it exists.
     */
    where: ClientCoachWhereUniqueInput
    /**
     * In case the ClientCoach found by the `where` argument doesn't exist, create a new ClientCoach with this data.
     */
    create: XOR<ClientCoachCreateInput, ClientCoachUncheckedCreateInput>
    /**
     * In case the ClientCoach was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientCoachUpdateInput, ClientCoachUncheckedUpdateInput>
  }

  /**
   * ClientCoach delete
   */
  export type ClientCoachDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
    /**
     * Filter which ClientCoach to delete.
     */
    where: ClientCoachWhereUniqueInput
  }

  /**
   * ClientCoach deleteMany
   */
  export type ClientCoachDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientCoaches to delete
     */
    where?: ClientCoachWhereInput
  }

  /**
   * ClientCoach without action
   */
  export type ClientCoachDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCoach
     */
    select?: ClientCoachSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientCoachInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    cycleDays: number | null
    targetCalories: number | null
    waterGoal: number | null
  }

  export type ProgramSumAggregateOutputType = {
    cycleDays: number | null
    targetCalories: number | null
    waterGoal: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    title: string | null
    description: string | null
    cycleDays: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    dietEnabled: boolean | null
    dietType: string | null
    targetCalories: number | null
    waterTrackingEnabled: boolean | null
    waterGoal: number | null
    sleepTrackingEnabled: boolean | null
    weightTrackingEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    title: string | null
    description: string | null
    cycleDays: number | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    dietEnabled: boolean | null
    dietType: string | null
    targetCalories: number | null
    waterTrackingEnabled: boolean | null
    waterGoal: number | null
    sleepTrackingEnabled: boolean | null
    weightTrackingEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    coachId: number
    clientId: number
    title: number
    description: number
    cycleDays: number
    startDate: number
    endDate: number
    isActive: number
    dietEnabled: number
    dietType: number
    targetCalories: number
    waterTrackingEnabled: number
    waterGoal: number
    sleepTrackingEnabled: number
    weightTrackingEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    cycleDays?: true
    targetCalories?: true
    waterGoal?: true
  }

  export type ProgramSumAggregateInputType = {
    cycleDays?: true
    targetCalories?: true
    waterGoal?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    title?: true
    description?: true
    cycleDays?: true
    startDate?: true
    endDate?: true
    isActive?: true
    dietEnabled?: true
    dietType?: true
    targetCalories?: true
    waterTrackingEnabled?: true
    waterGoal?: true
    sleepTrackingEnabled?: true
    weightTrackingEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    title?: true
    description?: true
    cycleDays?: true
    startDate?: true
    endDate?: true
    isActive?: true
    dietEnabled?: true
    dietType?: true
    targetCalories?: true
    waterTrackingEnabled?: true
    waterGoal?: true
    sleepTrackingEnabled?: true
    weightTrackingEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    title?: true
    description?: true
    cycleDays?: true
    startDate?: true
    endDate?: true
    isActive?: true
    dietEnabled?: true
    dietType?: true
    targetCalories?: true
    waterTrackingEnabled?: true
    waterGoal?: true
    sleepTrackingEnabled?: true
    weightTrackingEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    coachId: string
    clientId: string
    title: string
    description: string | null
    cycleDays: number | null
    startDate: Date
    endDate: Date | null
    isActive: boolean
    dietEnabled: boolean
    dietType: string | null
    targetCalories: number | null
    waterTrackingEnabled: boolean
    waterGoal: number | null
    sleepTrackingEnabled: boolean
    weightTrackingEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    cycleDays?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: boolean
    targetCalories?: boolean
    waterTrackingEnabled?: boolean
    waterGoal?: boolean
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    sessions?: boolean | Program$sessionsArgs<ExtArgs>
    mealPlans?: boolean | Program$mealPlansArgs<ExtArgs>
    customGoals?: boolean | Program$customGoalsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    cycleDays?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: boolean
    targetCalories?: boolean
    waterTrackingEnabled?: boolean
    waterGoal?: boolean
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    title?: boolean
    description?: boolean
    cycleDays?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: boolean
    targetCalories?: boolean
    waterTrackingEnabled?: boolean
    waterGoal?: boolean
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    sessions?: boolean | Program$sessionsArgs<ExtArgs>
    mealPlans?: boolean | Program$mealPlansArgs<ExtArgs>
    customGoals?: boolean | Program$customGoalsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      mealPlans: Prisma.$MealPlanPayload<ExtArgs>[]
      customGoals: Prisma.$CustomGoalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      clientId: string
      title: string
      description: string | null
      cycleDays: number | null
      startDate: Date
      endDate: Date | null
      isActive: boolean
      dietEnabled: boolean
      dietType: string | null
      targetCalories: number | null
      waterTrackingEnabled: boolean
      waterGoal: number | null
      sleepTrackingEnabled: boolean
      weightTrackingEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends Program$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Program$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    mealPlans<T extends Program$mealPlansArgs<ExtArgs> = {}>(args?: Subset<T, Program$mealPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findMany"> | Null>
    customGoals<T extends Program$customGoalsArgs<ExtArgs> = {}>(args?: Subset<T, Program$customGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */ 
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly coachId: FieldRef<"Program", 'String'>
    readonly clientId: FieldRef<"Program", 'String'>
    readonly title: FieldRef<"Program", 'String'>
    readonly description: FieldRef<"Program", 'String'>
    readonly cycleDays: FieldRef<"Program", 'Int'>
    readonly startDate: FieldRef<"Program", 'DateTime'>
    readonly endDate: FieldRef<"Program", 'DateTime'>
    readonly isActive: FieldRef<"Program", 'Boolean'>
    readonly dietEnabled: FieldRef<"Program", 'Boolean'>
    readonly dietType: FieldRef<"Program", 'String'>
    readonly targetCalories: FieldRef<"Program", 'Int'>
    readonly waterTrackingEnabled: FieldRef<"Program", 'Boolean'>
    readonly waterGoal: FieldRef<"Program", 'Float'>
    readonly sleepTrackingEnabled: FieldRef<"Program", 'Boolean'>
    readonly weightTrackingEnabled: FieldRef<"Program", 'Boolean'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }

  /**
   * Program.sessions
   */
  export type Program$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Program.mealPlans
   */
  export type Program$mealPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    where?: MealPlanWhereInput
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    cursor?: MealPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * Program.customGoals
   */
  export type Program$customGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    where?: CustomGoalWhereInput
    orderBy?: CustomGoalOrderByWithRelationInput | CustomGoalOrderByWithRelationInput[]
    cursor?: CustomGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomGoalScalarFieldEnum | CustomGoalScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model ProgramTemplate
   */

  export type AggregateProgramTemplate = {
    _count: ProgramTemplateCountAggregateOutputType | null
    _avg: ProgramTemplateAvgAggregateOutputType | null
    _sum: ProgramTemplateSumAggregateOutputType | null
    _min: ProgramTemplateMinAggregateOutputType | null
    _max: ProgramTemplateMaxAggregateOutputType | null
  }

  export type ProgramTemplateAvgAggregateOutputType = {
    cycleDays: number | null
    targetCalories: number | null
    waterGoal: number | null
  }

  export type ProgramTemplateSumAggregateOutputType = {
    cycleDays: number | null
    targetCalories: number | null
    waterGoal: number | null
  }

  export type ProgramTemplateMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    name: string | null
    description: string | null
    cycleDays: number | null
    dietEnabled: boolean | null
    dietType: string | null
    targetCalories: number | null
    waterTrackingEnabled: boolean | null
    waterGoal: number | null
    sleepTrackingEnabled: boolean | null
    weightTrackingEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramTemplateMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    name: string | null
    description: string | null
    cycleDays: number | null
    dietEnabled: boolean | null
    dietType: string | null
    targetCalories: number | null
    waterTrackingEnabled: boolean | null
    waterGoal: number | null
    sleepTrackingEnabled: boolean | null
    weightTrackingEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramTemplateCountAggregateOutputType = {
    id: number
    coachId: number
    name: number
    description: number
    cycleDays: number
    dietEnabled: number
    dietType: number
    targetCalories: number
    waterTrackingEnabled: number
    waterGoal: number
    sleepTrackingEnabled: number
    weightTrackingEnabled: number
    sessionsData: number
    customGoalsData: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramTemplateAvgAggregateInputType = {
    cycleDays?: true
    targetCalories?: true
    waterGoal?: true
  }

  export type ProgramTemplateSumAggregateInputType = {
    cycleDays?: true
    targetCalories?: true
    waterGoal?: true
  }

  export type ProgramTemplateMinAggregateInputType = {
    id?: true
    coachId?: true
    name?: true
    description?: true
    cycleDays?: true
    dietEnabled?: true
    dietType?: true
    targetCalories?: true
    waterTrackingEnabled?: true
    waterGoal?: true
    sleepTrackingEnabled?: true
    weightTrackingEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramTemplateMaxAggregateInputType = {
    id?: true
    coachId?: true
    name?: true
    description?: true
    cycleDays?: true
    dietEnabled?: true
    dietType?: true
    targetCalories?: true
    waterTrackingEnabled?: true
    waterGoal?: true
    sleepTrackingEnabled?: true
    weightTrackingEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramTemplateCountAggregateInputType = {
    id?: true
    coachId?: true
    name?: true
    description?: true
    cycleDays?: true
    dietEnabled?: true
    dietType?: true
    targetCalories?: true
    waterTrackingEnabled?: true
    waterGoal?: true
    sleepTrackingEnabled?: true
    weightTrackingEnabled?: true
    sessionsData?: true
    customGoalsData?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramTemplate to aggregate.
     */
    where?: ProgramTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramTemplates to fetch.
     */
    orderBy?: ProgramTemplateOrderByWithRelationInput | ProgramTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramTemplates
    **/
    _count?: true | ProgramTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramTemplateMaxAggregateInputType
  }

  export type GetProgramTemplateAggregateType<T extends ProgramTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramTemplate[P]>
      : GetScalarType<T[P], AggregateProgramTemplate[P]>
  }




  export type ProgramTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramTemplateWhereInput
    orderBy?: ProgramTemplateOrderByWithAggregationInput | ProgramTemplateOrderByWithAggregationInput[]
    by: ProgramTemplateScalarFieldEnum[] | ProgramTemplateScalarFieldEnum
    having?: ProgramTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramTemplateCountAggregateInputType | true
    _avg?: ProgramTemplateAvgAggregateInputType
    _sum?: ProgramTemplateSumAggregateInputType
    _min?: ProgramTemplateMinAggregateInputType
    _max?: ProgramTemplateMaxAggregateInputType
  }

  export type ProgramTemplateGroupByOutputType = {
    id: string
    coachId: string
    name: string
    description: string | null
    cycleDays: number | null
    dietEnabled: boolean
    dietType: string | null
    targetCalories: number | null
    waterTrackingEnabled: boolean
    waterGoal: number | null
    sleepTrackingEnabled: boolean
    weightTrackingEnabled: boolean
    sessionsData: JsonValue | null
    customGoalsData: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProgramTemplateCountAggregateOutputType | null
    _avg: ProgramTemplateAvgAggregateOutputType | null
    _sum: ProgramTemplateSumAggregateOutputType | null
    _min: ProgramTemplateMinAggregateOutputType | null
    _max: ProgramTemplateMaxAggregateOutputType | null
  }

  type GetProgramTemplateGroupByPayload<T extends ProgramTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ProgramTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    name?: boolean
    description?: boolean
    cycleDays?: boolean
    dietEnabled?: boolean
    dietType?: boolean
    targetCalories?: boolean
    waterTrackingEnabled?: boolean
    waterGoal?: boolean
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: boolean
    customGoalsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programTemplate"]>

  export type ProgramTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    name?: boolean
    description?: boolean
    cycleDays?: boolean
    dietEnabled?: boolean
    dietType?: boolean
    targetCalories?: boolean
    waterTrackingEnabled?: boolean
    waterGoal?: boolean
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: boolean
    customGoalsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programTemplate"]>

  export type ProgramTemplateSelectScalar = {
    id?: boolean
    coachId?: boolean
    name?: boolean
    description?: boolean
    cycleDays?: boolean
    dietEnabled?: boolean
    dietType?: boolean
    targetCalories?: boolean
    waterTrackingEnabled?: boolean
    waterGoal?: boolean
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: boolean
    customGoalsData?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }
  export type ProgramTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }

  export type $ProgramTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramTemplate"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      name: string
      description: string | null
      cycleDays: number | null
      dietEnabled: boolean
      dietType: string | null
      targetCalories: number | null
      waterTrackingEnabled: boolean
      waterGoal: number | null
      sleepTrackingEnabled: boolean
      weightTrackingEnabled: boolean
      sessionsData: Prisma.JsonValue | null
      customGoalsData: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["programTemplate"]>
    composites: {}
  }

  type ProgramTemplateGetPayload<S extends boolean | null | undefined | ProgramTemplateDefaultArgs> = $Result.GetResult<Prisma.$ProgramTemplatePayload, S>

  type ProgramTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramTemplateCountAggregateInputType | true
    }

  export interface ProgramTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramTemplate'], meta: { name: 'ProgramTemplate' } }
    /**
     * Find zero or one ProgramTemplate that matches the filter.
     * @param {ProgramTemplateFindUniqueArgs} args - Arguments to find a ProgramTemplate
     * @example
     * // Get one ProgramTemplate
     * const programTemplate = await prisma.programTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramTemplateFindUniqueArgs>(args: SelectSubset<T, ProgramTemplateFindUniqueArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramTemplateFindUniqueOrThrowArgs} args - Arguments to find a ProgramTemplate
     * @example
     * // Get one ProgramTemplate
     * const programTemplate = await prisma.programTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateFindFirstArgs} args - Arguments to find a ProgramTemplate
     * @example
     * // Get one ProgramTemplate
     * const programTemplate = await prisma.programTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramTemplateFindFirstArgs>(args?: SelectSubset<T, ProgramTemplateFindFirstArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateFindFirstOrThrowArgs} args - Arguments to find a ProgramTemplate
     * @example
     * // Get one ProgramTemplate
     * const programTemplate = await prisma.programTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramTemplates
     * const programTemplates = await prisma.programTemplate.findMany()
     * 
     * // Get first 10 ProgramTemplates
     * const programTemplates = await prisma.programTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programTemplateWithIdOnly = await prisma.programTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramTemplateFindManyArgs>(args?: SelectSubset<T, ProgramTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramTemplate.
     * @param {ProgramTemplateCreateArgs} args - Arguments to create a ProgramTemplate.
     * @example
     * // Create one ProgramTemplate
     * const ProgramTemplate = await prisma.programTemplate.create({
     *   data: {
     *     // ... data to create a ProgramTemplate
     *   }
     * })
     * 
     */
    create<T extends ProgramTemplateCreateArgs>(args: SelectSubset<T, ProgramTemplateCreateArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramTemplates.
     * @param {ProgramTemplateCreateManyArgs} args - Arguments to create many ProgramTemplates.
     * @example
     * // Create many ProgramTemplates
     * const programTemplate = await prisma.programTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramTemplateCreateManyArgs>(args?: SelectSubset<T, ProgramTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramTemplates and returns the data saved in the database.
     * @param {ProgramTemplateCreateManyAndReturnArgs} args - Arguments to create many ProgramTemplates.
     * @example
     * // Create many ProgramTemplates
     * const programTemplate = await prisma.programTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramTemplates and only return the `id`
     * const programTemplateWithIdOnly = await prisma.programTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramTemplate.
     * @param {ProgramTemplateDeleteArgs} args - Arguments to delete one ProgramTemplate.
     * @example
     * // Delete one ProgramTemplate
     * const ProgramTemplate = await prisma.programTemplate.delete({
     *   where: {
     *     // ... filter to delete one ProgramTemplate
     *   }
     * })
     * 
     */
    delete<T extends ProgramTemplateDeleteArgs>(args: SelectSubset<T, ProgramTemplateDeleteArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramTemplate.
     * @param {ProgramTemplateUpdateArgs} args - Arguments to update one ProgramTemplate.
     * @example
     * // Update one ProgramTemplate
     * const programTemplate = await prisma.programTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramTemplateUpdateArgs>(args: SelectSubset<T, ProgramTemplateUpdateArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramTemplates.
     * @param {ProgramTemplateDeleteManyArgs} args - Arguments to filter ProgramTemplates to delete.
     * @example
     * // Delete a few ProgramTemplates
     * const { count } = await prisma.programTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramTemplateDeleteManyArgs>(args?: SelectSubset<T, ProgramTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramTemplates
     * const programTemplate = await prisma.programTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramTemplateUpdateManyArgs>(args: SelectSubset<T, ProgramTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramTemplate.
     * @param {ProgramTemplateUpsertArgs} args - Arguments to update or create a ProgramTemplate.
     * @example
     * // Update or create a ProgramTemplate
     * const programTemplate = await prisma.programTemplate.upsert({
     *   create: {
     *     // ... data to create a ProgramTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ProgramTemplateUpsertArgs>(args: SelectSubset<T, ProgramTemplateUpsertArgs<ExtArgs>>): Prisma__ProgramTemplateClient<$Result.GetResult<Prisma.$ProgramTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateCountArgs} args - Arguments to filter ProgramTemplates to count.
     * @example
     * // Count the number of ProgramTemplates
     * const count = await prisma.programTemplate.count({
     *   where: {
     *     // ... the filter for the ProgramTemplates we want to count
     *   }
     * })
    **/
    count<T extends ProgramTemplateCountArgs>(
      args?: Subset<T, ProgramTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramTemplateAggregateArgs>(args: Subset<T, ProgramTemplateAggregateArgs>): Prisma.PrismaPromise<GetProgramTemplateAggregateType<T>>

    /**
     * Group by ProgramTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ProgramTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramTemplate model
   */
  readonly fields: ProgramTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramTemplate model
   */ 
  interface ProgramTemplateFieldRefs {
    readonly id: FieldRef<"ProgramTemplate", 'String'>
    readonly coachId: FieldRef<"ProgramTemplate", 'String'>
    readonly name: FieldRef<"ProgramTemplate", 'String'>
    readonly description: FieldRef<"ProgramTemplate", 'String'>
    readonly cycleDays: FieldRef<"ProgramTemplate", 'Int'>
    readonly dietEnabled: FieldRef<"ProgramTemplate", 'Boolean'>
    readonly dietType: FieldRef<"ProgramTemplate", 'String'>
    readonly targetCalories: FieldRef<"ProgramTemplate", 'Int'>
    readonly waterTrackingEnabled: FieldRef<"ProgramTemplate", 'Boolean'>
    readonly waterGoal: FieldRef<"ProgramTemplate", 'Float'>
    readonly sleepTrackingEnabled: FieldRef<"ProgramTemplate", 'Boolean'>
    readonly weightTrackingEnabled: FieldRef<"ProgramTemplate", 'Boolean'>
    readonly sessionsData: FieldRef<"ProgramTemplate", 'Json'>
    readonly customGoalsData: FieldRef<"ProgramTemplate", 'Json'>
    readonly createdAt: FieldRef<"ProgramTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ProgramTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgramTemplate findUnique
   */
  export type ProgramTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProgramTemplate to fetch.
     */
    where: ProgramTemplateWhereUniqueInput
  }

  /**
   * ProgramTemplate findUniqueOrThrow
   */
  export type ProgramTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProgramTemplate to fetch.
     */
    where: ProgramTemplateWhereUniqueInput
  }

  /**
   * ProgramTemplate findFirst
   */
  export type ProgramTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProgramTemplate to fetch.
     */
    where?: ProgramTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramTemplates to fetch.
     */
    orderBy?: ProgramTemplateOrderByWithRelationInput | ProgramTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramTemplates.
     */
    cursor?: ProgramTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramTemplates.
     */
    distinct?: ProgramTemplateScalarFieldEnum | ProgramTemplateScalarFieldEnum[]
  }

  /**
   * ProgramTemplate findFirstOrThrow
   */
  export type ProgramTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProgramTemplate to fetch.
     */
    where?: ProgramTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramTemplates to fetch.
     */
    orderBy?: ProgramTemplateOrderByWithRelationInput | ProgramTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramTemplates.
     */
    cursor?: ProgramTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramTemplates.
     */
    distinct?: ProgramTemplateScalarFieldEnum | ProgramTemplateScalarFieldEnum[]
  }

  /**
   * ProgramTemplate findMany
   */
  export type ProgramTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ProgramTemplates to fetch.
     */
    where?: ProgramTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramTemplates to fetch.
     */
    orderBy?: ProgramTemplateOrderByWithRelationInput | ProgramTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramTemplates.
     */
    cursor?: ProgramTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramTemplates.
     */
    skip?: number
    distinct?: ProgramTemplateScalarFieldEnum | ProgramTemplateScalarFieldEnum[]
  }

  /**
   * ProgramTemplate create
   */
  export type ProgramTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramTemplate.
     */
    data: XOR<ProgramTemplateCreateInput, ProgramTemplateUncheckedCreateInput>
  }

  /**
   * ProgramTemplate createMany
   */
  export type ProgramTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramTemplates.
     */
    data: ProgramTemplateCreateManyInput | ProgramTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramTemplate createManyAndReturn
   */
  export type ProgramTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramTemplates.
     */
    data: ProgramTemplateCreateManyInput | ProgramTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramTemplate update
   */
  export type ProgramTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramTemplate.
     */
    data: XOR<ProgramTemplateUpdateInput, ProgramTemplateUncheckedUpdateInput>
    /**
     * Choose, which ProgramTemplate to update.
     */
    where: ProgramTemplateWhereUniqueInput
  }

  /**
   * ProgramTemplate updateMany
   */
  export type ProgramTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramTemplates.
     */
    data: XOR<ProgramTemplateUpdateManyMutationInput, ProgramTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ProgramTemplates to update
     */
    where?: ProgramTemplateWhereInput
  }

  /**
   * ProgramTemplate upsert
   */
  export type ProgramTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramTemplate to update in case it exists.
     */
    where: ProgramTemplateWhereUniqueInput
    /**
     * In case the ProgramTemplate found by the `where` argument doesn't exist, create a new ProgramTemplate with this data.
     */
    create: XOR<ProgramTemplateCreateInput, ProgramTemplateUncheckedCreateInput>
    /**
     * In case the ProgramTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramTemplateUpdateInput, ProgramTemplateUncheckedUpdateInput>
  }

  /**
   * ProgramTemplate delete
   */
  export type ProgramTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
    /**
     * Filter which ProgramTemplate to delete.
     */
    where: ProgramTemplateWhereUniqueInput
  }

  /**
   * ProgramTemplate deleteMany
   */
  export type ProgramTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramTemplates to delete
     */
    where?: ProgramTemplateWhereInput
  }

  /**
   * ProgramTemplate without action
   */
  export type ProgramTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramTemplate
     */
    select?: ProgramTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramTemplateInclude<ExtArgs> | null
  }


  /**
   * Model CustomGoal
   */

  export type AggregateCustomGoal = {
    _count: CustomGoalCountAggregateOutputType | null
    _avg: CustomGoalAvgAggregateOutputType | null
    _sum: CustomGoalSumAggregateOutputType | null
    _min: CustomGoalMinAggregateOutputType | null
    _max: CustomGoalMaxAggregateOutputType | null
  }

  export type CustomGoalAvgAggregateOutputType = {
    order: number | null
  }

  export type CustomGoalSumAggregateOutputType = {
    order: number | null
  }

  export type CustomGoalMinAggregateOutputType = {
    id: string | null
    programId: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomGoalMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomGoalCountAggregateOutputType = {
    id: number
    programId: number
    title: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomGoalAvgAggregateInputType = {
    order?: true
  }

  export type CustomGoalSumAggregateInputType = {
    order?: true
  }

  export type CustomGoalMinAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomGoalMaxAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomGoalCountAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomGoal to aggregate.
     */
    where?: CustomGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomGoals to fetch.
     */
    orderBy?: CustomGoalOrderByWithRelationInput | CustomGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomGoals
    **/
    _count?: true | CustomGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomGoalMaxAggregateInputType
  }

  export type GetCustomGoalAggregateType<T extends CustomGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomGoal[P]>
      : GetScalarType<T[P], AggregateCustomGoal[P]>
  }




  export type CustomGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomGoalWhereInput
    orderBy?: CustomGoalOrderByWithAggregationInput | CustomGoalOrderByWithAggregationInput[]
    by: CustomGoalScalarFieldEnum[] | CustomGoalScalarFieldEnum
    having?: CustomGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomGoalCountAggregateInputType | true
    _avg?: CustomGoalAvgAggregateInputType
    _sum?: CustomGoalSumAggregateInputType
    _min?: CustomGoalMinAggregateInputType
    _max?: CustomGoalMaxAggregateInputType
  }

  export type CustomGoalGroupByOutputType = {
    id: string
    programId: string
    title: string
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: CustomGoalCountAggregateOutputType | null
    _avg: CustomGoalAvgAggregateOutputType | null
    _sum: CustomGoalSumAggregateOutputType | null
    _min: CustomGoalMinAggregateOutputType | null
    _max: CustomGoalMaxAggregateOutputType | null
  }

  type GetCustomGoalGroupByPayload<T extends CustomGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomGoalGroupByOutputType[P]>
            : GetScalarType<T[P], CustomGoalGroupByOutputType[P]>
        }
      >
    >


  export type CustomGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    completions?: boolean | CustomGoal$completionsArgs<ExtArgs>
    _count?: boolean | CustomGoalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customGoal"]>

  export type CustomGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customGoal"]>

  export type CustomGoalSelectScalar = {
    id?: boolean
    programId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    completions?: boolean | CustomGoal$completionsArgs<ExtArgs>
    _count?: boolean | CustomGoalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $CustomGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomGoal"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      completions: Prisma.$GoalCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      title: string
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customGoal"]>
    composites: {}
  }

  type CustomGoalGetPayload<S extends boolean | null | undefined | CustomGoalDefaultArgs> = $Result.GetResult<Prisma.$CustomGoalPayload, S>

  type CustomGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomGoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomGoalCountAggregateInputType | true
    }

  export interface CustomGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomGoal'], meta: { name: 'CustomGoal' } }
    /**
     * Find zero or one CustomGoal that matches the filter.
     * @param {CustomGoalFindUniqueArgs} args - Arguments to find a CustomGoal
     * @example
     * // Get one CustomGoal
     * const customGoal = await prisma.customGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomGoalFindUniqueArgs>(args: SelectSubset<T, CustomGoalFindUniqueArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomGoal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomGoalFindUniqueOrThrowArgs} args - Arguments to find a CustomGoal
     * @example
     * // Get one CustomGoal
     * const customGoal = await prisma.customGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalFindFirstArgs} args - Arguments to find a CustomGoal
     * @example
     * // Get one CustomGoal
     * const customGoal = await prisma.customGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomGoalFindFirstArgs>(args?: SelectSubset<T, CustomGoalFindFirstArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalFindFirstOrThrowArgs} args - Arguments to find a CustomGoal
     * @example
     * // Get one CustomGoal
     * const customGoal = await prisma.customGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomGoals
     * const customGoals = await prisma.customGoal.findMany()
     * 
     * // Get first 10 CustomGoals
     * const customGoals = await prisma.customGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customGoalWithIdOnly = await prisma.customGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomGoalFindManyArgs>(args?: SelectSubset<T, CustomGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomGoal.
     * @param {CustomGoalCreateArgs} args - Arguments to create a CustomGoal.
     * @example
     * // Create one CustomGoal
     * const CustomGoal = await prisma.customGoal.create({
     *   data: {
     *     // ... data to create a CustomGoal
     *   }
     * })
     * 
     */
    create<T extends CustomGoalCreateArgs>(args: SelectSubset<T, CustomGoalCreateArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomGoals.
     * @param {CustomGoalCreateManyArgs} args - Arguments to create many CustomGoals.
     * @example
     * // Create many CustomGoals
     * const customGoal = await prisma.customGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomGoalCreateManyArgs>(args?: SelectSubset<T, CustomGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomGoals and returns the data saved in the database.
     * @param {CustomGoalCreateManyAndReturnArgs} args - Arguments to create many CustomGoals.
     * @example
     * // Create many CustomGoals
     * const customGoal = await prisma.customGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomGoals and only return the `id`
     * const customGoalWithIdOnly = await prisma.customGoal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomGoal.
     * @param {CustomGoalDeleteArgs} args - Arguments to delete one CustomGoal.
     * @example
     * // Delete one CustomGoal
     * const CustomGoal = await prisma.customGoal.delete({
     *   where: {
     *     // ... filter to delete one CustomGoal
     *   }
     * })
     * 
     */
    delete<T extends CustomGoalDeleteArgs>(args: SelectSubset<T, CustomGoalDeleteArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomGoal.
     * @param {CustomGoalUpdateArgs} args - Arguments to update one CustomGoal.
     * @example
     * // Update one CustomGoal
     * const customGoal = await prisma.customGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomGoalUpdateArgs>(args: SelectSubset<T, CustomGoalUpdateArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomGoals.
     * @param {CustomGoalDeleteManyArgs} args - Arguments to filter CustomGoals to delete.
     * @example
     * // Delete a few CustomGoals
     * const { count } = await prisma.customGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomGoalDeleteManyArgs>(args?: SelectSubset<T, CustomGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomGoals
     * const customGoal = await prisma.customGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomGoalUpdateManyArgs>(args: SelectSubset<T, CustomGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomGoal.
     * @param {CustomGoalUpsertArgs} args - Arguments to update or create a CustomGoal.
     * @example
     * // Update or create a CustomGoal
     * const customGoal = await prisma.customGoal.upsert({
     *   create: {
     *     // ... data to create a CustomGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomGoal we want to update
     *   }
     * })
     */
    upsert<T extends CustomGoalUpsertArgs>(args: SelectSubset<T, CustomGoalUpsertArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalCountArgs} args - Arguments to filter CustomGoals to count.
     * @example
     * // Count the number of CustomGoals
     * const count = await prisma.customGoal.count({
     *   where: {
     *     // ... the filter for the CustomGoals we want to count
     *   }
     * })
    **/
    count<T extends CustomGoalCountArgs>(
      args?: Subset<T, CustomGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomGoalAggregateArgs>(args: Subset<T, CustomGoalAggregateArgs>): Prisma.PrismaPromise<GetCustomGoalAggregateType<T>>

    /**
     * Group by CustomGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomGoalGroupByArgs['orderBy'] }
        : { orderBy?: CustomGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomGoal model
   */
  readonly fields: CustomGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    completions<T extends CustomGoal$completionsArgs<ExtArgs> = {}>(args?: Subset<T, CustomGoal$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomGoal model
   */ 
  interface CustomGoalFieldRefs {
    readonly id: FieldRef<"CustomGoal", 'String'>
    readonly programId: FieldRef<"CustomGoal", 'String'>
    readonly title: FieldRef<"CustomGoal", 'String'>
    readonly description: FieldRef<"CustomGoal", 'String'>
    readonly order: FieldRef<"CustomGoal", 'Int'>
    readonly createdAt: FieldRef<"CustomGoal", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomGoal findUnique
   */
  export type CustomGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * Filter, which CustomGoal to fetch.
     */
    where: CustomGoalWhereUniqueInput
  }

  /**
   * CustomGoal findUniqueOrThrow
   */
  export type CustomGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * Filter, which CustomGoal to fetch.
     */
    where: CustomGoalWhereUniqueInput
  }

  /**
   * CustomGoal findFirst
   */
  export type CustomGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * Filter, which CustomGoal to fetch.
     */
    where?: CustomGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomGoals to fetch.
     */
    orderBy?: CustomGoalOrderByWithRelationInput | CustomGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomGoals.
     */
    cursor?: CustomGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomGoals.
     */
    distinct?: CustomGoalScalarFieldEnum | CustomGoalScalarFieldEnum[]
  }

  /**
   * CustomGoal findFirstOrThrow
   */
  export type CustomGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * Filter, which CustomGoal to fetch.
     */
    where?: CustomGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomGoals to fetch.
     */
    orderBy?: CustomGoalOrderByWithRelationInput | CustomGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomGoals.
     */
    cursor?: CustomGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomGoals.
     */
    distinct?: CustomGoalScalarFieldEnum | CustomGoalScalarFieldEnum[]
  }

  /**
   * CustomGoal findMany
   */
  export type CustomGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * Filter, which CustomGoals to fetch.
     */
    where?: CustomGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomGoals to fetch.
     */
    orderBy?: CustomGoalOrderByWithRelationInput | CustomGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomGoals.
     */
    cursor?: CustomGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomGoals.
     */
    skip?: number
    distinct?: CustomGoalScalarFieldEnum | CustomGoalScalarFieldEnum[]
  }

  /**
   * CustomGoal create
   */
  export type CustomGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomGoal.
     */
    data: XOR<CustomGoalCreateInput, CustomGoalUncheckedCreateInput>
  }

  /**
   * CustomGoal createMany
   */
  export type CustomGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomGoals.
     */
    data: CustomGoalCreateManyInput | CustomGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomGoal createManyAndReturn
   */
  export type CustomGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomGoals.
     */
    data: CustomGoalCreateManyInput | CustomGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomGoal update
   */
  export type CustomGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomGoal.
     */
    data: XOR<CustomGoalUpdateInput, CustomGoalUncheckedUpdateInput>
    /**
     * Choose, which CustomGoal to update.
     */
    where: CustomGoalWhereUniqueInput
  }

  /**
   * CustomGoal updateMany
   */
  export type CustomGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomGoals.
     */
    data: XOR<CustomGoalUpdateManyMutationInput, CustomGoalUncheckedUpdateManyInput>
    /**
     * Filter which CustomGoals to update
     */
    where?: CustomGoalWhereInput
  }

  /**
   * CustomGoal upsert
   */
  export type CustomGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomGoal to update in case it exists.
     */
    where: CustomGoalWhereUniqueInput
    /**
     * In case the CustomGoal found by the `where` argument doesn't exist, create a new CustomGoal with this data.
     */
    create: XOR<CustomGoalCreateInput, CustomGoalUncheckedCreateInput>
    /**
     * In case the CustomGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomGoalUpdateInput, CustomGoalUncheckedUpdateInput>
  }

  /**
   * CustomGoal delete
   */
  export type CustomGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
    /**
     * Filter which CustomGoal to delete.
     */
    where: CustomGoalWhereUniqueInput
  }

  /**
   * CustomGoal deleteMany
   */
  export type CustomGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomGoals to delete
     */
    where?: CustomGoalWhereInput
  }

  /**
   * CustomGoal.completions
   */
  export type CustomGoal$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    where?: GoalCompletionWhereInput
    orderBy?: GoalCompletionOrderByWithRelationInput | GoalCompletionOrderByWithRelationInput[]
    cursor?: GoalCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GoalCompletionScalarFieldEnum | GoalCompletionScalarFieldEnum[]
  }

  /**
   * CustomGoal without action
   */
  export type CustomGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomGoal
     */
    select?: CustomGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomGoalInclude<ExtArgs> | null
  }


  /**
   * Model GoalCompletion
   */

  export type AggregateGoalCompletion = {
    _count: GoalCompletionCountAggregateOutputType | null
    _min: GoalCompletionMinAggregateOutputType | null
    _max: GoalCompletionMaxAggregateOutputType | null
  }

  export type GoalCompletionMinAggregateOutputType = {
    id: string | null
    customGoalId: string | null
    clientId: string | null
    date: Date | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCompletionMaxAggregateOutputType = {
    id: string | null
    customGoalId: string | null
    clientId: string | null
    date: Date | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoalCompletionCountAggregateOutputType = {
    id: number
    customGoalId: number
    clientId: number
    date: number
    completed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoalCompletionMinAggregateInputType = {
    id?: true
    customGoalId?: true
    clientId?: true
    date?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCompletionMaxAggregateInputType = {
    id?: true
    customGoalId?: true
    clientId?: true
    date?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoalCompletionCountAggregateInputType = {
    id?: true
    customGoalId?: true
    clientId?: true
    date?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoalCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalCompletion to aggregate.
     */
    where?: GoalCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalCompletions to fetch.
     */
    orderBy?: GoalCompletionOrderByWithRelationInput | GoalCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoalCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoalCompletions
    **/
    _count?: true | GoalCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalCompletionMaxAggregateInputType
  }

  export type GetGoalCompletionAggregateType<T extends GoalCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateGoalCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoalCompletion[P]>
      : GetScalarType<T[P], AggregateGoalCompletion[P]>
  }




  export type GoalCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoalCompletionWhereInput
    orderBy?: GoalCompletionOrderByWithAggregationInput | GoalCompletionOrderByWithAggregationInput[]
    by: GoalCompletionScalarFieldEnum[] | GoalCompletionScalarFieldEnum
    having?: GoalCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCompletionCountAggregateInputType | true
    _min?: GoalCompletionMinAggregateInputType
    _max?: GoalCompletionMaxAggregateInputType
  }

  export type GoalCompletionGroupByOutputType = {
    id: string
    customGoalId: string
    clientId: string
    date: Date
    completed: boolean
    createdAt: Date
    updatedAt: Date
    _count: GoalCompletionCountAggregateOutputType | null
    _min: GoalCompletionMinAggregateOutputType | null
    _max: GoalCompletionMaxAggregateOutputType | null
  }

  type GetGoalCompletionGroupByPayload<T extends GoalCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoalCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], GoalCompletionGroupByOutputType[P]>
        }
      >
    >


  export type GoalCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customGoalId?: boolean
    clientId?: boolean
    date?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customGoal?: boolean | CustomGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalCompletion"]>

  export type GoalCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customGoalId?: boolean
    clientId?: boolean
    date?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customGoal?: boolean | CustomGoalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goalCompletion"]>

  export type GoalCompletionSelectScalar = {
    id?: boolean
    customGoalId?: boolean
    clientId?: boolean
    date?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoalCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customGoal?: boolean | CustomGoalDefaultArgs<ExtArgs>
  }
  export type GoalCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customGoal?: boolean | CustomGoalDefaultArgs<ExtArgs>
  }

  export type $GoalCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoalCompletion"
    objects: {
      customGoal: Prisma.$CustomGoalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customGoalId: string
      clientId: string
      date: Date
      completed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goalCompletion"]>
    composites: {}
  }

  type GoalCompletionGetPayload<S extends boolean | null | undefined | GoalCompletionDefaultArgs> = $Result.GetResult<Prisma.$GoalCompletionPayload, S>

  type GoalCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GoalCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GoalCompletionCountAggregateInputType | true
    }

  export interface GoalCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoalCompletion'], meta: { name: 'GoalCompletion' } }
    /**
     * Find zero or one GoalCompletion that matches the filter.
     * @param {GoalCompletionFindUniqueArgs} args - Arguments to find a GoalCompletion
     * @example
     * // Get one GoalCompletion
     * const goalCompletion = await prisma.goalCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoalCompletionFindUniqueArgs>(args: SelectSubset<T, GoalCompletionFindUniqueArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GoalCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GoalCompletionFindUniqueOrThrowArgs} args - Arguments to find a GoalCompletion
     * @example
     * // Get one GoalCompletion
     * const goalCompletion = await prisma.goalCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoalCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, GoalCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GoalCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionFindFirstArgs} args - Arguments to find a GoalCompletion
     * @example
     * // Get one GoalCompletion
     * const goalCompletion = await prisma.goalCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoalCompletionFindFirstArgs>(args?: SelectSubset<T, GoalCompletionFindFirstArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GoalCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionFindFirstOrThrowArgs} args - Arguments to find a GoalCompletion
     * @example
     * // Get one GoalCompletion
     * const goalCompletion = await prisma.goalCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoalCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, GoalCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GoalCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoalCompletions
     * const goalCompletions = await prisma.goalCompletion.findMany()
     * 
     * // Get first 10 GoalCompletions
     * const goalCompletions = await prisma.goalCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalCompletionWithIdOnly = await prisma.goalCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoalCompletionFindManyArgs>(args?: SelectSubset<T, GoalCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GoalCompletion.
     * @param {GoalCompletionCreateArgs} args - Arguments to create a GoalCompletion.
     * @example
     * // Create one GoalCompletion
     * const GoalCompletion = await prisma.goalCompletion.create({
     *   data: {
     *     // ... data to create a GoalCompletion
     *   }
     * })
     * 
     */
    create<T extends GoalCompletionCreateArgs>(args: SelectSubset<T, GoalCompletionCreateArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GoalCompletions.
     * @param {GoalCompletionCreateManyArgs} args - Arguments to create many GoalCompletions.
     * @example
     * // Create many GoalCompletions
     * const goalCompletion = await prisma.goalCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoalCompletionCreateManyArgs>(args?: SelectSubset<T, GoalCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoalCompletions and returns the data saved in the database.
     * @param {GoalCompletionCreateManyAndReturnArgs} args - Arguments to create many GoalCompletions.
     * @example
     * // Create many GoalCompletions
     * const goalCompletion = await prisma.goalCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoalCompletions and only return the `id`
     * const goalCompletionWithIdOnly = await prisma.goalCompletion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoalCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, GoalCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GoalCompletion.
     * @param {GoalCompletionDeleteArgs} args - Arguments to delete one GoalCompletion.
     * @example
     * // Delete one GoalCompletion
     * const GoalCompletion = await prisma.goalCompletion.delete({
     *   where: {
     *     // ... filter to delete one GoalCompletion
     *   }
     * })
     * 
     */
    delete<T extends GoalCompletionDeleteArgs>(args: SelectSubset<T, GoalCompletionDeleteArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GoalCompletion.
     * @param {GoalCompletionUpdateArgs} args - Arguments to update one GoalCompletion.
     * @example
     * // Update one GoalCompletion
     * const goalCompletion = await prisma.goalCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoalCompletionUpdateArgs>(args: SelectSubset<T, GoalCompletionUpdateArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GoalCompletions.
     * @param {GoalCompletionDeleteManyArgs} args - Arguments to filter GoalCompletions to delete.
     * @example
     * // Delete a few GoalCompletions
     * const { count } = await prisma.goalCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoalCompletionDeleteManyArgs>(args?: SelectSubset<T, GoalCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoalCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoalCompletions
     * const goalCompletion = await prisma.goalCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoalCompletionUpdateManyArgs>(args: SelectSubset<T, GoalCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GoalCompletion.
     * @param {GoalCompletionUpsertArgs} args - Arguments to update or create a GoalCompletion.
     * @example
     * // Update or create a GoalCompletion
     * const goalCompletion = await prisma.goalCompletion.upsert({
     *   create: {
     *     // ... data to create a GoalCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoalCompletion we want to update
     *   }
     * })
     */
    upsert<T extends GoalCompletionUpsertArgs>(args: SelectSubset<T, GoalCompletionUpsertArgs<ExtArgs>>): Prisma__GoalCompletionClient<$Result.GetResult<Prisma.$GoalCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GoalCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionCountArgs} args - Arguments to filter GoalCompletions to count.
     * @example
     * // Count the number of GoalCompletions
     * const count = await prisma.goalCompletion.count({
     *   where: {
     *     // ... the filter for the GoalCompletions we want to count
     *   }
     * })
    **/
    count<T extends GoalCompletionCountArgs>(
      args?: Subset<T, GoalCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoalCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalCompletionAggregateArgs>(args: Subset<T, GoalCompletionAggregateArgs>): Prisma.PrismaPromise<GetGoalCompletionAggregateType<T>>

    /**
     * Group by GoalCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalCompletionGroupByArgs['orderBy'] }
        : { orderBy?: GoalCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoalCompletion model
   */
  readonly fields: GoalCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoalCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoalCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customGoal<T extends CustomGoalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomGoalDefaultArgs<ExtArgs>>): Prisma__CustomGoalClient<$Result.GetResult<Prisma.$CustomGoalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoalCompletion model
   */ 
  interface GoalCompletionFieldRefs {
    readonly id: FieldRef<"GoalCompletion", 'String'>
    readonly customGoalId: FieldRef<"GoalCompletion", 'String'>
    readonly clientId: FieldRef<"GoalCompletion", 'String'>
    readonly date: FieldRef<"GoalCompletion", 'DateTime'>
    readonly completed: FieldRef<"GoalCompletion", 'Boolean'>
    readonly createdAt: FieldRef<"GoalCompletion", 'DateTime'>
    readonly updatedAt: FieldRef<"GoalCompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoalCompletion findUnique
   */
  export type GoalCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * Filter, which GoalCompletion to fetch.
     */
    where: GoalCompletionWhereUniqueInput
  }

  /**
   * GoalCompletion findUniqueOrThrow
   */
  export type GoalCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * Filter, which GoalCompletion to fetch.
     */
    where: GoalCompletionWhereUniqueInput
  }

  /**
   * GoalCompletion findFirst
   */
  export type GoalCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * Filter, which GoalCompletion to fetch.
     */
    where?: GoalCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalCompletions to fetch.
     */
    orderBy?: GoalCompletionOrderByWithRelationInput | GoalCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalCompletions.
     */
    cursor?: GoalCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalCompletions.
     */
    distinct?: GoalCompletionScalarFieldEnum | GoalCompletionScalarFieldEnum[]
  }

  /**
   * GoalCompletion findFirstOrThrow
   */
  export type GoalCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * Filter, which GoalCompletion to fetch.
     */
    where?: GoalCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalCompletions to fetch.
     */
    orderBy?: GoalCompletionOrderByWithRelationInput | GoalCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoalCompletions.
     */
    cursor?: GoalCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoalCompletions.
     */
    distinct?: GoalCompletionScalarFieldEnum | GoalCompletionScalarFieldEnum[]
  }

  /**
   * GoalCompletion findMany
   */
  export type GoalCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * Filter, which GoalCompletions to fetch.
     */
    where?: GoalCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoalCompletions to fetch.
     */
    orderBy?: GoalCompletionOrderByWithRelationInput | GoalCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoalCompletions.
     */
    cursor?: GoalCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GoalCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoalCompletions.
     */
    skip?: number
    distinct?: GoalCompletionScalarFieldEnum | GoalCompletionScalarFieldEnum[]
  }

  /**
   * GoalCompletion create
   */
  export type GoalCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a GoalCompletion.
     */
    data: XOR<GoalCompletionCreateInput, GoalCompletionUncheckedCreateInput>
  }

  /**
   * GoalCompletion createMany
   */
  export type GoalCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoalCompletions.
     */
    data: GoalCompletionCreateManyInput | GoalCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoalCompletion createManyAndReturn
   */
  export type GoalCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GoalCompletions.
     */
    data: GoalCompletionCreateManyInput | GoalCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoalCompletion update
   */
  export type GoalCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a GoalCompletion.
     */
    data: XOR<GoalCompletionUpdateInput, GoalCompletionUncheckedUpdateInput>
    /**
     * Choose, which GoalCompletion to update.
     */
    where: GoalCompletionWhereUniqueInput
  }

  /**
   * GoalCompletion updateMany
   */
  export type GoalCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoalCompletions.
     */
    data: XOR<GoalCompletionUpdateManyMutationInput, GoalCompletionUncheckedUpdateManyInput>
    /**
     * Filter which GoalCompletions to update
     */
    where?: GoalCompletionWhereInput
  }

  /**
   * GoalCompletion upsert
   */
  export type GoalCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the GoalCompletion to update in case it exists.
     */
    where: GoalCompletionWhereUniqueInput
    /**
     * In case the GoalCompletion found by the `where` argument doesn't exist, create a new GoalCompletion with this data.
     */
    create: XOR<GoalCompletionCreateInput, GoalCompletionUncheckedCreateInput>
    /**
     * In case the GoalCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoalCompletionUpdateInput, GoalCompletionUncheckedUpdateInput>
  }

  /**
   * GoalCompletion delete
   */
  export type GoalCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
    /**
     * Filter which GoalCompletion to delete.
     */
    where: GoalCompletionWhereUniqueInput
  }

  /**
   * GoalCompletion deleteMany
   */
  export type GoalCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoalCompletions to delete
     */
    where?: GoalCompletionWhereInput
  }

  /**
   * GoalCompletion without action
   */
  export type GoalCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoalCompletion
     */
    select?: GoalCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoalCompletionInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    programId: string | null
    date: Date | null
    status: $Enums.SessionStatus | null
    isRestDay: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    date: Date | null
    status: $Enums.SessionStatus | null
    isRestDay: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    programId: number
    date: number
    status: number
    isRestDay: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    programId?: true
    date?: true
    status?: true
    isRestDay?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    programId?: true
    date?: true
    status?: true
    isRestDay?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    programId?: true
    date?: true
    status?: true
    isRestDay?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    programId: string
    date: Date
    status: $Enums.SessionStatus
    isRestDay: boolean
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    date?: boolean
    status?: boolean
    isRestDay?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercises?: boolean | Session$exercisesArgs<ExtArgs>
    comments?: boolean | Session$commentsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    date?: boolean
    status?: boolean
    isRestDay?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    programId?: boolean
    date?: boolean
    status?: boolean
    isRestDay?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercises?: boolean | Session$exercisesArgs<ExtArgs>
    comments?: boolean | Session$commentsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      date: Date
      status: $Enums.SessionStatus
      isRestDay: boolean
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercises<T extends Session$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Session$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Session$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Session$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly programId: FieldRef<"Session", 'String'>
    readonly date: FieldRef<"Session", 'DateTime'>
    readonly status: FieldRef<"Session", 'SessionStatus'>
    readonly isRestDay: FieldRef<"Session", 'Boolean'>
    readonly notes: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.exercises
   */
  export type Session$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Session.comments
   */
  export type Session$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    sets: number | null
    order: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    sets: number | null
    order: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    category: $Enums.ExerciseCategory | null
    sets: number | null
    reps: string | null
    weight: string | null
    restTime: string | null
    videoUrl: string | null
    gifUrl: string | null
    description: string | null
    order: number | null
    duration: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    name: string | null
    category: $Enums.ExerciseCategory | null
    sets: number | null
    reps: string | null
    weight: string | null
    restTime: string | null
    videoUrl: string | null
    gifUrl: string | null
    description: string | null
    order: number | null
    duration: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    sessionId: number
    name: number
    category: number
    sets: number
    reps: number
    weight: number
    restTime: number
    videoUrl: number
    gifUrl: number
    description: number
    order: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    sets?: true
    order?: true
  }

  export type ExerciseSumAggregateInputType = {
    sets?: true
    order?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    category?: true
    sets?: true
    reps?: true
    weight?: true
    restTime?: true
    videoUrl?: true
    gifUrl?: true
    description?: true
    order?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    category?: true
    sets?: true
    reps?: true
    weight?: true
    restTime?: true
    videoUrl?: true
    gifUrl?: true
    description?: true
    order?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    sessionId?: true
    name?: true
    category?: true
    sets?: true
    reps?: true
    weight?: true
    restTime?: true
    videoUrl?: true
    gifUrl?: true
    description?: true
    order?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    sessionId: string
    name: string
    category: $Enums.ExerciseCategory
    sets: number | null
    reps: string | null
    weight: string | null
    restTime: string | null
    videoUrl: string | null
    gifUrl: string | null
    description: string | null
    order: number
    duration: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    category?: boolean
    sets?: boolean
    reps?: boolean
    weight?: boolean
    restTime?: boolean
    videoUrl?: boolean
    gifUrl?: boolean
    description?: boolean
    order?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    setCompletions?: boolean | Exercise$setCompletionsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    name?: boolean
    category?: boolean
    sets?: boolean
    reps?: boolean
    weight?: boolean
    restTime?: boolean
    videoUrl?: boolean
    gifUrl?: boolean
    description?: boolean
    order?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    name?: boolean
    category?: boolean
    sets?: boolean
    reps?: boolean
    weight?: boolean
    restTime?: boolean
    videoUrl?: boolean
    gifUrl?: boolean
    description?: boolean
    order?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    setCompletions?: boolean | Exercise$setCompletionsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      setCompletions: Prisma.$SetCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      name: string
      category: $Enums.ExerciseCategory
      sets: number | null
      reps: string | null
      weight: string | null
      restTime: string | null
      videoUrl: string | null
      gifUrl: string | null
      description: string | null
      order: number
      duration: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    setCompletions<T extends Exercise$setCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$setCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly sessionId: FieldRef<"Exercise", 'String'>
    readonly name: FieldRef<"Exercise", 'String'>
    readonly category: FieldRef<"Exercise", 'ExerciseCategory'>
    readonly sets: FieldRef<"Exercise", 'Int'>
    readonly reps: FieldRef<"Exercise", 'String'>
    readonly weight: FieldRef<"Exercise", 'String'>
    readonly restTime: FieldRef<"Exercise", 'String'>
    readonly videoUrl: FieldRef<"Exercise", 'String'>
    readonly gifUrl: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly order: FieldRef<"Exercise", 'Int'>
    readonly duration: FieldRef<"Exercise", 'String'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise.setCompletions
   */
  export type Exercise$setCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    where?: SetCompletionWhereInput
    orderBy?: SetCompletionOrderByWithRelationInput | SetCompletionOrderByWithRelationInput[]
    cursor?: SetCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SetCompletionScalarFieldEnum | SetCompletionScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model SetCompletion
   */

  export type AggregateSetCompletion = {
    _count: SetCompletionCountAggregateOutputType | null
    _avg: SetCompletionAvgAggregateOutputType | null
    _sum: SetCompletionSumAggregateOutputType | null
    _min: SetCompletionMinAggregateOutputType | null
    _max: SetCompletionMaxAggregateOutputType | null
  }

  export type SetCompletionAvgAggregateOutputType = {
    setNumber: number | null
  }

  export type SetCompletionSumAggregateOutputType = {
    setNumber: number | null
  }

  export type SetCompletionMinAggregateOutputType = {
    id: string | null
    exerciseId: string | null
    setNumber: number | null
    repsAchieved: string | null
    weightUsed: string | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SetCompletionMaxAggregateOutputType = {
    id: string | null
    exerciseId: string | null
    setNumber: number | null
    repsAchieved: string | null
    weightUsed: string | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SetCompletionCountAggregateOutputType = {
    id: number
    exerciseId: number
    setNumber: number
    repsAchieved: number
    weightUsed: number
    completed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SetCompletionAvgAggregateInputType = {
    setNumber?: true
  }

  export type SetCompletionSumAggregateInputType = {
    setNumber?: true
  }

  export type SetCompletionMinAggregateInputType = {
    id?: true
    exerciseId?: true
    setNumber?: true
    repsAchieved?: true
    weightUsed?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SetCompletionMaxAggregateInputType = {
    id?: true
    exerciseId?: true
    setNumber?: true
    repsAchieved?: true
    weightUsed?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SetCompletionCountAggregateInputType = {
    id?: true
    exerciseId?: true
    setNumber?: true
    repsAchieved?: true
    weightUsed?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SetCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SetCompletion to aggregate.
     */
    where?: SetCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SetCompletions to fetch.
     */
    orderBy?: SetCompletionOrderByWithRelationInput | SetCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SetCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SetCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SetCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SetCompletions
    **/
    _count?: true | SetCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SetCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SetCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SetCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SetCompletionMaxAggregateInputType
  }

  export type GetSetCompletionAggregateType<T extends SetCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateSetCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetCompletion[P]>
      : GetScalarType<T[P], AggregateSetCompletion[P]>
  }




  export type SetCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SetCompletionWhereInput
    orderBy?: SetCompletionOrderByWithAggregationInput | SetCompletionOrderByWithAggregationInput[]
    by: SetCompletionScalarFieldEnum[] | SetCompletionScalarFieldEnum
    having?: SetCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SetCompletionCountAggregateInputType | true
    _avg?: SetCompletionAvgAggregateInputType
    _sum?: SetCompletionSumAggregateInputType
    _min?: SetCompletionMinAggregateInputType
    _max?: SetCompletionMaxAggregateInputType
  }

  export type SetCompletionGroupByOutputType = {
    id: string
    exerciseId: string
    setNumber: number
    repsAchieved: string | null
    weightUsed: string | null
    completed: boolean
    createdAt: Date
    updatedAt: Date
    _count: SetCompletionCountAggregateOutputType | null
    _avg: SetCompletionAvgAggregateOutputType | null
    _sum: SetCompletionSumAggregateOutputType | null
    _min: SetCompletionMinAggregateOutputType | null
    _max: SetCompletionMaxAggregateOutputType | null
  }

  type GetSetCompletionGroupByPayload<T extends SetCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SetCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SetCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SetCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], SetCompletionGroupByOutputType[P]>
        }
      >
    >


  export type SetCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    setNumber?: boolean
    repsAchieved?: boolean
    weightUsed?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["setCompletion"]>

  export type SetCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    setNumber?: boolean
    repsAchieved?: boolean
    weightUsed?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["setCompletion"]>

  export type SetCompletionSelectScalar = {
    id?: boolean
    exerciseId?: boolean
    setNumber?: boolean
    repsAchieved?: boolean
    weightUsed?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SetCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type SetCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $SetCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SetCompletion"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exerciseId: string
      setNumber: number
      repsAchieved: string | null
      weightUsed: string | null
      completed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setCompletion"]>
    composites: {}
  }

  type SetCompletionGetPayload<S extends boolean | null | undefined | SetCompletionDefaultArgs> = $Result.GetResult<Prisma.$SetCompletionPayload, S>

  type SetCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SetCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SetCompletionCountAggregateInputType | true
    }

  export interface SetCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SetCompletion'], meta: { name: 'SetCompletion' } }
    /**
     * Find zero or one SetCompletion that matches the filter.
     * @param {SetCompletionFindUniqueArgs} args - Arguments to find a SetCompletion
     * @example
     * // Get one SetCompletion
     * const setCompletion = await prisma.setCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SetCompletionFindUniqueArgs>(args: SelectSubset<T, SetCompletionFindUniqueArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SetCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SetCompletionFindUniqueOrThrowArgs} args - Arguments to find a SetCompletion
     * @example
     * // Get one SetCompletion
     * const setCompletion = await prisma.setCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SetCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, SetCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SetCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionFindFirstArgs} args - Arguments to find a SetCompletion
     * @example
     * // Get one SetCompletion
     * const setCompletion = await prisma.setCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SetCompletionFindFirstArgs>(args?: SelectSubset<T, SetCompletionFindFirstArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SetCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionFindFirstOrThrowArgs} args - Arguments to find a SetCompletion
     * @example
     * // Get one SetCompletion
     * const setCompletion = await prisma.setCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SetCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, SetCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SetCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SetCompletions
     * const setCompletions = await prisma.setCompletion.findMany()
     * 
     * // Get first 10 SetCompletions
     * const setCompletions = await prisma.setCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const setCompletionWithIdOnly = await prisma.setCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SetCompletionFindManyArgs>(args?: SelectSubset<T, SetCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SetCompletion.
     * @param {SetCompletionCreateArgs} args - Arguments to create a SetCompletion.
     * @example
     * // Create one SetCompletion
     * const SetCompletion = await prisma.setCompletion.create({
     *   data: {
     *     // ... data to create a SetCompletion
     *   }
     * })
     * 
     */
    create<T extends SetCompletionCreateArgs>(args: SelectSubset<T, SetCompletionCreateArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SetCompletions.
     * @param {SetCompletionCreateManyArgs} args - Arguments to create many SetCompletions.
     * @example
     * // Create many SetCompletions
     * const setCompletion = await prisma.setCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SetCompletionCreateManyArgs>(args?: SelectSubset<T, SetCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SetCompletions and returns the data saved in the database.
     * @param {SetCompletionCreateManyAndReturnArgs} args - Arguments to create many SetCompletions.
     * @example
     * // Create many SetCompletions
     * const setCompletion = await prisma.setCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SetCompletions and only return the `id`
     * const setCompletionWithIdOnly = await prisma.setCompletion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SetCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, SetCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SetCompletion.
     * @param {SetCompletionDeleteArgs} args - Arguments to delete one SetCompletion.
     * @example
     * // Delete one SetCompletion
     * const SetCompletion = await prisma.setCompletion.delete({
     *   where: {
     *     // ... filter to delete one SetCompletion
     *   }
     * })
     * 
     */
    delete<T extends SetCompletionDeleteArgs>(args: SelectSubset<T, SetCompletionDeleteArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SetCompletion.
     * @param {SetCompletionUpdateArgs} args - Arguments to update one SetCompletion.
     * @example
     * // Update one SetCompletion
     * const setCompletion = await prisma.setCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SetCompletionUpdateArgs>(args: SelectSubset<T, SetCompletionUpdateArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SetCompletions.
     * @param {SetCompletionDeleteManyArgs} args - Arguments to filter SetCompletions to delete.
     * @example
     * // Delete a few SetCompletions
     * const { count } = await prisma.setCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SetCompletionDeleteManyArgs>(args?: SelectSubset<T, SetCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SetCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SetCompletions
     * const setCompletion = await prisma.setCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SetCompletionUpdateManyArgs>(args: SelectSubset<T, SetCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SetCompletion.
     * @param {SetCompletionUpsertArgs} args - Arguments to update or create a SetCompletion.
     * @example
     * // Update or create a SetCompletion
     * const setCompletion = await prisma.setCompletion.upsert({
     *   create: {
     *     // ... data to create a SetCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SetCompletion we want to update
     *   }
     * })
     */
    upsert<T extends SetCompletionUpsertArgs>(args: SelectSubset<T, SetCompletionUpsertArgs<ExtArgs>>): Prisma__SetCompletionClient<$Result.GetResult<Prisma.$SetCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SetCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionCountArgs} args - Arguments to filter SetCompletions to count.
     * @example
     * // Count the number of SetCompletions
     * const count = await prisma.setCompletion.count({
     *   where: {
     *     // ... the filter for the SetCompletions we want to count
     *   }
     * })
    **/
    count<T extends SetCompletionCountArgs>(
      args?: Subset<T, SetCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SetCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SetCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SetCompletionAggregateArgs>(args: Subset<T, SetCompletionAggregateArgs>): Prisma.PrismaPromise<GetSetCompletionAggregateType<T>>

    /**
     * Group by SetCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SetCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SetCompletionGroupByArgs['orderBy'] }
        : { orderBy?: SetCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SetCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSetCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SetCompletion model
   */
  readonly fields: SetCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SetCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SetCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SetCompletion model
   */ 
  interface SetCompletionFieldRefs {
    readonly id: FieldRef<"SetCompletion", 'String'>
    readonly exerciseId: FieldRef<"SetCompletion", 'String'>
    readonly setNumber: FieldRef<"SetCompletion", 'Int'>
    readonly repsAchieved: FieldRef<"SetCompletion", 'String'>
    readonly weightUsed: FieldRef<"SetCompletion", 'String'>
    readonly completed: FieldRef<"SetCompletion", 'Boolean'>
    readonly createdAt: FieldRef<"SetCompletion", 'DateTime'>
    readonly updatedAt: FieldRef<"SetCompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SetCompletion findUnique
   */
  export type SetCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * Filter, which SetCompletion to fetch.
     */
    where: SetCompletionWhereUniqueInput
  }

  /**
   * SetCompletion findUniqueOrThrow
   */
  export type SetCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * Filter, which SetCompletion to fetch.
     */
    where: SetCompletionWhereUniqueInput
  }

  /**
   * SetCompletion findFirst
   */
  export type SetCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * Filter, which SetCompletion to fetch.
     */
    where?: SetCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SetCompletions to fetch.
     */
    orderBy?: SetCompletionOrderByWithRelationInput | SetCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SetCompletions.
     */
    cursor?: SetCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SetCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SetCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SetCompletions.
     */
    distinct?: SetCompletionScalarFieldEnum | SetCompletionScalarFieldEnum[]
  }

  /**
   * SetCompletion findFirstOrThrow
   */
  export type SetCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * Filter, which SetCompletion to fetch.
     */
    where?: SetCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SetCompletions to fetch.
     */
    orderBy?: SetCompletionOrderByWithRelationInput | SetCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SetCompletions.
     */
    cursor?: SetCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SetCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SetCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SetCompletions.
     */
    distinct?: SetCompletionScalarFieldEnum | SetCompletionScalarFieldEnum[]
  }

  /**
   * SetCompletion findMany
   */
  export type SetCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * Filter, which SetCompletions to fetch.
     */
    where?: SetCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SetCompletions to fetch.
     */
    orderBy?: SetCompletionOrderByWithRelationInput | SetCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SetCompletions.
     */
    cursor?: SetCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SetCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SetCompletions.
     */
    skip?: number
    distinct?: SetCompletionScalarFieldEnum | SetCompletionScalarFieldEnum[]
  }

  /**
   * SetCompletion create
   */
  export type SetCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a SetCompletion.
     */
    data: XOR<SetCompletionCreateInput, SetCompletionUncheckedCreateInput>
  }

  /**
   * SetCompletion createMany
   */
  export type SetCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SetCompletions.
     */
    data: SetCompletionCreateManyInput | SetCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SetCompletion createManyAndReturn
   */
  export type SetCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SetCompletions.
     */
    data: SetCompletionCreateManyInput | SetCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SetCompletion update
   */
  export type SetCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a SetCompletion.
     */
    data: XOR<SetCompletionUpdateInput, SetCompletionUncheckedUpdateInput>
    /**
     * Choose, which SetCompletion to update.
     */
    where: SetCompletionWhereUniqueInput
  }

  /**
   * SetCompletion updateMany
   */
  export type SetCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SetCompletions.
     */
    data: XOR<SetCompletionUpdateManyMutationInput, SetCompletionUncheckedUpdateManyInput>
    /**
     * Filter which SetCompletions to update
     */
    where?: SetCompletionWhereInput
  }

  /**
   * SetCompletion upsert
   */
  export type SetCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the SetCompletion to update in case it exists.
     */
    where: SetCompletionWhereUniqueInput
    /**
     * In case the SetCompletion found by the `where` argument doesn't exist, create a new SetCompletion with this data.
     */
    create: XOR<SetCompletionCreateInput, SetCompletionUncheckedCreateInput>
    /**
     * In case the SetCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SetCompletionUpdateInput, SetCompletionUncheckedUpdateInput>
  }

  /**
   * SetCompletion delete
   */
  export type SetCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
    /**
     * Filter which SetCompletion to delete.
     */
    where: SetCompletionWhereUniqueInput
  }

  /**
   * SetCompletion deleteMany
   */
  export type SetCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SetCompletions to delete
     */
    where?: SetCompletionWhereInput
  }

  /**
   * SetCompletion without action
   */
  export type SetCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SetCompletion
     */
    select?: SetCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetCompletionInclude<ExtArgs> | null
  }


  /**
   * Model MealPlan
   */

  export type AggregateMealPlan = {
    _count: MealPlanCountAggregateOutputType | null
    _avg: MealPlanAvgAggregateOutputType | null
    _sum: MealPlanSumAggregateOutputType | null
    _min: MealPlanMinAggregateOutputType | null
    _max: MealPlanMaxAggregateOutputType | null
  }

  export type MealPlanAvgAggregateOutputType = {
    dailyCalories: number | null
  }

  export type MealPlanSumAggregateOutputType = {
    dailyCalories: number | null
  }

  export type MealPlanMinAggregateOutputType = {
    id: string | null
    programId: string | null
    title: string | null
    description: string | null
    dailyCalories: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MealPlanMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    title: string | null
    description: string | null
    dailyCalories: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MealPlanCountAggregateOutputType = {
    id: number
    programId: number
    title: number
    description: number
    dailyCalories: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MealPlanAvgAggregateInputType = {
    dailyCalories?: true
  }

  export type MealPlanSumAggregateInputType = {
    dailyCalories?: true
  }

  export type MealPlanMinAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    description?: true
    dailyCalories?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MealPlanMaxAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    description?: true
    dailyCalories?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MealPlanCountAggregateInputType = {
    id?: true
    programId?: true
    title?: true
    description?: true
    dailyCalories?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MealPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealPlan to aggregate.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MealPlans
    **/
    _count?: true | MealPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealPlanMaxAggregateInputType
  }

  export type GetMealPlanAggregateType<T extends MealPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateMealPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMealPlan[P]>
      : GetScalarType<T[P], AggregateMealPlan[P]>
  }




  export type MealPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanWhereInput
    orderBy?: MealPlanOrderByWithAggregationInput | MealPlanOrderByWithAggregationInput[]
    by: MealPlanScalarFieldEnum[] | MealPlanScalarFieldEnum
    having?: MealPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealPlanCountAggregateInputType | true
    _avg?: MealPlanAvgAggregateInputType
    _sum?: MealPlanSumAggregateInputType
    _min?: MealPlanMinAggregateInputType
    _max?: MealPlanMaxAggregateInputType
  }

  export type MealPlanGroupByOutputType = {
    id: string
    programId: string
    title: string
    description: string | null
    dailyCalories: number | null
    createdAt: Date
    updatedAt: Date
    _count: MealPlanCountAggregateOutputType | null
    _avg: MealPlanAvgAggregateOutputType | null
    _sum: MealPlanSumAggregateOutputType | null
    _min: MealPlanMinAggregateOutputType | null
    _max: MealPlanMaxAggregateOutputType | null
  }

  type GetMealPlanGroupByPayload<T extends MealPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealPlanGroupByOutputType[P]>
            : GetScalarType<T[P], MealPlanGroupByOutputType[P]>
        }
      >
    >


  export type MealPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    title?: boolean
    description?: boolean
    dailyCalories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    menuItems?: boolean | MealPlan$menuItemsArgs<ExtArgs>
    _count?: boolean | MealPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlan"]>

  export type MealPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    title?: boolean
    description?: boolean
    dailyCalories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlan"]>

  export type MealPlanSelectScalar = {
    id?: boolean
    programId?: boolean
    title?: boolean
    description?: boolean
    dailyCalories?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MealPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    menuItems?: boolean | MealPlan$menuItemsArgs<ExtArgs>
    _count?: boolean | MealPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MealPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $MealPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MealPlan"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      menuItems: Prisma.$MenuItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      title: string
      description: string | null
      dailyCalories: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mealPlan"]>
    composites: {}
  }

  type MealPlanGetPayload<S extends boolean | null | undefined | MealPlanDefaultArgs> = $Result.GetResult<Prisma.$MealPlanPayload, S>

  type MealPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MealPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MealPlanCountAggregateInputType | true
    }

  export interface MealPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MealPlan'], meta: { name: 'MealPlan' } }
    /**
     * Find zero or one MealPlan that matches the filter.
     * @param {MealPlanFindUniqueArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealPlanFindUniqueArgs>(args: SelectSubset<T, MealPlanFindUniqueArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MealPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MealPlanFindUniqueOrThrowArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, MealPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MealPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanFindFirstArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealPlanFindFirstArgs>(args?: SelectSubset<T, MealPlanFindFirstArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MealPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanFindFirstOrThrowArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, MealPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MealPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MealPlans
     * const mealPlans = await prisma.mealPlan.findMany()
     * 
     * // Get first 10 MealPlans
     * const mealPlans = await prisma.mealPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealPlanWithIdOnly = await prisma.mealPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealPlanFindManyArgs>(args?: SelectSubset<T, MealPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MealPlan.
     * @param {MealPlanCreateArgs} args - Arguments to create a MealPlan.
     * @example
     * // Create one MealPlan
     * const MealPlan = await prisma.mealPlan.create({
     *   data: {
     *     // ... data to create a MealPlan
     *   }
     * })
     * 
     */
    create<T extends MealPlanCreateArgs>(args: SelectSubset<T, MealPlanCreateArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MealPlans.
     * @param {MealPlanCreateManyArgs} args - Arguments to create many MealPlans.
     * @example
     * // Create many MealPlans
     * const mealPlan = await prisma.mealPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealPlanCreateManyArgs>(args?: SelectSubset<T, MealPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MealPlans and returns the data saved in the database.
     * @param {MealPlanCreateManyAndReturnArgs} args - Arguments to create many MealPlans.
     * @example
     * // Create many MealPlans
     * const mealPlan = await prisma.mealPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MealPlans and only return the `id`
     * const mealPlanWithIdOnly = await prisma.mealPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, MealPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MealPlan.
     * @param {MealPlanDeleteArgs} args - Arguments to delete one MealPlan.
     * @example
     * // Delete one MealPlan
     * const MealPlan = await prisma.mealPlan.delete({
     *   where: {
     *     // ... filter to delete one MealPlan
     *   }
     * })
     * 
     */
    delete<T extends MealPlanDeleteArgs>(args: SelectSubset<T, MealPlanDeleteArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MealPlan.
     * @param {MealPlanUpdateArgs} args - Arguments to update one MealPlan.
     * @example
     * // Update one MealPlan
     * const mealPlan = await prisma.mealPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealPlanUpdateArgs>(args: SelectSubset<T, MealPlanUpdateArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MealPlans.
     * @param {MealPlanDeleteManyArgs} args - Arguments to filter MealPlans to delete.
     * @example
     * // Delete a few MealPlans
     * const { count } = await prisma.mealPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealPlanDeleteManyArgs>(args?: SelectSubset<T, MealPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MealPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MealPlans
     * const mealPlan = await prisma.mealPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealPlanUpdateManyArgs>(args: SelectSubset<T, MealPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MealPlan.
     * @param {MealPlanUpsertArgs} args - Arguments to update or create a MealPlan.
     * @example
     * // Update or create a MealPlan
     * const mealPlan = await prisma.mealPlan.upsert({
     *   create: {
     *     // ... data to create a MealPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MealPlan we want to update
     *   }
     * })
     */
    upsert<T extends MealPlanUpsertArgs>(args: SelectSubset<T, MealPlanUpsertArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MealPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanCountArgs} args - Arguments to filter MealPlans to count.
     * @example
     * // Count the number of MealPlans
     * const count = await prisma.mealPlan.count({
     *   where: {
     *     // ... the filter for the MealPlans we want to count
     *   }
     * })
    **/
    count<T extends MealPlanCountArgs>(
      args?: Subset<T, MealPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MealPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealPlanAggregateArgs>(args: Subset<T, MealPlanAggregateArgs>): Prisma.PrismaPromise<GetMealPlanAggregateType<T>>

    /**
     * Group by MealPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealPlanGroupByArgs['orderBy'] }
        : { orderBy?: MealPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MealPlan model
   */
  readonly fields: MealPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MealPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    menuItems<T extends MealPlan$menuItemsArgs<ExtArgs> = {}>(args?: Subset<T, MealPlan$menuItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MealPlan model
   */ 
  interface MealPlanFieldRefs {
    readonly id: FieldRef<"MealPlan", 'String'>
    readonly programId: FieldRef<"MealPlan", 'String'>
    readonly title: FieldRef<"MealPlan", 'String'>
    readonly description: FieldRef<"MealPlan", 'String'>
    readonly dailyCalories: FieldRef<"MealPlan", 'Int'>
    readonly createdAt: FieldRef<"MealPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"MealPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MealPlan findUnique
   */
  export type MealPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan findUniqueOrThrow
   */
  export type MealPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan findFirst
   */
  export type MealPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealPlans.
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealPlans.
     */
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * MealPlan findFirstOrThrow
   */
  export type MealPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealPlans.
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealPlans.
     */
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * MealPlan findMany
   */
  export type MealPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlans to fetch.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MealPlans.
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * MealPlan create
   */
  export type MealPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a MealPlan.
     */
    data: XOR<MealPlanCreateInput, MealPlanUncheckedCreateInput>
  }

  /**
   * MealPlan createMany
   */
  export type MealPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MealPlans.
     */
    data: MealPlanCreateManyInput | MealPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MealPlan createManyAndReturn
   */
  export type MealPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MealPlans.
     */
    data: MealPlanCreateManyInput | MealPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MealPlan update
   */
  export type MealPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a MealPlan.
     */
    data: XOR<MealPlanUpdateInput, MealPlanUncheckedUpdateInput>
    /**
     * Choose, which MealPlan to update.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan updateMany
   */
  export type MealPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MealPlans.
     */
    data: XOR<MealPlanUpdateManyMutationInput, MealPlanUncheckedUpdateManyInput>
    /**
     * Filter which MealPlans to update
     */
    where?: MealPlanWhereInput
  }

  /**
   * MealPlan upsert
   */
  export type MealPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the MealPlan to update in case it exists.
     */
    where: MealPlanWhereUniqueInput
    /**
     * In case the MealPlan found by the `where` argument doesn't exist, create a new MealPlan with this data.
     */
    create: XOR<MealPlanCreateInput, MealPlanUncheckedCreateInput>
    /**
     * In case the MealPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealPlanUpdateInput, MealPlanUncheckedUpdateInput>
  }

  /**
   * MealPlan delete
   */
  export type MealPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter which MealPlan to delete.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan deleteMany
   */
  export type MealPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealPlans to delete
     */
    where?: MealPlanWhereInput
  }

  /**
   * MealPlan.menuItems
   */
  export type MealPlan$menuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MealPlan without action
   */
  export type MealPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
  }


  /**
   * Model MenuItem
   */

  export type AggregateMenuItem = {
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  export type MenuItemAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type MenuItemSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type MenuItemMinAggregateOutputType = {
    id: string | null
    mealPlanId: string | null
    mealType: string | null
    name: string | null
    description: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemMaxAggregateOutputType = {
    id: string | null
    mealPlanId: string | null
    mealType: string | null
    name: string | null
    description: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemCountAggregateOutputType = {
    id: number
    mealPlanId: number
    mealType: number
    name: number
    description: number
    calories: number
    protein: number
    carbs: number
    fats: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuItemAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type MenuItemSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type MenuItemMinAggregateInputType = {
    id?: true
    mealPlanId?: true
    mealType?: true
    name?: true
    description?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemMaxAggregateInputType = {
    id?: true
    mealPlanId?: true
    mealType?: true
    name?: true
    description?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemCountAggregateInputType = {
    id?: true
    mealPlanId?: true
    mealType?: true
    name?: true
    description?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItem to aggregate.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItems
    **/
    _count?: true | MenuItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemMaxAggregateInputType
  }

  export type GetMenuItemAggregateType<T extends MenuItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItem[P]>
      : GetScalarType<T[P], AggregateMenuItem[P]>
  }




  export type MenuItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithAggregationInput | MenuItemOrderByWithAggregationInput[]
    by: MenuItemScalarFieldEnum[] | MenuItemScalarFieldEnum
    having?: MenuItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemCountAggregateInputType | true
    _avg?: MenuItemAvgAggregateInputType
    _sum?: MenuItemSumAggregateInputType
    _min?: MenuItemMinAggregateInputType
    _max?: MenuItemMaxAggregateInputType
  }

  export type MenuItemGroupByOutputType = {
    id: string
    mealPlanId: string
    mealType: string
    name: string
    description: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    createdAt: Date
    updatedAt: Date
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  type GetMenuItemGroupByPayload<T extends MenuItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealPlanId?: boolean
    mealType?: boolean
    name?: boolean
    description?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealPlanId?: boolean
    mealType?: boolean
    name?: boolean
    description?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectScalar = {
    id?: boolean
    mealPlanId?: boolean
    mealType?: boolean
    name?: boolean
    description?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
  }

  export type $MenuItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItem"
    objects: {
      mealPlan: Prisma.$MealPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mealPlanId: string
      mealType: string
      name: string
      description: string | null
      calories: number | null
      protein: number | null
      carbs: number | null
      fats: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuItem"]>
    composites: {}
  }

  type MenuItemGetPayload<S extends boolean | null | undefined | MenuItemDefaultArgs> = $Result.GetResult<Prisma.$MenuItemPayload, S>

  type MenuItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuItemCountAggregateInputType | true
    }

  export interface MenuItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItem'], meta: { name: 'MenuItem' } }
    /**
     * Find zero or one MenuItem that matches the filter.
     * @param {MenuItemFindUniqueArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemFindUniqueArgs>(args: SelectSubset<T, MenuItemFindUniqueArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MenuItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuItemFindUniqueOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MenuItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemFindFirstArgs>(args?: SelectSubset<T, MenuItemFindFirstArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MenuItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItems
     * const menuItems = await prisma.menuItem.findMany()
     * 
     * // Get first 10 MenuItems
     * const menuItems = await prisma.menuItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemFindManyArgs>(args?: SelectSubset<T, MenuItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MenuItem.
     * @param {MenuItemCreateArgs} args - Arguments to create a MenuItem.
     * @example
     * // Create one MenuItem
     * const MenuItem = await prisma.menuItem.create({
     *   data: {
     *     // ... data to create a MenuItem
     *   }
     * })
     * 
     */
    create<T extends MenuItemCreateArgs>(args: SelectSubset<T, MenuItemCreateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MenuItems.
     * @param {MenuItemCreateManyArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemCreateManyArgs>(args?: SelectSubset<T, MenuItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItems and returns the data saved in the database.
     * @param {MenuItemCreateManyAndReturnArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MenuItem.
     * @param {MenuItemDeleteArgs} args - Arguments to delete one MenuItem.
     * @example
     * // Delete one MenuItem
     * const MenuItem = await prisma.menuItem.delete({
     *   where: {
     *     // ... filter to delete one MenuItem
     *   }
     * })
     * 
     */
    delete<T extends MenuItemDeleteArgs>(args: SelectSubset<T, MenuItemDeleteArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MenuItem.
     * @param {MenuItemUpdateArgs} args - Arguments to update one MenuItem.
     * @example
     * // Update one MenuItem
     * const menuItem = await prisma.menuItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemUpdateArgs>(args: SelectSubset<T, MenuItemUpdateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MenuItems.
     * @param {MenuItemDeleteManyArgs} args - Arguments to filter MenuItems to delete.
     * @example
     * // Delete a few MenuItems
     * const { count } = await prisma.menuItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemDeleteManyArgs>(args?: SelectSubset<T, MenuItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemUpdateManyArgs>(args: SelectSubset<T, MenuItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuItem.
     * @param {MenuItemUpsertArgs} args - Arguments to update or create a MenuItem.
     * @example
     * // Update or create a MenuItem
     * const menuItem = await prisma.menuItem.upsert({
     *   create: {
     *     // ... data to create a MenuItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItem we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemUpsertArgs>(args: SelectSubset<T, MenuItemUpsertArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemCountArgs} args - Arguments to filter MenuItems to count.
     * @example
     * // Count the number of MenuItems
     * const count = await prisma.menuItem.count({
     *   where: {
     *     // ... the filter for the MenuItems we want to count
     *   }
     * })
    **/
    count<T extends MenuItemCountArgs>(
      args?: Subset<T, MenuItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAggregateArgs>(args: Subset<T, MenuItemAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAggregateType<T>>

    /**
     * Group by MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItem model
   */
  readonly fields: MenuItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mealPlan<T extends MealPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MealPlanDefaultArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItem model
   */ 
  interface MenuItemFieldRefs {
    readonly id: FieldRef<"MenuItem", 'String'>
    readonly mealPlanId: FieldRef<"MenuItem", 'String'>
    readonly mealType: FieldRef<"MenuItem", 'String'>
    readonly name: FieldRef<"MenuItem", 'String'>
    readonly description: FieldRef<"MenuItem", 'String'>
    readonly calories: FieldRef<"MenuItem", 'Int'>
    readonly protein: FieldRef<"MenuItem", 'Float'>
    readonly carbs: FieldRef<"MenuItem", 'Float'>
    readonly fats: FieldRef<"MenuItem", 'Float'>
    readonly createdAt: FieldRef<"MenuItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuItem findUnique
   */
  export type MenuItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findUniqueOrThrow
   */
  export type MenuItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findFirst
   */
  export type MenuItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findFirstOrThrow
   */
  export type MenuItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findMany
   */
  export type MenuItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItems to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem create
   */
  export type MenuItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItem.
     */
    data: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
  }

  /**
   * MenuItem createMany
   */
  export type MenuItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItem createManyAndReturn
   */
  export type MenuItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem update
   */
  export type MenuItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItem.
     */
    data: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
    /**
     * Choose, which MenuItem to update.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem updateMany
   */
  export type MenuItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem upsert
   */
  export type MenuItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItem to update in case it exists.
     */
    where: MenuItemWhereUniqueInput
    /**
     * In case the MenuItem found by the `where` argument doesn't exist, create a new MenuItem with this data.
     */
    create: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
    /**
     * In case the MenuItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
  }

  /**
   * MenuItem delete
   */
  export type MenuItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter which MenuItem to delete.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem deleteMany
   */
  export type MenuItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItems to delete
     */
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem without action
   */
  export type MenuItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
  }


  /**
   * Model Meal
   */

  export type AggregateMeal = {
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  export type MealAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type MealSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
  }

  export type MealMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    date: Date | null
    mealType: string | null
    description: string | null
    photoUrl: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MealMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    date: Date | null
    mealType: string | null
    description: string | null
    photoUrl: string | null
    calories: number | null
    protein: number | null
    carbs: number | null
    fats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MealCountAggregateOutputType = {
    id: number
    clientId: number
    date: number
    mealType: number
    description: number
    photoUrl: number
    calories: number
    protein: number
    carbs: number
    fats: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MealAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type MealSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
  }

  export type MealMinAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    mealType?: true
    description?: true
    photoUrl?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MealMaxAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    mealType?: true
    description?: true
    photoUrl?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MealCountAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    mealType?: true
    description?: true
    photoUrl?: true
    calories?: true
    protein?: true
    carbs?: true
    fats?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meal to aggregate.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meals
    **/
    _count?: true | MealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealMaxAggregateInputType
  }

  export type GetMealAggregateType<T extends MealAggregateArgs> = {
        [P in keyof T & keyof AggregateMeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeal[P]>
      : GetScalarType<T[P], AggregateMeal[P]>
  }




  export type MealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
    orderBy?: MealOrderByWithAggregationInput | MealOrderByWithAggregationInput[]
    by: MealScalarFieldEnum[] | MealScalarFieldEnum
    having?: MealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealCountAggregateInputType | true
    _avg?: MealAvgAggregateInputType
    _sum?: MealSumAggregateInputType
    _min?: MealMinAggregateInputType
    _max?: MealMaxAggregateInputType
  }

  export type MealGroupByOutputType = {
    id: string
    clientId: string
    date: Date
    mealType: string
    description: string
    photoUrl: string | null
    calories: number
    protein: number | null
    carbs: number | null
    fats: number | null
    createdAt: Date
    updatedAt: Date
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  type GetMealGroupByPayload<T extends MealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealGroupByOutputType[P]>
            : GetScalarType<T[P], MealGroupByOutputType[P]>
        }
      >
    >


  export type MealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    mealType?: boolean
    description?: boolean
    photoUrl?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    mealType?: boolean
    description?: boolean
    photoUrl?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectScalar = {
    id?: boolean
    clientId?: boolean
    date?: boolean
    mealType?: boolean
    description?: boolean
    photoUrl?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type MealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $MealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meal"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      date: Date
      mealType: string
      description: string
      photoUrl: string | null
      calories: number
      protein: number | null
      carbs: number | null
      fats: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meal"]>
    composites: {}
  }

  type MealGetPayload<S extends boolean | null | undefined | MealDefaultArgs> = $Result.GetResult<Prisma.$MealPayload, S>

  type MealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MealCountAggregateInputType | true
    }

  export interface MealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meal'], meta: { name: 'Meal' } }
    /**
     * Find zero or one Meal that matches the filter.
     * @param {MealFindUniqueArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealFindUniqueArgs>(args: SelectSubset<T, MealFindUniqueArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MealFindUniqueOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealFindUniqueOrThrowArgs>(args: SelectSubset<T, MealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealFindFirstArgs>(args?: SelectSubset<T, MealFindFirstArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealFindFirstOrThrowArgs>(args?: SelectSubset<T, MealFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meals
     * const meals = await prisma.meal.findMany()
     * 
     * // Get first 10 Meals
     * const meals = await prisma.meal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealWithIdOnly = await prisma.meal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealFindManyArgs>(args?: SelectSubset<T, MealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meal.
     * @param {MealCreateArgs} args - Arguments to create a Meal.
     * @example
     * // Create one Meal
     * const Meal = await prisma.meal.create({
     *   data: {
     *     // ... data to create a Meal
     *   }
     * })
     * 
     */
    create<T extends MealCreateArgs>(args: SelectSubset<T, MealCreateArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meals.
     * @param {MealCreateManyArgs} args - Arguments to create many Meals.
     * @example
     * // Create many Meals
     * const meal = await prisma.meal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealCreateManyArgs>(args?: SelectSubset<T, MealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meals and returns the data saved in the database.
     * @param {MealCreateManyAndReturnArgs} args - Arguments to create many Meals.
     * @example
     * // Create many Meals
     * const meal = await prisma.meal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meals and only return the `id`
     * const mealWithIdOnly = await prisma.meal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealCreateManyAndReturnArgs>(args?: SelectSubset<T, MealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meal.
     * @param {MealDeleteArgs} args - Arguments to delete one Meal.
     * @example
     * // Delete one Meal
     * const Meal = await prisma.meal.delete({
     *   where: {
     *     // ... filter to delete one Meal
     *   }
     * })
     * 
     */
    delete<T extends MealDeleteArgs>(args: SelectSubset<T, MealDeleteArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meal.
     * @param {MealUpdateArgs} args - Arguments to update one Meal.
     * @example
     * // Update one Meal
     * const meal = await prisma.meal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealUpdateArgs>(args: SelectSubset<T, MealUpdateArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meals.
     * @param {MealDeleteManyArgs} args - Arguments to filter Meals to delete.
     * @example
     * // Delete a few Meals
     * const { count } = await prisma.meal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealDeleteManyArgs>(args?: SelectSubset<T, MealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meals
     * const meal = await prisma.meal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealUpdateManyArgs>(args: SelectSubset<T, MealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meal.
     * @param {MealUpsertArgs} args - Arguments to update or create a Meal.
     * @example
     * // Update or create a Meal
     * const meal = await prisma.meal.upsert({
     *   create: {
     *     // ... data to create a Meal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meal we want to update
     *   }
     * })
     */
    upsert<T extends MealUpsertArgs>(args: SelectSubset<T, MealUpsertArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealCountArgs} args - Arguments to filter Meals to count.
     * @example
     * // Count the number of Meals
     * const count = await prisma.meal.count({
     *   where: {
     *     // ... the filter for the Meals we want to count
     *   }
     * })
    **/
    count<T extends MealCountArgs>(
      args?: Subset<T, MealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealAggregateArgs>(args: Subset<T, MealAggregateArgs>): Prisma.PrismaPromise<GetMealAggregateType<T>>

    /**
     * Group by Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealGroupByArgs['orderBy'] }
        : { orderBy?: MealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meal model
   */
  readonly fields: MealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meal model
   */ 
  interface MealFieldRefs {
    readonly id: FieldRef<"Meal", 'String'>
    readonly clientId: FieldRef<"Meal", 'String'>
    readonly date: FieldRef<"Meal", 'DateTime'>
    readonly mealType: FieldRef<"Meal", 'String'>
    readonly description: FieldRef<"Meal", 'String'>
    readonly photoUrl: FieldRef<"Meal", 'String'>
    readonly calories: FieldRef<"Meal", 'Int'>
    readonly protein: FieldRef<"Meal", 'Float'>
    readonly carbs: FieldRef<"Meal", 'Float'>
    readonly fats: FieldRef<"Meal", 'Float'>
    readonly createdAt: FieldRef<"Meal", 'DateTime'>
    readonly updatedAt: FieldRef<"Meal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meal findUnique
   */
  export type MealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findUniqueOrThrow
   */
  export type MealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findFirst
   */
  export type MealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal findFirstOrThrow
   */
  export type MealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal findMany
   */
  export type MealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meals to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal create
   */
  export type MealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The data needed to create a Meal.
     */
    data: XOR<MealCreateInput, MealUncheckedCreateInput>
  }

  /**
   * Meal createMany
   */
  export type MealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meals.
     */
    data: MealCreateManyInput | MealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meal createManyAndReturn
   */
  export type MealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Meals.
     */
    data: MealCreateManyInput | MealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meal update
   */
  export type MealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The data needed to update a Meal.
     */
    data: XOR<MealUpdateInput, MealUncheckedUpdateInput>
    /**
     * Choose, which Meal to update.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal updateMany
   */
  export type MealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meals.
     */
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyInput>
    /**
     * Filter which Meals to update
     */
    where?: MealWhereInput
  }

  /**
   * Meal upsert
   */
  export type MealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The filter to search for the Meal to update in case it exists.
     */
    where: MealWhereUniqueInput
    /**
     * In case the Meal found by the `where` argument doesn't exist, create a new Meal with this data.
     */
    create: XOR<MealCreateInput, MealUncheckedCreateInput>
    /**
     * In case the Meal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealUpdateInput, MealUncheckedUpdateInput>
  }

  /**
   * Meal delete
   */
  export type MealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter which Meal to delete.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal deleteMany
   */
  export type MealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meals to delete
     */
    where?: MealWhereInput
  }

  /**
   * Meal without action
   */
  export type MealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
  }


  /**
   * Model DailyStat
   */

  export type AggregateDailyStat = {
    _count: DailyStatCountAggregateOutputType | null
    _avg: DailyStatAvgAggregateOutputType | null
    _sum: DailyStatSumAggregateOutputType | null
    _min: DailyStatMinAggregateOutputType | null
    _max: DailyStatMaxAggregateOutputType | null
  }

  export type DailyStatAvgAggregateOutputType = {
    sleepHours: number | null
    waterIntake: number | null
    weight: number | null
    totalCalories: number | null
    workoutDuration: number | null
  }

  export type DailyStatSumAggregateOutputType = {
    sleepHours: number | null
    waterIntake: number | null
    weight: number | null
    totalCalories: number | null
    workoutDuration: number | null
  }

  export type DailyStatMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    date: Date | null
    sleepHours: number | null
    bedTime: Date | null
    wakeTime: Date | null
    waterIntake: number | null
    weight: number | null
    totalCalories: number | null
    workoutTime: Date | null
    workoutDuration: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyStatMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    date: Date | null
    sleepHours: number | null
    bedTime: Date | null
    wakeTime: Date | null
    waterIntake: number | null
    weight: number | null
    totalCalories: number | null
    workoutTime: Date | null
    workoutDuration: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyStatCountAggregateOutputType = {
    id: number
    clientId: number
    date: number
    sleepHours: number
    bedTime: number
    wakeTime: number
    waterIntake: number
    weight: number
    totalCalories: number
    workoutTime: number
    workoutDuration: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyStatAvgAggregateInputType = {
    sleepHours?: true
    waterIntake?: true
    weight?: true
    totalCalories?: true
    workoutDuration?: true
  }

  export type DailyStatSumAggregateInputType = {
    sleepHours?: true
    waterIntake?: true
    weight?: true
    totalCalories?: true
    workoutDuration?: true
  }

  export type DailyStatMinAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    sleepHours?: true
    bedTime?: true
    wakeTime?: true
    waterIntake?: true
    weight?: true
    totalCalories?: true
    workoutTime?: true
    workoutDuration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyStatMaxAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    sleepHours?: true
    bedTime?: true
    wakeTime?: true
    waterIntake?: true
    weight?: true
    totalCalories?: true
    workoutTime?: true
    workoutDuration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyStatCountAggregateInputType = {
    id?: true
    clientId?: true
    date?: true
    sleepHours?: true
    bedTime?: true
    wakeTime?: true
    waterIntake?: true
    weight?: true
    totalCalories?: true
    workoutTime?: true
    workoutDuration?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStat to aggregate.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyStats
    **/
    _count?: true | DailyStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyStatMaxAggregateInputType
  }

  export type GetDailyStatAggregateType<T extends DailyStatAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyStat[P]>
      : GetScalarType<T[P], AggregateDailyStat[P]>
  }




  export type DailyStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyStatWhereInput
    orderBy?: DailyStatOrderByWithAggregationInput | DailyStatOrderByWithAggregationInput[]
    by: DailyStatScalarFieldEnum[] | DailyStatScalarFieldEnum
    having?: DailyStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyStatCountAggregateInputType | true
    _avg?: DailyStatAvgAggregateInputType
    _sum?: DailyStatSumAggregateInputType
    _min?: DailyStatMinAggregateInputType
    _max?: DailyStatMaxAggregateInputType
  }

  export type DailyStatGroupByOutputType = {
    id: string
    clientId: string
    date: Date
    sleepHours: number | null
    bedTime: Date | null
    wakeTime: Date | null
    waterIntake: number | null
    weight: number | null
    totalCalories: number | null
    workoutTime: Date | null
    workoutDuration: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DailyStatCountAggregateOutputType | null
    _avg: DailyStatAvgAggregateOutputType | null
    _sum: DailyStatSumAggregateOutputType | null
    _min: DailyStatMinAggregateOutputType | null
    _max: DailyStatMaxAggregateOutputType | null
  }

  type GetDailyStatGroupByPayload<T extends DailyStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyStatGroupByOutputType[P]>
            : GetScalarType<T[P], DailyStatGroupByOutputType[P]>
        }
      >
    >


  export type DailyStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    sleepHours?: boolean
    bedTime?: boolean
    wakeTime?: boolean
    waterIntake?: boolean
    weight?: boolean
    totalCalories?: boolean
    workoutTime?: boolean
    workoutDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyStat"]>

  export type DailyStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    date?: boolean
    sleepHours?: boolean
    bedTime?: boolean
    wakeTime?: boolean
    waterIntake?: boolean
    weight?: boolean
    totalCalories?: boolean
    workoutTime?: boolean
    workoutDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyStat"]>

  export type DailyStatSelectScalar = {
    id?: boolean
    clientId?: boolean
    date?: boolean
    sleepHours?: boolean
    bedTime?: boolean
    wakeTime?: boolean
    waterIntake?: boolean
    weight?: boolean
    totalCalories?: boolean
    workoutTime?: boolean
    workoutDuration?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type DailyStatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $DailyStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyStat"
    objects: {
      client: Prisma.$ClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      date: Date
      sleepHours: number | null
      bedTime: Date | null
      wakeTime: Date | null
      waterIntake: number | null
      weight: number | null
      totalCalories: number | null
      workoutTime: Date | null
      workoutDuration: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyStat"]>
    composites: {}
  }

  type DailyStatGetPayload<S extends boolean | null | undefined | DailyStatDefaultArgs> = $Result.GetResult<Prisma.$DailyStatPayload, S>

  type DailyStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyStatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyStatCountAggregateInputType | true
    }

  export interface DailyStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyStat'], meta: { name: 'DailyStat' } }
    /**
     * Find zero or one DailyStat that matches the filter.
     * @param {DailyStatFindUniqueArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyStatFindUniqueArgs>(args: SelectSubset<T, DailyStatFindUniqueArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyStat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyStatFindUniqueOrThrowArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyStatFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatFindFirstArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyStatFindFirstArgs>(args?: SelectSubset<T, DailyStatFindFirstArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatFindFirstOrThrowArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyStatFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyStats
     * const dailyStats = await prisma.dailyStat.findMany()
     * 
     * // Get first 10 DailyStats
     * const dailyStats = await prisma.dailyStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyStatWithIdOnly = await prisma.dailyStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyStatFindManyArgs>(args?: SelectSubset<T, DailyStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyStat.
     * @param {DailyStatCreateArgs} args - Arguments to create a DailyStat.
     * @example
     * // Create one DailyStat
     * const DailyStat = await prisma.dailyStat.create({
     *   data: {
     *     // ... data to create a DailyStat
     *   }
     * })
     * 
     */
    create<T extends DailyStatCreateArgs>(args: SelectSubset<T, DailyStatCreateArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyStats.
     * @param {DailyStatCreateManyArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStat = await prisma.dailyStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyStatCreateManyArgs>(args?: SelectSubset<T, DailyStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyStats and returns the data saved in the database.
     * @param {DailyStatCreateManyAndReturnArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStat = await prisma.dailyStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyStats and only return the `id`
     * const dailyStatWithIdOnly = await prisma.dailyStat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyStatCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyStat.
     * @param {DailyStatDeleteArgs} args - Arguments to delete one DailyStat.
     * @example
     * // Delete one DailyStat
     * const DailyStat = await prisma.dailyStat.delete({
     *   where: {
     *     // ... filter to delete one DailyStat
     *   }
     * })
     * 
     */
    delete<T extends DailyStatDeleteArgs>(args: SelectSubset<T, DailyStatDeleteArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyStat.
     * @param {DailyStatUpdateArgs} args - Arguments to update one DailyStat.
     * @example
     * // Update one DailyStat
     * const dailyStat = await prisma.dailyStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyStatUpdateArgs>(args: SelectSubset<T, DailyStatUpdateArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyStats.
     * @param {DailyStatDeleteManyArgs} args - Arguments to filter DailyStats to delete.
     * @example
     * // Delete a few DailyStats
     * const { count } = await prisma.dailyStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyStatDeleteManyArgs>(args?: SelectSubset<T, DailyStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyStats
     * const dailyStat = await prisma.dailyStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyStatUpdateManyArgs>(args: SelectSubset<T, DailyStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyStat.
     * @param {DailyStatUpsertArgs} args - Arguments to update or create a DailyStat.
     * @example
     * // Update or create a DailyStat
     * const dailyStat = await prisma.dailyStat.upsert({
     *   create: {
     *     // ... data to create a DailyStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyStat we want to update
     *   }
     * })
     */
    upsert<T extends DailyStatUpsertArgs>(args: SelectSubset<T, DailyStatUpsertArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatCountArgs} args - Arguments to filter DailyStats to count.
     * @example
     * // Count the number of DailyStats
     * const count = await prisma.dailyStat.count({
     *   where: {
     *     // ... the filter for the DailyStats we want to count
     *   }
     * })
    **/
    count<T extends DailyStatCountArgs>(
      args?: Subset<T, DailyStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyStatAggregateArgs>(args: Subset<T, DailyStatAggregateArgs>): Prisma.PrismaPromise<GetDailyStatAggregateType<T>>

    /**
     * Group by DailyStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyStatGroupByArgs['orderBy'] }
        : { orderBy?: DailyStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyStat model
   */
  readonly fields: DailyStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyStat model
   */ 
  interface DailyStatFieldRefs {
    readonly id: FieldRef<"DailyStat", 'String'>
    readonly clientId: FieldRef<"DailyStat", 'String'>
    readonly date: FieldRef<"DailyStat", 'DateTime'>
    readonly sleepHours: FieldRef<"DailyStat", 'Float'>
    readonly bedTime: FieldRef<"DailyStat", 'DateTime'>
    readonly wakeTime: FieldRef<"DailyStat", 'DateTime'>
    readonly waterIntake: FieldRef<"DailyStat", 'Float'>
    readonly weight: FieldRef<"DailyStat", 'Float'>
    readonly totalCalories: FieldRef<"DailyStat", 'Int'>
    readonly workoutTime: FieldRef<"DailyStat", 'DateTime'>
    readonly workoutDuration: FieldRef<"DailyStat", 'Int'>
    readonly notes: FieldRef<"DailyStat", 'String'>
    readonly createdAt: FieldRef<"DailyStat", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyStat findUnique
   */
  export type DailyStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat findUniqueOrThrow
   */
  export type DailyStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat findFirst
   */
  export type DailyStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * DailyStat findFirstOrThrow
   */
  export type DailyStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * DailyStat findMany
   */
  export type DailyStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyStats.
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * DailyStat create
   */
  export type DailyStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyStat.
     */
    data: XOR<DailyStatCreateInput, DailyStatUncheckedCreateInput>
  }

  /**
   * DailyStat createMany
   */
  export type DailyStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatCreateManyInput | DailyStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyStat createManyAndReturn
   */
  export type DailyStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatCreateManyInput | DailyStatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyStat update
   */
  export type DailyStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyStat.
     */
    data: XOR<DailyStatUpdateInput, DailyStatUncheckedUpdateInput>
    /**
     * Choose, which DailyStat to update.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat updateMany
   */
  export type DailyStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyStats.
     */
    data: XOR<DailyStatUpdateManyMutationInput, DailyStatUncheckedUpdateManyInput>
    /**
     * Filter which DailyStats to update
     */
    where?: DailyStatWhereInput
  }

  /**
   * DailyStat upsert
   */
  export type DailyStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyStat to update in case it exists.
     */
    where: DailyStatWhereUniqueInput
    /**
     * In case the DailyStat found by the `where` argument doesn't exist, create a new DailyStat with this data.
     */
    create: XOR<DailyStatCreateInput, DailyStatUncheckedCreateInput>
    /**
     * In case the DailyStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyStatUpdateInput, DailyStatUncheckedUpdateInput>
  }

  /**
   * DailyStat delete
   */
  export type DailyStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
    /**
     * Filter which DailyStat to delete.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat deleteMany
   */
  export type DailyStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStats to delete
     */
    where?: DailyStatWhereInput
  }

  /**
   * DailyStat without action
   */
  export type DailyStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyStatInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    clientId: string | null
    content: string | null
    date: Date | null
    isPastComment: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    clientId: string | null
    content: string | null
    date: Date | null
    isPastComment: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    sessionId: number
    clientId: number
    content: number
    date: number
    isPastComment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    sessionId?: true
    clientId?: true
    content?: true
    date?: true
    isPastComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    sessionId?: true
    clientId?: true
    content?: true
    date?: true
    isPastComment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    sessionId?: true
    clientId?: true
    content?: true
    date?: true
    isPastComment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    sessionId: string | null
    clientId: string
    content: string
    date: Date
    isPastComment: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    clientId?: boolean
    content?: boolean
    date?: boolean
    isPastComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | Comment$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    clientId?: boolean
    content?: boolean
    date?: boolean
    isPastComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | Comment$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    sessionId?: boolean
    clientId?: boolean
    content?: boolean
    date?: boolean
    isPastComment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | Comment$sessionArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | Comment$sessionArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      clientId: string
      content: string
      date: Date
      isPastComment: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends Comment$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Comment$sessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly sessionId: FieldRef<"Comment", 'String'>
    readonly clientId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly date: FieldRef<"Comment", 'DateTime'>
    readonly isPastComment: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.session
   */
  export type Comment$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    content: string | null
    type: $Enums.MessageType | null
    scheduledTime: Date | null
    isRead: boolean | null
    isSentByCoach: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    content: string | null
    type: $Enums.MessageType | null
    scheduledTime: Date | null
    isRead: boolean | null
    isSentByCoach: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    coachId: number
    clientId: number
    content: number
    type: number
    scheduledTime: number
    isRead: number
    isSentByCoach: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    content?: true
    type?: true
    scheduledTime?: true
    isRead?: true
    isSentByCoach?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    content?: true
    type?: true
    scheduledTime?: true
    isRead?: true
    isSentByCoach?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    content?: true
    type?: true
    scheduledTime?: true
    isRead?: true
    isSentByCoach?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    coachId: string
    clientId: string
    content: string
    type: $Enums.MessageType
    scheduledTime: Date | null
    isRead: boolean
    isSentByCoach: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    content?: boolean
    type?: boolean
    scheduledTime?: boolean
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    content?: boolean
    type?: boolean
    scheduledTime?: boolean
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    content?: boolean
    type?: boolean
    scheduledTime?: boolean
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
      client: Prisma.$ClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      clientId: string
      content: string
      type: $Enums.MessageType
      scheduledTime: Date | null
      isRead: boolean
      isSentByCoach: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly coachId: FieldRef<"Message", 'String'>
    readonly clientId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly scheduledTime: FieldRef<"Message", 'DateTime'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly isSentByCoach: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    title: string | null
    description: string | null
    content: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    title: string | null
    description: string | null
    content: string | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    coachId: number
    title: number
    description: number
    content: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    description?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    description?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    coachId?: true
    title?: true
    description?: true
    content?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    coachId: string
    title: string
    description: string | null
    content: string
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    coachId?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      title: string
      description: string | null
      content: string
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly coachId: FieldRef<"Channel", 'String'>
    readonly title: FieldRef<"Channel", 'String'>
    readonly description: FieldRef<"Channel", 'String'>
    readonly content: FieldRef<"Channel", 'String'>
    readonly isPublished: FieldRef<"Channel", 'Boolean'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
    readonly updatedAt: FieldRef<"Channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    coachId: number
    clientId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    coachId: string
    clientId: string
    rating: number
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
      client: Prisma.$ClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      clientId: string
      rating: number
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly coachId: FieldRef<"Review", 'String'>
    readonly clientId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model CoachRequest
   */

  export type AggregateCoachRequest = {
    _count: CoachRequestCountAggregateOutputType | null
    _min: CoachRequestMinAggregateOutputType | null
    _max: CoachRequestMaxAggregateOutputType | null
  }

  export type CoachRequestMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachRequestMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    clientId: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachRequestCountAggregateOutputType = {
    id: number
    coachId: number
    clientId: number
    message: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachRequestMinAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachRequestMaxAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachRequestCountAggregateInputType = {
    id?: true
    coachId?: true
    clientId?: true
    message?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachRequest to aggregate.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachRequests
    **/
    _count?: true | CoachRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachRequestMaxAggregateInputType
  }

  export type GetCoachRequestAggregateType<T extends CoachRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachRequest[P]>
      : GetScalarType<T[P], AggregateCoachRequest[P]>
  }




  export type CoachRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachRequestWhereInput
    orderBy?: CoachRequestOrderByWithAggregationInput | CoachRequestOrderByWithAggregationInput[]
    by: CoachRequestScalarFieldEnum[] | CoachRequestScalarFieldEnum
    having?: CoachRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachRequestCountAggregateInputType | true
    _min?: CoachRequestMinAggregateInputType
    _max?: CoachRequestMaxAggregateInputType
  }

  export type CoachRequestGroupByOutputType = {
    id: string
    coachId: string
    clientId: string
    message: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: CoachRequestCountAggregateOutputType | null
    _min: CoachRequestMinAggregateOutputType | null
    _max: CoachRequestMaxAggregateOutputType | null
  }

  type GetCoachRequestGroupByPayload<T extends CoachRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachRequestGroupByOutputType[P]>
            : GetScalarType<T[P], CoachRequestGroupByOutputType[P]>
        }
      >
    >


  export type CoachRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachRequest"]>

  export type CoachRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachRequest"]>

  export type CoachRequestSelectScalar = {
    id?: boolean
    coachId?: boolean
    clientId?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }
  export type CoachRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
    client?: boolean | ClientProfileDefaultArgs<ExtArgs>
  }

  export type $CoachRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachRequest"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
      client: Prisma.$ClientProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      clientId: string
      message: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachRequest"]>
    composites: {}
  }

  type CoachRequestGetPayload<S extends boolean | null | undefined | CoachRequestDefaultArgs> = $Result.GetResult<Prisma.$CoachRequestPayload, S>

  type CoachRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachRequestCountAggregateInputType | true
    }

  export interface CoachRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachRequest'], meta: { name: 'CoachRequest' } }
    /**
     * Find zero or one CoachRequest that matches the filter.
     * @param {CoachRequestFindUniqueArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachRequestFindUniqueArgs>(args: SelectSubset<T, CoachRequestFindUniqueArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachRequestFindUniqueOrThrowArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestFindFirstArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachRequestFindFirstArgs>(args?: SelectSubset<T, CoachRequestFindFirstArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestFindFirstOrThrowArgs} args - Arguments to find a CoachRequest
     * @example
     * // Get one CoachRequest
     * const coachRequest = await prisma.coachRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachRequests
     * const coachRequests = await prisma.coachRequest.findMany()
     * 
     * // Get first 10 CoachRequests
     * const coachRequests = await prisma.coachRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachRequestWithIdOnly = await prisma.coachRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachRequestFindManyArgs>(args?: SelectSubset<T, CoachRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachRequest.
     * @param {CoachRequestCreateArgs} args - Arguments to create a CoachRequest.
     * @example
     * // Create one CoachRequest
     * const CoachRequest = await prisma.coachRequest.create({
     *   data: {
     *     // ... data to create a CoachRequest
     *   }
     * })
     * 
     */
    create<T extends CoachRequestCreateArgs>(args: SelectSubset<T, CoachRequestCreateArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachRequests.
     * @param {CoachRequestCreateManyArgs} args - Arguments to create many CoachRequests.
     * @example
     * // Create many CoachRequests
     * const coachRequest = await prisma.coachRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachRequestCreateManyArgs>(args?: SelectSubset<T, CoachRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachRequests and returns the data saved in the database.
     * @param {CoachRequestCreateManyAndReturnArgs} args - Arguments to create many CoachRequests.
     * @example
     * // Create many CoachRequests
     * const coachRequest = await prisma.coachRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachRequests and only return the `id`
     * const coachRequestWithIdOnly = await prisma.coachRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachRequest.
     * @param {CoachRequestDeleteArgs} args - Arguments to delete one CoachRequest.
     * @example
     * // Delete one CoachRequest
     * const CoachRequest = await prisma.coachRequest.delete({
     *   where: {
     *     // ... filter to delete one CoachRequest
     *   }
     * })
     * 
     */
    delete<T extends CoachRequestDeleteArgs>(args: SelectSubset<T, CoachRequestDeleteArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachRequest.
     * @param {CoachRequestUpdateArgs} args - Arguments to update one CoachRequest.
     * @example
     * // Update one CoachRequest
     * const coachRequest = await prisma.coachRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachRequestUpdateArgs>(args: SelectSubset<T, CoachRequestUpdateArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachRequests.
     * @param {CoachRequestDeleteManyArgs} args - Arguments to filter CoachRequests to delete.
     * @example
     * // Delete a few CoachRequests
     * const { count } = await prisma.coachRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachRequestDeleteManyArgs>(args?: SelectSubset<T, CoachRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachRequests
     * const coachRequest = await prisma.coachRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachRequestUpdateManyArgs>(args: SelectSubset<T, CoachRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachRequest.
     * @param {CoachRequestUpsertArgs} args - Arguments to update or create a CoachRequest.
     * @example
     * // Update or create a CoachRequest
     * const coachRequest = await prisma.coachRequest.upsert({
     *   create: {
     *     // ... data to create a CoachRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachRequest we want to update
     *   }
     * })
     */
    upsert<T extends CoachRequestUpsertArgs>(args: SelectSubset<T, CoachRequestUpsertArgs<ExtArgs>>): Prisma__CoachRequestClient<$Result.GetResult<Prisma.$CoachRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestCountArgs} args - Arguments to filter CoachRequests to count.
     * @example
     * // Count the number of CoachRequests
     * const count = await prisma.coachRequest.count({
     *   where: {
     *     // ... the filter for the CoachRequests we want to count
     *   }
     * })
    **/
    count<T extends CoachRequestCountArgs>(
      args?: Subset<T, CoachRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachRequestAggregateArgs>(args: Subset<T, CoachRequestAggregateArgs>): Prisma.PrismaPromise<GetCoachRequestAggregateType<T>>

    /**
     * Group by CoachRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachRequestGroupByArgs['orderBy'] }
        : { orderBy?: CoachRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachRequest model
   */
  readonly fields: CoachRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientProfileDefaultArgs<ExtArgs>>): Prisma__ClientProfileClient<$Result.GetResult<Prisma.$ClientProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachRequest model
   */ 
  interface CoachRequestFieldRefs {
    readonly id: FieldRef<"CoachRequest", 'String'>
    readonly coachId: FieldRef<"CoachRequest", 'String'>
    readonly clientId: FieldRef<"CoachRequest", 'String'>
    readonly message: FieldRef<"CoachRequest", 'String'>
    readonly status: FieldRef<"CoachRequest", 'String'>
    readonly createdAt: FieldRef<"CoachRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachRequest findUnique
   */
  export type CoachRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest findUniqueOrThrow
   */
  export type CoachRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest findFirst
   */
  export type CoachRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachRequests.
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachRequests.
     */
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachRequest findFirstOrThrow
   */
  export type CoachRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequest to fetch.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachRequests.
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachRequests.
     */
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachRequest findMany
   */
  export type CoachRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter, which CoachRequests to fetch.
     */
    where?: CoachRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachRequests to fetch.
     */
    orderBy?: CoachRequestOrderByWithRelationInput | CoachRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachRequests.
     */
    cursor?: CoachRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachRequests.
     */
    skip?: number
    distinct?: CoachRequestScalarFieldEnum | CoachRequestScalarFieldEnum[]
  }

  /**
   * CoachRequest create
   */
  export type CoachRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachRequest.
     */
    data: XOR<CoachRequestCreateInput, CoachRequestUncheckedCreateInput>
  }

  /**
   * CoachRequest createMany
   */
  export type CoachRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachRequests.
     */
    data: CoachRequestCreateManyInput | CoachRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachRequest createManyAndReturn
   */
  export type CoachRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachRequests.
     */
    data: CoachRequestCreateManyInput | CoachRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachRequest update
   */
  export type CoachRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachRequest.
     */
    data: XOR<CoachRequestUpdateInput, CoachRequestUncheckedUpdateInput>
    /**
     * Choose, which CoachRequest to update.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest updateMany
   */
  export type CoachRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachRequests.
     */
    data: XOR<CoachRequestUpdateManyMutationInput, CoachRequestUncheckedUpdateManyInput>
    /**
     * Filter which CoachRequests to update
     */
    where?: CoachRequestWhereInput
  }

  /**
   * CoachRequest upsert
   */
  export type CoachRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachRequest to update in case it exists.
     */
    where: CoachRequestWhereUniqueInput
    /**
     * In case the CoachRequest found by the `where` argument doesn't exist, create a new CoachRequest with this data.
     */
    create: XOR<CoachRequestCreateInput, CoachRequestUncheckedCreateInput>
    /**
     * In case the CoachRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachRequestUpdateInput, CoachRequestUncheckedUpdateInput>
  }

  /**
   * CoachRequest delete
   */
  export type CoachRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
    /**
     * Filter which CoachRequest to delete.
     */
    where: CoachRequestWhereUniqueInput
  }

  /**
   * CoachRequest deleteMany
   */
  export type CoachRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachRequests to delete
     */
    where?: CoachRequestWhereInput
  }

  /**
   * CoachRequest without action
   */
  export type CoachRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachRequest
     */
    select?: CoachRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachRequestInclude<ExtArgs> | null
  }


  /**
   * Model CoachPost
   */

  export type AggregateCoachPost = {
    _count: CoachPostCountAggregateOutputType | null
    _min: CoachPostMinAggregateOutputType | null
    _max: CoachPostMaxAggregateOutputType | null
  }

  export type CoachPostMinAggregateOutputType = {
    id: string | null
    coachId: string | null
    content: string | null
    mediaType: string | null
    mediaUrl: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachPostMaxAggregateOutputType = {
    id: string | null
    coachId: string | null
    content: string | null
    mediaType: string | null
    mediaUrl: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachPostCountAggregateOutputType = {
    id: number
    coachId: number
    content: number
    mediaType: number
    mediaUrl: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachPostMinAggregateInputType = {
    id?: true
    coachId?: true
    content?: true
    mediaType?: true
    mediaUrl?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachPostMaxAggregateInputType = {
    id?: true
    coachId?: true
    content?: true
    mediaType?: true
    mediaUrl?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachPostCountAggregateInputType = {
    id?: true
    coachId?: true
    content?: true
    mediaType?: true
    mediaUrl?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachPost to aggregate.
     */
    where?: CoachPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachPosts to fetch.
     */
    orderBy?: CoachPostOrderByWithRelationInput | CoachPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachPosts
    **/
    _count?: true | CoachPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachPostMaxAggregateInputType
  }

  export type GetCoachPostAggregateType<T extends CoachPostAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachPost[P]>
      : GetScalarType<T[P], AggregateCoachPost[P]>
  }




  export type CoachPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachPostWhereInput
    orderBy?: CoachPostOrderByWithAggregationInput | CoachPostOrderByWithAggregationInput[]
    by: CoachPostScalarFieldEnum[] | CoachPostScalarFieldEnum
    having?: CoachPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachPostCountAggregateInputType | true
    _min?: CoachPostMinAggregateInputType
    _max?: CoachPostMaxAggregateInputType
  }

  export type CoachPostGroupByOutputType = {
    id: string
    coachId: string
    content: string
    mediaType: string | null
    mediaUrl: string | null
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: CoachPostCountAggregateOutputType | null
    _min: CoachPostMinAggregateOutputType | null
    _max: CoachPostMaxAggregateOutputType | null
  }

  type GetCoachPostGroupByPayload<T extends CoachPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachPostGroupByOutputType[P]>
            : GetScalarType<T[P], CoachPostGroupByOutputType[P]>
        }
      >
    >


  export type CoachPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    content?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachPost"]>

  export type CoachPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coachId?: boolean
    content?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachPost"]>

  export type CoachPostSelectScalar = {
    id?: boolean
    coachId?: boolean
    content?: boolean
    mediaType?: boolean
    mediaUrl?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }
  export type CoachPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coach?: boolean | CoachProfileDefaultArgs<ExtArgs>
  }

  export type $CoachPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachPost"
    objects: {
      coach: Prisma.$CoachProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coachId: string
      content: string
      mediaType: string | null
      mediaUrl: string | null
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachPost"]>
    composites: {}
  }

  type CoachPostGetPayload<S extends boolean | null | undefined | CoachPostDefaultArgs> = $Result.GetResult<Prisma.$CoachPostPayload, S>

  type CoachPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachPostCountAggregateInputType | true
    }

  export interface CoachPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachPost'], meta: { name: 'CoachPost' } }
    /**
     * Find zero or one CoachPost that matches the filter.
     * @param {CoachPostFindUniqueArgs} args - Arguments to find a CoachPost
     * @example
     * // Get one CoachPost
     * const coachPost = await prisma.coachPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachPostFindUniqueArgs>(args: SelectSubset<T, CoachPostFindUniqueArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachPostFindUniqueOrThrowArgs} args - Arguments to find a CoachPost
     * @example
     * // Get one CoachPost
     * const coachPost = await prisma.coachPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachPostFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostFindFirstArgs} args - Arguments to find a CoachPost
     * @example
     * // Get one CoachPost
     * const coachPost = await prisma.coachPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachPostFindFirstArgs>(args?: SelectSubset<T, CoachPostFindFirstArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostFindFirstOrThrowArgs} args - Arguments to find a CoachPost
     * @example
     * // Get one CoachPost
     * const coachPost = await prisma.coachPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachPostFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachPosts
     * const coachPosts = await prisma.coachPost.findMany()
     * 
     * // Get first 10 CoachPosts
     * const coachPosts = await prisma.coachPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachPostWithIdOnly = await prisma.coachPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachPostFindManyArgs>(args?: SelectSubset<T, CoachPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachPost.
     * @param {CoachPostCreateArgs} args - Arguments to create a CoachPost.
     * @example
     * // Create one CoachPost
     * const CoachPost = await prisma.coachPost.create({
     *   data: {
     *     // ... data to create a CoachPost
     *   }
     * })
     * 
     */
    create<T extends CoachPostCreateArgs>(args: SelectSubset<T, CoachPostCreateArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachPosts.
     * @param {CoachPostCreateManyArgs} args - Arguments to create many CoachPosts.
     * @example
     * // Create many CoachPosts
     * const coachPost = await prisma.coachPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachPostCreateManyArgs>(args?: SelectSubset<T, CoachPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachPosts and returns the data saved in the database.
     * @param {CoachPostCreateManyAndReturnArgs} args - Arguments to create many CoachPosts.
     * @example
     * // Create many CoachPosts
     * const coachPost = await prisma.coachPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachPosts and only return the `id`
     * const coachPostWithIdOnly = await prisma.coachPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachPostCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachPost.
     * @param {CoachPostDeleteArgs} args - Arguments to delete one CoachPost.
     * @example
     * // Delete one CoachPost
     * const CoachPost = await prisma.coachPost.delete({
     *   where: {
     *     // ... filter to delete one CoachPost
     *   }
     * })
     * 
     */
    delete<T extends CoachPostDeleteArgs>(args: SelectSubset<T, CoachPostDeleteArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachPost.
     * @param {CoachPostUpdateArgs} args - Arguments to update one CoachPost.
     * @example
     * // Update one CoachPost
     * const coachPost = await prisma.coachPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachPostUpdateArgs>(args: SelectSubset<T, CoachPostUpdateArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachPosts.
     * @param {CoachPostDeleteManyArgs} args - Arguments to filter CoachPosts to delete.
     * @example
     * // Delete a few CoachPosts
     * const { count } = await prisma.coachPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachPostDeleteManyArgs>(args?: SelectSubset<T, CoachPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachPosts
     * const coachPost = await prisma.coachPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachPostUpdateManyArgs>(args: SelectSubset<T, CoachPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachPost.
     * @param {CoachPostUpsertArgs} args - Arguments to update or create a CoachPost.
     * @example
     * // Update or create a CoachPost
     * const coachPost = await prisma.coachPost.upsert({
     *   create: {
     *     // ... data to create a CoachPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachPost we want to update
     *   }
     * })
     */
    upsert<T extends CoachPostUpsertArgs>(args: SelectSubset<T, CoachPostUpsertArgs<ExtArgs>>): Prisma__CoachPostClient<$Result.GetResult<Prisma.$CoachPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostCountArgs} args - Arguments to filter CoachPosts to count.
     * @example
     * // Count the number of CoachPosts
     * const count = await prisma.coachPost.count({
     *   where: {
     *     // ... the filter for the CoachPosts we want to count
     *   }
     * })
    **/
    count<T extends CoachPostCountArgs>(
      args?: Subset<T, CoachPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachPostAggregateArgs>(args: Subset<T, CoachPostAggregateArgs>): Prisma.PrismaPromise<GetCoachPostAggregateType<T>>

    /**
     * Group by CoachPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachPostGroupByArgs['orderBy'] }
        : { orderBy?: CoachPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachPost model
   */
  readonly fields: CoachPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coach<T extends CoachProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoachProfileDefaultArgs<ExtArgs>>): Prisma__CoachProfileClient<$Result.GetResult<Prisma.$CoachProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachPost model
   */ 
  interface CoachPostFieldRefs {
    readonly id: FieldRef<"CoachPost", 'String'>
    readonly coachId: FieldRef<"CoachPost", 'String'>
    readonly content: FieldRef<"CoachPost", 'String'>
    readonly mediaType: FieldRef<"CoachPost", 'String'>
    readonly mediaUrl: FieldRef<"CoachPost", 'String'>
    readonly isPublic: FieldRef<"CoachPost", 'Boolean'>
    readonly createdAt: FieldRef<"CoachPost", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachPost findUnique
   */
  export type CoachPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * Filter, which CoachPost to fetch.
     */
    where: CoachPostWhereUniqueInput
  }

  /**
   * CoachPost findUniqueOrThrow
   */
  export type CoachPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * Filter, which CoachPost to fetch.
     */
    where: CoachPostWhereUniqueInput
  }

  /**
   * CoachPost findFirst
   */
  export type CoachPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * Filter, which CoachPost to fetch.
     */
    where?: CoachPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachPosts to fetch.
     */
    orderBy?: CoachPostOrderByWithRelationInput | CoachPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachPosts.
     */
    cursor?: CoachPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachPosts.
     */
    distinct?: CoachPostScalarFieldEnum | CoachPostScalarFieldEnum[]
  }

  /**
   * CoachPost findFirstOrThrow
   */
  export type CoachPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * Filter, which CoachPost to fetch.
     */
    where?: CoachPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachPosts to fetch.
     */
    orderBy?: CoachPostOrderByWithRelationInput | CoachPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachPosts.
     */
    cursor?: CoachPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachPosts.
     */
    distinct?: CoachPostScalarFieldEnum | CoachPostScalarFieldEnum[]
  }

  /**
   * CoachPost findMany
   */
  export type CoachPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * Filter, which CoachPosts to fetch.
     */
    where?: CoachPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachPosts to fetch.
     */
    orderBy?: CoachPostOrderByWithRelationInput | CoachPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachPosts.
     */
    cursor?: CoachPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachPosts.
     */
    skip?: number
    distinct?: CoachPostScalarFieldEnum | CoachPostScalarFieldEnum[]
  }

  /**
   * CoachPost create
   */
  export type CoachPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachPost.
     */
    data: XOR<CoachPostCreateInput, CoachPostUncheckedCreateInput>
  }

  /**
   * CoachPost createMany
   */
  export type CoachPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachPosts.
     */
    data: CoachPostCreateManyInput | CoachPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoachPost createManyAndReturn
   */
  export type CoachPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachPosts.
     */
    data: CoachPostCreateManyInput | CoachPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachPost update
   */
  export type CoachPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachPost.
     */
    data: XOR<CoachPostUpdateInput, CoachPostUncheckedUpdateInput>
    /**
     * Choose, which CoachPost to update.
     */
    where: CoachPostWhereUniqueInput
  }

  /**
   * CoachPost updateMany
   */
  export type CoachPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachPosts.
     */
    data: XOR<CoachPostUpdateManyMutationInput, CoachPostUncheckedUpdateManyInput>
    /**
     * Filter which CoachPosts to update
     */
    where?: CoachPostWhereInput
  }

  /**
   * CoachPost upsert
   */
  export type CoachPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachPost to update in case it exists.
     */
    where: CoachPostWhereUniqueInput
    /**
     * In case the CoachPost found by the `where` argument doesn't exist, create a new CoachPost with this data.
     */
    create: XOR<CoachPostCreateInput, CoachPostUncheckedCreateInput>
    /**
     * In case the CoachPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachPostUpdateInput, CoachPostUncheckedUpdateInput>
  }

  /**
   * CoachPost delete
   */
  export type CoachPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
    /**
     * Filter which CoachPost to delete.
     */
    where: CoachPostWhereUniqueInput
  }

  /**
   * CoachPost deleteMany
   */
  export type CoachPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachPosts to delete
     */
    where?: CoachPostWhereInput
  }

  /**
   * CoachPost without action
   */
  export type CoachPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachPost
     */
    select?: CoachPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachPostInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    birthDate: 'birthDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CoachProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    experience: 'experience',
    rating: 'rating',
    ratingCount: 'ratingCount',
    profilePicture: 'profilePicture',
    city: 'city',
    isRemote: 'isRemote',
    trainingLocations: 'trainingLocations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachProfileScalarFieldEnum = (typeof CoachProfileScalarFieldEnum)[keyof typeof CoachProfileScalarFieldEnum]


  export const ClientProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coachId: 'coachId',
    weight: 'weight',
    height: 'height',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    goals: 'goals',
    level: 'level',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientProfileScalarFieldEnum = (typeof ClientProfileScalarFieldEnum)[keyof typeof ClientProfileScalarFieldEnum]


  export const ClientCoachScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    coachId: 'coachId',
    isPrimary: 'isPrimary',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientCoachScalarFieldEnum = (typeof ClientCoachScalarFieldEnum)[keyof typeof ClientCoachScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    clientId: 'clientId',
    title: 'title',
    description: 'description',
    cycleDays: 'cycleDays',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    dietEnabled: 'dietEnabled',
    dietType: 'dietType',
    targetCalories: 'targetCalories',
    waterTrackingEnabled: 'waterTrackingEnabled',
    waterGoal: 'waterGoal',
    sleepTrackingEnabled: 'sleepTrackingEnabled',
    weightTrackingEnabled: 'weightTrackingEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ProgramTemplateScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    name: 'name',
    description: 'description',
    cycleDays: 'cycleDays',
    dietEnabled: 'dietEnabled',
    dietType: 'dietType',
    targetCalories: 'targetCalories',
    waterTrackingEnabled: 'waterTrackingEnabled',
    waterGoal: 'waterGoal',
    sleepTrackingEnabled: 'sleepTrackingEnabled',
    weightTrackingEnabled: 'weightTrackingEnabled',
    sessionsData: 'sessionsData',
    customGoalsData: 'customGoalsData',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramTemplateScalarFieldEnum = (typeof ProgramTemplateScalarFieldEnum)[keyof typeof ProgramTemplateScalarFieldEnum]


  export const CustomGoalScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    title: 'title',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomGoalScalarFieldEnum = (typeof CustomGoalScalarFieldEnum)[keyof typeof CustomGoalScalarFieldEnum]


  export const GoalCompletionScalarFieldEnum: {
    id: 'id',
    customGoalId: 'customGoalId',
    clientId: 'clientId',
    date: 'date',
    completed: 'completed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoalCompletionScalarFieldEnum = (typeof GoalCompletionScalarFieldEnum)[keyof typeof GoalCompletionScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    date: 'date',
    status: 'status',
    isRestDay: 'isRestDay',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    name: 'name',
    category: 'category',
    sets: 'sets',
    reps: 'reps',
    weight: 'weight',
    restTime: 'restTime',
    videoUrl: 'videoUrl',
    gifUrl: 'gifUrl',
    description: 'description',
    order: 'order',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const SetCompletionScalarFieldEnum: {
    id: 'id',
    exerciseId: 'exerciseId',
    setNumber: 'setNumber',
    repsAchieved: 'repsAchieved',
    weightUsed: 'weightUsed',
    completed: 'completed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SetCompletionScalarFieldEnum = (typeof SetCompletionScalarFieldEnum)[keyof typeof SetCompletionScalarFieldEnum]


  export const MealPlanScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    title: 'title',
    description: 'description',
    dailyCalories: 'dailyCalories',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MealPlanScalarFieldEnum = (typeof MealPlanScalarFieldEnum)[keyof typeof MealPlanScalarFieldEnum]


  export const MenuItemScalarFieldEnum: {
    id: 'id',
    mealPlanId: 'mealPlanId',
    mealType: 'mealType',
    name: 'name',
    description: 'description',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


  export const MealScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    date: 'date',
    mealType: 'mealType',
    description: 'description',
    photoUrl: 'photoUrl',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fats: 'fats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MealScalarFieldEnum = (typeof MealScalarFieldEnum)[keyof typeof MealScalarFieldEnum]


  export const DailyStatScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    date: 'date',
    sleepHours: 'sleepHours',
    bedTime: 'bedTime',
    wakeTime: 'wakeTime',
    waterIntake: 'waterIntake',
    weight: 'weight',
    totalCalories: 'totalCalories',
    workoutTime: 'workoutTime',
    workoutDuration: 'workoutDuration',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyStatScalarFieldEnum = (typeof DailyStatScalarFieldEnum)[keyof typeof DailyStatScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    clientId: 'clientId',
    content: 'content',
    date: 'date',
    isPastComment: 'isPastComment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    clientId: 'clientId',
    content: 'content',
    type: 'type',
    scheduledTime: 'scheduledTime',
    isRead: 'isRead',
    isSentByCoach: 'isSentByCoach',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    title: 'title',
    description: 'description',
    content: 'content',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    clientId: 'clientId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const CoachRequestScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    clientId: 'clientId',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachRequestScalarFieldEnum = (typeof CoachRequestScalarFieldEnum)[keyof typeof CoachRequestScalarFieldEnum]


  export const CoachPostScalarFieldEnum: {
    id: 'id',
    coachId: 'coachId',
    content: 'content',
    mediaType: 'mediaType',
    mediaUrl: 'mediaUrl',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachPostScalarFieldEnum = (typeof CoachPostScalarFieldEnum)[keyof typeof CoachPostScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'ExerciseCategory'
   */
  export type EnumExerciseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseCategory'>
    


  /**
   * Reference to a field of type 'ExerciseCategory[]'
   */
  export type ListEnumExerciseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExerciseCategory[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    coachProfile?: XOR<CoachProfileNullableRelationFilter, CoachProfileWhereInput> | null
    clientProfile?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coachProfile?: CoachProfileOrderByWithRelationInput
    clientProfile?: ClientProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    coachProfile?: XOR<CoachProfileNullableRelationFilter, CoachProfileWhereInput> | null
    clientProfile?: XOR<ClientProfileNullableRelationFilter, ClientProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CoachProfileWhereInput = {
    AND?: CoachProfileWhereInput | CoachProfileWhereInput[]
    OR?: CoachProfileWhereInput[]
    NOT?: CoachProfileWhereInput | CoachProfileWhereInput[]
    id?: StringFilter<"CoachProfile"> | string
    userId?: StringFilter<"CoachProfile"> | string
    bio?: StringNullableFilter<"CoachProfile"> | string | null
    experience?: StringNullableFilter<"CoachProfile"> | string | null
    rating?: FloatFilter<"CoachProfile"> | number
    ratingCount?: IntFilter<"CoachProfile"> | number
    profilePicture?: StringNullableFilter<"CoachProfile"> | string | null
    city?: StringNullableFilter<"CoachProfile"> | string | null
    isRemote?: BoolFilter<"CoachProfile"> | boolean
    trainingLocations?: StringNullableListFilter<"CoachProfile">
    createdAt?: DateTimeFilter<"CoachProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CoachProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clients?: ClientProfileListRelationFilter
    clientCoaches?: ClientCoachListRelationFilter
    programs?: ProgramListRelationFilter
    programTemplates?: ProgramTemplateListRelationFilter
    sentMessages?: MessageListRelationFilter
    channels?: ChannelListRelationFilter
    reviews?: ReviewListRelationFilter
    posts?: CoachPostListRelationFilter
    coachRequests?: CoachRequestListRelationFilter
  }

  export type CoachProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    isRemote?: SortOrder
    trainingLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    clients?: ClientProfileOrderByRelationAggregateInput
    clientCoaches?: ClientCoachOrderByRelationAggregateInput
    programs?: ProgramOrderByRelationAggregateInput
    programTemplates?: ProgramTemplateOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    posts?: CoachPostOrderByRelationAggregateInput
    coachRequests?: CoachRequestOrderByRelationAggregateInput
  }

  export type CoachProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CoachProfileWhereInput | CoachProfileWhereInput[]
    OR?: CoachProfileWhereInput[]
    NOT?: CoachProfileWhereInput | CoachProfileWhereInput[]
    bio?: StringNullableFilter<"CoachProfile"> | string | null
    experience?: StringNullableFilter<"CoachProfile"> | string | null
    rating?: FloatFilter<"CoachProfile"> | number
    ratingCount?: IntFilter<"CoachProfile"> | number
    profilePicture?: StringNullableFilter<"CoachProfile"> | string | null
    city?: StringNullableFilter<"CoachProfile"> | string | null
    isRemote?: BoolFilter<"CoachProfile"> | boolean
    trainingLocations?: StringNullableListFilter<"CoachProfile">
    createdAt?: DateTimeFilter<"CoachProfile"> | Date | string
    updatedAt?: DateTimeFilter<"CoachProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clients?: ClientProfileListRelationFilter
    clientCoaches?: ClientCoachListRelationFilter
    programs?: ProgramListRelationFilter
    programTemplates?: ProgramTemplateListRelationFilter
    sentMessages?: MessageListRelationFilter
    channels?: ChannelListRelationFilter
    reviews?: ReviewListRelationFilter
    posts?: CoachPostListRelationFilter
    coachRequests?: CoachRequestListRelationFilter
  }, "id" | "userId">

  export type CoachProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    isRemote?: SortOrder
    trainingLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachProfileCountOrderByAggregateInput
    _avg?: CoachProfileAvgOrderByAggregateInput
    _max?: CoachProfileMaxOrderByAggregateInput
    _min?: CoachProfileMinOrderByAggregateInput
    _sum?: CoachProfileSumOrderByAggregateInput
  }

  export type CoachProfileScalarWhereWithAggregatesInput = {
    AND?: CoachProfileScalarWhereWithAggregatesInput | CoachProfileScalarWhereWithAggregatesInput[]
    OR?: CoachProfileScalarWhereWithAggregatesInput[]
    NOT?: CoachProfileScalarWhereWithAggregatesInput | CoachProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachProfile"> | string
    userId?: StringWithAggregatesFilter<"CoachProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"CoachProfile"> | string | null
    experience?: StringNullableWithAggregatesFilter<"CoachProfile"> | string | null
    rating?: FloatWithAggregatesFilter<"CoachProfile"> | number
    ratingCount?: IntWithAggregatesFilter<"CoachProfile"> | number
    profilePicture?: StringNullableWithAggregatesFilter<"CoachProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"CoachProfile"> | string | null
    isRemote?: BoolWithAggregatesFilter<"CoachProfile"> | boolean
    trainingLocations?: StringNullableListFilter<"CoachProfile">
    createdAt?: DateTimeWithAggregatesFilter<"CoachProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachProfile"> | Date | string
  }

  export type ClientProfileWhereInput = {
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    id?: StringFilter<"ClientProfile"> | string
    userId?: StringFilter<"ClientProfile"> | string
    coachId?: StringNullableFilter<"ClientProfile"> | string | null
    weight?: FloatNullableFilter<"ClientProfile"> | number | null
    height?: FloatNullableFilter<"ClientProfile"> | number | null
    dateOfBirth?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    gender?: StringNullableFilter<"ClientProfile"> | string | null
    goals?: StringNullableFilter<"ClientProfile"> | string | null
    level?: StringNullableFilter<"ClientProfile"> | string | null
    profilePicture?: StringNullableFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    coach?: XOR<CoachProfileNullableRelationFilter, CoachProfileWhereInput> | null
    coaches?: ClientCoachListRelationFilter
    stats?: DailyStatListRelationFilter
    meals?: MealListRelationFilter
    receivedMessages?: MessageListRelationFilter
    reviews?: ReviewListRelationFilter
    coachRequests?: CoachRequestListRelationFilter
  }

  export type ClientProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coach?: CoachProfileOrderByWithRelationInput
    coaches?: ClientCoachOrderByRelationAggregateInput
    stats?: DailyStatOrderByRelationAggregateInput
    meals?: MealOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    coachRequests?: CoachRequestOrderByRelationAggregateInput
  }

  export type ClientProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ClientProfileWhereInput | ClientProfileWhereInput[]
    OR?: ClientProfileWhereInput[]
    NOT?: ClientProfileWhereInput | ClientProfileWhereInput[]
    coachId?: StringNullableFilter<"ClientProfile"> | string | null
    weight?: FloatNullableFilter<"ClientProfile"> | number | null
    height?: FloatNullableFilter<"ClientProfile"> | number | null
    dateOfBirth?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    gender?: StringNullableFilter<"ClientProfile"> | string | null
    goals?: StringNullableFilter<"ClientProfile"> | string | null
    level?: StringNullableFilter<"ClientProfile"> | string | null
    profilePicture?: StringNullableFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    coach?: XOR<CoachProfileNullableRelationFilter, CoachProfileWhereInput> | null
    coaches?: ClientCoachListRelationFilter
    stats?: DailyStatListRelationFilter
    meals?: MealListRelationFilter
    receivedMessages?: MessageListRelationFilter
    reviews?: ReviewListRelationFilter
    coachRequests?: CoachRequestListRelationFilter
  }, "id" | "userId">

  export type ClientProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    goals?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientProfileCountOrderByAggregateInput
    _avg?: ClientProfileAvgOrderByAggregateInput
    _max?: ClientProfileMaxOrderByAggregateInput
    _min?: ClientProfileMinOrderByAggregateInput
    _sum?: ClientProfileSumOrderByAggregateInput
  }

  export type ClientProfileScalarWhereWithAggregatesInput = {
    AND?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    OR?: ClientProfileScalarWhereWithAggregatesInput[]
    NOT?: ClientProfileScalarWhereWithAggregatesInput | ClientProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientProfile"> | string
    userId?: StringWithAggregatesFilter<"ClientProfile"> | string
    coachId?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"ClientProfile"> | number | null
    height?: FloatNullableWithAggregatesFilter<"ClientProfile"> | number | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"ClientProfile"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    goals?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    level?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientProfile"> | Date | string
  }

  export type ClientCoachWhereInput = {
    AND?: ClientCoachWhereInput | ClientCoachWhereInput[]
    OR?: ClientCoachWhereInput[]
    NOT?: ClientCoachWhereInput | ClientCoachWhereInput[]
    id?: StringFilter<"ClientCoach"> | string
    clientId?: StringFilter<"ClientCoach"> | string
    coachId?: StringFilter<"ClientCoach"> | string
    isPrimary?: BoolFilter<"ClientCoach"> | boolean
    startDate?: DateTimeFilter<"ClientCoach"> | Date | string
    endDate?: DateTimeNullableFilter<"ClientCoach"> | Date | string | null
    isActive?: BoolFilter<"ClientCoach"> | boolean
    createdAt?: DateTimeFilter<"ClientCoach"> | Date | string
    updatedAt?: DateTimeFilter<"ClientCoach"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }

  export type ClientCoachOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    coachId?: SortOrder
    isPrimary?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
    coach?: CoachProfileOrderByWithRelationInput
  }

  export type ClientCoachWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_coachId?: ClientCoachClientIdCoachIdCompoundUniqueInput
    AND?: ClientCoachWhereInput | ClientCoachWhereInput[]
    OR?: ClientCoachWhereInput[]
    NOT?: ClientCoachWhereInput | ClientCoachWhereInput[]
    clientId?: StringFilter<"ClientCoach"> | string
    coachId?: StringFilter<"ClientCoach"> | string
    isPrimary?: BoolFilter<"ClientCoach"> | boolean
    startDate?: DateTimeFilter<"ClientCoach"> | Date | string
    endDate?: DateTimeNullableFilter<"ClientCoach"> | Date | string | null
    isActive?: BoolFilter<"ClientCoach"> | boolean
    createdAt?: DateTimeFilter<"ClientCoach"> | Date | string
    updatedAt?: DateTimeFilter<"ClientCoach"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }, "id" | "clientId_coachId">

  export type ClientCoachOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    coachId?: SortOrder
    isPrimary?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCoachCountOrderByAggregateInput
    _max?: ClientCoachMaxOrderByAggregateInput
    _min?: ClientCoachMinOrderByAggregateInput
  }

  export type ClientCoachScalarWhereWithAggregatesInput = {
    AND?: ClientCoachScalarWhereWithAggregatesInput | ClientCoachScalarWhereWithAggregatesInput[]
    OR?: ClientCoachScalarWhereWithAggregatesInput[]
    NOT?: ClientCoachScalarWhereWithAggregatesInput | ClientCoachScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientCoach"> | string
    clientId?: StringWithAggregatesFilter<"ClientCoach"> | string
    coachId?: StringWithAggregatesFilter<"ClientCoach"> | string
    isPrimary?: BoolWithAggregatesFilter<"ClientCoach"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"ClientCoach"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ClientCoach"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ClientCoach"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClientCoach"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientCoach"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    coachId?: StringFilter<"Program"> | string
    clientId?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    description?: StringNullableFilter<"Program"> | string | null
    cycleDays?: IntNullableFilter<"Program"> | number | null
    startDate?: DateTimeFilter<"Program"> | Date | string
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    isActive?: BoolFilter<"Program"> | boolean
    dietEnabled?: BoolFilter<"Program"> | boolean
    dietType?: StringNullableFilter<"Program"> | string | null
    targetCalories?: IntNullableFilter<"Program"> | number | null
    waterTrackingEnabled?: BoolFilter<"Program"> | boolean
    waterGoal?: FloatNullableFilter<"Program"> | number | null
    sleepTrackingEnabled?: BoolFilter<"Program"> | boolean
    weightTrackingEnabled?: BoolFilter<"Program"> | boolean
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    sessions?: SessionListRelationFilter
    mealPlans?: MealPlanListRelationFilter
    customGoals?: CustomGoalListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    cycleDays?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrderInput | SortOrder
    targetCalories?: SortOrderInput | SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrderInput | SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    mealPlans?: MealPlanOrderByRelationAggregateInput
    customGoals?: CustomGoalOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    coachId?: StringFilter<"Program"> | string
    clientId?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    description?: StringNullableFilter<"Program"> | string | null
    cycleDays?: IntNullableFilter<"Program"> | number | null
    startDate?: DateTimeFilter<"Program"> | Date | string
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    isActive?: BoolFilter<"Program"> | boolean
    dietEnabled?: BoolFilter<"Program"> | boolean
    dietType?: StringNullableFilter<"Program"> | string | null
    targetCalories?: IntNullableFilter<"Program"> | number | null
    waterTrackingEnabled?: BoolFilter<"Program"> | boolean
    waterGoal?: FloatNullableFilter<"Program"> | number | null
    sleepTrackingEnabled?: BoolFilter<"Program"> | boolean
    weightTrackingEnabled?: BoolFilter<"Program"> | boolean
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    sessions?: SessionListRelationFilter
    mealPlans?: MealPlanListRelationFilter
    customGoals?: CustomGoalListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    cycleDays?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrderInput | SortOrder
    targetCalories?: SortOrderInput | SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrderInput | SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    coachId?: StringWithAggregatesFilter<"Program"> | string
    clientId?: StringWithAggregatesFilter<"Program"> | string
    title?: StringWithAggregatesFilter<"Program"> | string
    description?: StringNullableWithAggregatesFilter<"Program"> | string | null
    cycleDays?: IntNullableWithAggregatesFilter<"Program"> | number | null
    startDate?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Program"> | boolean
    dietEnabled?: BoolWithAggregatesFilter<"Program"> | boolean
    dietType?: StringNullableWithAggregatesFilter<"Program"> | string | null
    targetCalories?: IntNullableWithAggregatesFilter<"Program"> | number | null
    waterTrackingEnabled?: BoolWithAggregatesFilter<"Program"> | boolean
    waterGoal?: FloatNullableWithAggregatesFilter<"Program"> | number | null
    sleepTrackingEnabled?: BoolWithAggregatesFilter<"Program"> | boolean
    weightTrackingEnabled?: BoolWithAggregatesFilter<"Program"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type ProgramTemplateWhereInput = {
    AND?: ProgramTemplateWhereInput | ProgramTemplateWhereInput[]
    OR?: ProgramTemplateWhereInput[]
    NOT?: ProgramTemplateWhereInput | ProgramTemplateWhereInput[]
    id?: StringFilter<"ProgramTemplate"> | string
    coachId?: StringFilter<"ProgramTemplate"> | string
    name?: StringFilter<"ProgramTemplate"> | string
    description?: StringNullableFilter<"ProgramTemplate"> | string | null
    cycleDays?: IntNullableFilter<"ProgramTemplate"> | number | null
    dietEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    dietType?: StringNullableFilter<"ProgramTemplate"> | string | null
    targetCalories?: IntNullableFilter<"ProgramTemplate"> | number | null
    waterTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    waterGoal?: FloatNullableFilter<"ProgramTemplate"> | number | null
    sleepTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    weightTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    sessionsData?: JsonNullableFilter<"ProgramTemplate">
    customGoalsData?: JsonNullableFilter<"ProgramTemplate">
    createdAt?: DateTimeFilter<"ProgramTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramTemplate"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }

  export type ProgramTemplateOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cycleDays?: SortOrderInput | SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrderInput | SortOrder
    targetCalories?: SortOrderInput | SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrderInput | SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    sessionsData?: SortOrderInput | SortOrder
    customGoalsData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
  }

  export type ProgramTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramTemplateWhereInput | ProgramTemplateWhereInput[]
    OR?: ProgramTemplateWhereInput[]
    NOT?: ProgramTemplateWhereInput | ProgramTemplateWhereInput[]
    coachId?: StringFilter<"ProgramTemplate"> | string
    name?: StringFilter<"ProgramTemplate"> | string
    description?: StringNullableFilter<"ProgramTemplate"> | string | null
    cycleDays?: IntNullableFilter<"ProgramTemplate"> | number | null
    dietEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    dietType?: StringNullableFilter<"ProgramTemplate"> | string | null
    targetCalories?: IntNullableFilter<"ProgramTemplate"> | number | null
    waterTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    waterGoal?: FloatNullableFilter<"ProgramTemplate"> | number | null
    sleepTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    weightTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    sessionsData?: JsonNullableFilter<"ProgramTemplate">
    customGoalsData?: JsonNullableFilter<"ProgramTemplate">
    createdAt?: DateTimeFilter<"ProgramTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramTemplate"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }, "id">

  export type ProgramTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cycleDays?: SortOrderInput | SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrderInput | SortOrder
    targetCalories?: SortOrderInput | SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrderInput | SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    sessionsData?: SortOrderInput | SortOrder
    customGoalsData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramTemplateCountOrderByAggregateInput
    _avg?: ProgramTemplateAvgOrderByAggregateInput
    _max?: ProgramTemplateMaxOrderByAggregateInput
    _min?: ProgramTemplateMinOrderByAggregateInput
    _sum?: ProgramTemplateSumOrderByAggregateInput
  }

  export type ProgramTemplateScalarWhereWithAggregatesInput = {
    AND?: ProgramTemplateScalarWhereWithAggregatesInput | ProgramTemplateScalarWhereWithAggregatesInput[]
    OR?: ProgramTemplateScalarWhereWithAggregatesInput[]
    NOT?: ProgramTemplateScalarWhereWithAggregatesInput | ProgramTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramTemplate"> | string
    coachId?: StringWithAggregatesFilter<"ProgramTemplate"> | string
    name?: StringWithAggregatesFilter<"ProgramTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ProgramTemplate"> | string | null
    cycleDays?: IntNullableWithAggregatesFilter<"ProgramTemplate"> | number | null
    dietEnabled?: BoolWithAggregatesFilter<"ProgramTemplate"> | boolean
    dietType?: StringNullableWithAggregatesFilter<"ProgramTemplate"> | string | null
    targetCalories?: IntNullableWithAggregatesFilter<"ProgramTemplate"> | number | null
    waterTrackingEnabled?: BoolWithAggregatesFilter<"ProgramTemplate"> | boolean
    waterGoal?: FloatNullableWithAggregatesFilter<"ProgramTemplate"> | number | null
    sleepTrackingEnabled?: BoolWithAggregatesFilter<"ProgramTemplate"> | boolean
    weightTrackingEnabled?: BoolWithAggregatesFilter<"ProgramTemplate"> | boolean
    sessionsData?: JsonNullableWithAggregatesFilter<"ProgramTemplate">
    customGoalsData?: JsonNullableWithAggregatesFilter<"ProgramTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"ProgramTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProgramTemplate"> | Date | string
  }

  export type CustomGoalWhereInput = {
    AND?: CustomGoalWhereInput | CustomGoalWhereInput[]
    OR?: CustomGoalWhereInput[]
    NOT?: CustomGoalWhereInput | CustomGoalWhereInput[]
    id?: StringFilter<"CustomGoal"> | string
    programId?: StringFilter<"CustomGoal"> | string
    title?: StringFilter<"CustomGoal"> | string
    description?: StringNullableFilter<"CustomGoal"> | string | null
    order?: IntFilter<"CustomGoal"> | number
    createdAt?: DateTimeFilter<"CustomGoal"> | Date | string
    updatedAt?: DateTimeFilter<"CustomGoal"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    completions?: GoalCompletionListRelationFilter
  }

  export type CustomGoalOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
    completions?: GoalCompletionOrderByRelationAggregateInput
  }

  export type CustomGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomGoalWhereInput | CustomGoalWhereInput[]
    OR?: CustomGoalWhereInput[]
    NOT?: CustomGoalWhereInput | CustomGoalWhereInput[]
    programId?: StringFilter<"CustomGoal"> | string
    title?: StringFilter<"CustomGoal"> | string
    description?: StringNullableFilter<"CustomGoal"> | string | null
    order?: IntFilter<"CustomGoal"> | number
    createdAt?: DateTimeFilter<"CustomGoal"> | Date | string
    updatedAt?: DateTimeFilter<"CustomGoal"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    completions?: GoalCompletionListRelationFilter
  }, "id">

  export type CustomGoalOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomGoalCountOrderByAggregateInput
    _avg?: CustomGoalAvgOrderByAggregateInput
    _max?: CustomGoalMaxOrderByAggregateInput
    _min?: CustomGoalMinOrderByAggregateInput
    _sum?: CustomGoalSumOrderByAggregateInput
  }

  export type CustomGoalScalarWhereWithAggregatesInput = {
    AND?: CustomGoalScalarWhereWithAggregatesInput | CustomGoalScalarWhereWithAggregatesInput[]
    OR?: CustomGoalScalarWhereWithAggregatesInput[]
    NOT?: CustomGoalScalarWhereWithAggregatesInput | CustomGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomGoal"> | string
    programId?: StringWithAggregatesFilter<"CustomGoal"> | string
    title?: StringWithAggregatesFilter<"CustomGoal"> | string
    description?: StringNullableWithAggregatesFilter<"CustomGoal"> | string | null
    order?: IntWithAggregatesFilter<"CustomGoal"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomGoal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomGoal"> | Date | string
  }

  export type GoalCompletionWhereInput = {
    AND?: GoalCompletionWhereInput | GoalCompletionWhereInput[]
    OR?: GoalCompletionWhereInput[]
    NOT?: GoalCompletionWhereInput | GoalCompletionWhereInput[]
    id?: StringFilter<"GoalCompletion"> | string
    customGoalId?: StringFilter<"GoalCompletion"> | string
    clientId?: StringFilter<"GoalCompletion"> | string
    date?: DateTimeFilter<"GoalCompletion"> | Date | string
    completed?: BoolFilter<"GoalCompletion"> | boolean
    createdAt?: DateTimeFilter<"GoalCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"GoalCompletion"> | Date | string
    customGoal?: XOR<CustomGoalRelationFilter, CustomGoalWhereInput>
  }

  export type GoalCompletionOrderByWithRelationInput = {
    id?: SortOrder
    customGoalId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customGoal?: CustomGoalOrderByWithRelationInput
  }

  export type GoalCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customGoalId_clientId_date?: GoalCompletionCustomGoalIdClientIdDateCompoundUniqueInput
    AND?: GoalCompletionWhereInput | GoalCompletionWhereInput[]
    OR?: GoalCompletionWhereInput[]
    NOT?: GoalCompletionWhereInput | GoalCompletionWhereInput[]
    customGoalId?: StringFilter<"GoalCompletion"> | string
    clientId?: StringFilter<"GoalCompletion"> | string
    date?: DateTimeFilter<"GoalCompletion"> | Date | string
    completed?: BoolFilter<"GoalCompletion"> | boolean
    createdAt?: DateTimeFilter<"GoalCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"GoalCompletion"> | Date | string
    customGoal?: XOR<CustomGoalRelationFilter, CustomGoalWhereInput>
  }, "id" | "customGoalId_clientId_date">

  export type GoalCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    customGoalId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoalCompletionCountOrderByAggregateInput
    _max?: GoalCompletionMaxOrderByAggregateInput
    _min?: GoalCompletionMinOrderByAggregateInput
  }

  export type GoalCompletionScalarWhereWithAggregatesInput = {
    AND?: GoalCompletionScalarWhereWithAggregatesInput | GoalCompletionScalarWhereWithAggregatesInput[]
    OR?: GoalCompletionScalarWhereWithAggregatesInput[]
    NOT?: GoalCompletionScalarWhereWithAggregatesInput | GoalCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GoalCompletion"> | string
    customGoalId?: StringWithAggregatesFilter<"GoalCompletion"> | string
    clientId?: StringWithAggregatesFilter<"GoalCompletion"> | string
    date?: DateTimeWithAggregatesFilter<"GoalCompletion"> | Date | string
    completed?: BoolWithAggregatesFilter<"GoalCompletion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GoalCompletion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoalCompletion"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    programId?: StringFilter<"Session"> | string
    date?: DateTimeFilter<"Session"> | Date | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    isRestDay?: BoolFilter<"Session"> | boolean
    notes?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    exercises?: ExerciseListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isRestDay?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
    exercises?: ExerciseOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    programId_date?: SessionProgramIdDateCompoundUniqueInput
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    programId?: StringFilter<"Session"> | string
    date?: DateTimeFilter<"Session"> | Date | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    isRestDay?: BoolFilter<"Session"> | boolean
    notes?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    exercises?: ExerciseListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "programId_date">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isRestDay?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    programId?: StringWithAggregatesFilter<"Session"> | string
    date?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    status?: EnumSessionStatusWithAggregatesFilter<"Session"> | $Enums.SessionStatus
    isRestDay?: BoolWithAggregatesFilter<"Session"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    sessionId?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    category?: EnumExerciseCategoryFilter<"Exercise"> | $Enums.ExerciseCategory
    sets?: IntNullableFilter<"Exercise"> | number | null
    reps?: StringNullableFilter<"Exercise"> | string | null
    weight?: StringNullableFilter<"Exercise"> | string | null
    restTime?: StringNullableFilter<"Exercise"> | string | null
    videoUrl?: StringNullableFilter<"Exercise"> | string | null
    gifUrl?: StringNullableFilter<"Exercise"> | string | null
    description?: StringNullableFilter<"Exercise"> | string | null
    order?: IntFilter<"Exercise"> | number
    duration?: StringNullableFilter<"Exercise"> | string | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    setCompletions?: SetCompletionListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    sets?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    restTime?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    gifUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    setCompletions?: SetCompletionOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    sessionId?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    category?: EnumExerciseCategoryFilter<"Exercise"> | $Enums.ExerciseCategory
    sets?: IntNullableFilter<"Exercise"> | number | null
    reps?: StringNullableFilter<"Exercise"> | string | null
    weight?: StringNullableFilter<"Exercise"> | string | null
    restTime?: StringNullableFilter<"Exercise"> | string | null
    videoUrl?: StringNullableFilter<"Exercise"> | string | null
    gifUrl?: StringNullableFilter<"Exercise"> | string | null
    description?: StringNullableFilter<"Exercise"> | string | null
    order?: IntFilter<"Exercise"> | number
    duration?: StringNullableFilter<"Exercise"> | string | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    session?: XOR<SessionRelationFilter, SessionWhereInput>
    setCompletions?: SetCompletionListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    sets?: SortOrderInput | SortOrder
    reps?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    restTime?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    gifUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    duration?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    sessionId?: StringWithAggregatesFilter<"Exercise"> | string
    name?: StringWithAggregatesFilter<"Exercise"> | string
    category?: EnumExerciseCategoryWithAggregatesFilter<"Exercise"> | $Enums.ExerciseCategory
    sets?: IntNullableWithAggregatesFilter<"Exercise"> | number | null
    reps?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    weight?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    restTime?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    gifUrl?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    order?: IntWithAggregatesFilter<"Exercise"> | number
    duration?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
  }

  export type SetCompletionWhereInput = {
    AND?: SetCompletionWhereInput | SetCompletionWhereInput[]
    OR?: SetCompletionWhereInput[]
    NOT?: SetCompletionWhereInput | SetCompletionWhereInput[]
    id?: StringFilter<"SetCompletion"> | string
    exerciseId?: StringFilter<"SetCompletion"> | string
    setNumber?: IntFilter<"SetCompletion"> | number
    repsAchieved?: StringNullableFilter<"SetCompletion"> | string | null
    weightUsed?: StringNullableFilter<"SetCompletion"> | string | null
    completed?: BoolFilter<"SetCompletion"> | boolean
    createdAt?: DateTimeFilter<"SetCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"SetCompletion"> | Date | string
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type SetCompletionOrderByWithRelationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    setNumber?: SortOrder
    repsAchieved?: SortOrderInput | SortOrder
    weightUsed?: SortOrderInput | SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type SetCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    exerciseId_setNumber?: SetCompletionExerciseIdSetNumberCompoundUniqueInput
    AND?: SetCompletionWhereInput | SetCompletionWhereInput[]
    OR?: SetCompletionWhereInput[]
    NOT?: SetCompletionWhereInput | SetCompletionWhereInput[]
    exerciseId?: StringFilter<"SetCompletion"> | string
    setNumber?: IntFilter<"SetCompletion"> | number
    repsAchieved?: StringNullableFilter<"SetCompletion"> | string | null
    weightUsed?: StringNullableFilter<"SetCompletion"> | string | null
    completed?: BoolFilter<"SetCompletion"> | boolean
    createdAt?: DateTimeFilter<"SetCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"SetCompletion"> | Date | string
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }, "id" | "exerciseId_setNumber">

  export type SetCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    setNumber?: SortOrder
    repsAchieved?: SortOrderInput | SortOrder
    weightUsed?: SortOrderInput | SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SetCompletionCountOrderByAggregateInput
    _avg?: SetCompletionAvgOrderByAggregateInput
    _max?: SetCompletionMaxOrderByAggregateInput
    _min?: SetCompletionMinOrderByAggregateInput
    _sum?: SetCompletionSumOrderByAggregateInput
  }

  export type SetCompletionScalarWhereWithAggregatesInput = {
    AND?: SetCompletionScalarWhereWithAggregatesInput | SetCompletionScalarWhereWithAggregatesInput[]
    OR?: SetCompletionScalarWhereWithAggregatesInput[]
    NOT?: SetCompletionScalarWhereWithAggregatesInput | SetCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SetCompletion"> | string
    exerciseId?: StringWithAggregatesFilter<"SetCompletion"> | string
    setNumber?: IntWithAggregatesFilter<"SetCompletion"> | number
    repsAchieved?: StringNullableWithAggregatesFilter<"SetCompletion"> | string | null
    weightUsed?: StringNullableWithAggregatesFilter<"SetCompletion"> | string | null
    completed?: BoolWithAggregatesFilter<"SetCompletion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SetCompletion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SetCompletion"> | Date | string
  }

  export type MealPlanWhereInput = {
    AND?: MealPlanWhereInput | MealPlanWhereInput[]
    OR?: MealPlanWhereInput[]
    NOT?: MealPlanWhereInput | MealPlanWhereInput[]
    id?: StringFilter<"MealPlan"> | string
    programId?: StringFilter<"MealPlan"> | string
    title?: StringFilter<"MealPlan"> | string
    description?: StringNullableFilter<"MealPlan"> | string | null
    dailyCalories?: IntNullableFilter<"MealPlan"> | number | null
    createdAt?: DateTimeFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MealPlan"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    menuItems?: MenuItemListRelationFilter
  }

  export type MealPlanOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dailyCalories?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
    menuItems?: MenuItemOrderByRelationAggregateInput
  }

  export type MealPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MealPlanWhereInput | MealPlanWhereInput[]
    OR?: MealPlanWhereInput[]
    NOT?: MealPlanWhereInput | MealPlanWhereInput[]
    programId?: StringFilter<"MealPlan"> | string
    title?: StringFilter<"MealPlan"> | string
    description?: StringNullableFilter<"MealPlan"> | string | null
    dailyCalories?: IntNullableFilter<"MealPlan"> | number | null
    createdAt?: DateTimeFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MealPlan"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    menuItems?: MenuItemListRelationFilter
  }, "id">

  export type MealPlanOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    dailyCalories?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MealPlanCountOrderByAggregateInput
    _avg?: MealPlanAvgOrderByAggregateInput
    _max?: MealPlanMaxOrderByAggregateInput
    _min?: MealPlanMinOrderByAggregateInput
    _sum?: MealPlanSumOrderByAggregateInput
  }

  export type MealPlanScalarWhereWithAggregatesInput = {
    AND?: MealPlanScalarWhereWithAggregatesInput | MealPlanScalarWhereWithAggregatesInput[]
    OR?: MealPlanScalarWhereWithAggregatesInput[]
    NOT?: MealPlanScalarWhereWithAggregatesInput | MealPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MealPlan"> | string
    programId?: StringWithAggregatesFilter<"MealPlan"> | string
    title?: StringWithAggregatesFilter<"MealPlan"> | string
    description?: StringNullableWithAggregatesFilter<"MealPlan"> | string | null
    dailyCalories?: IntNullableWithAggregatesFilter<"MealPlan"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MealPlan"> | Date | string
  }

  export type MenuItemWhereInput = {
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    mealPlanId?: StringFilter<"MenuItem"> | string
    mealType?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    calories?: IntNullableFilter<"MenuItem"> | number | null
    protein?: FloatNullableFilter<"MenuItem"> | number | null
    carbs?: FloatNullableFilter<"MenuItem"> | number | null
    fats?: FloatNullableFilter<"MenuItem"> | number | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    mealPlan?: XOR<MealPlanRelationFilter, MealPlanWhereInput>
  }

  export type MenuItemOrderByWithRelationInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    mealType?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mealPlan?: MealPlanOrderByWithRelationInput
  }

  export type MenuItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    mealPlanId?: StringFilter<"MenuItem"> | string
    mealType?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    calories?: IntNullableFilter<"MenuItem"> | number | null
    protein?: FloatNullableFilter<"MenuItem"> | number | null
    carbs?: FloatNullableFilter<"MenuItem"> | number | null
    fats?: FloatNullableFilter<"MenuItem"> | number | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    mealPlan?: XOR<MealPlanRelationFilter, MealPlanWhereInput>
  }, "id">

  export type MenuItemOrderByWithAggregationInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    mealType?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuItemCountOrderByAggregateInput
    _avg?: MenuItemAvgOrderByAggregateInput
    _max?: MenuItemMaxOrderByAggregateInput
    _min?: MenuItemMinOrderByAggregateInput
    _sum?: MenuItemSumOrderByAggregateInput
  }

  export type MenuItemScalarWhereWithAggregatesInput = {
    AND?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    OR?: MenuItemScalarWhereWithAggregatesInput[]
    NOT?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MenuItem"> | string
    mealPlanId?: StringWithAggregatesFilter<"MenuItem"> | string
    mealType?: StringWithAggregatesFilter<"MenuItem"> | string
    name?: StringWithAggregatesFilter<"MenuItem"> | string
    description?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    calories?: IntNullableWithAggregatesFilter<"MenuItem"> | number | null
    protein?: FloatNullableWithAggregatesFilter<"MenuItem"> | number | null
    carbs?: FloatNullableWithAggregatesFilter<"MenuItem"> | number | null
    fats?: FloatNullableWithAggregatesFilter<"MenuItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
  }

  export type MealWhereInput = {
    AND?: MealWhereInput | MealWhereInput[]
    OR?: MealWhereInput[]
    NOT?: MealWhereInput | MealWhereInput[]
    id?: StringFilter<"Meal"> | string
    clientId?: StringFilter<"Meal"> | string
    date?: DateTimeFilter<"Meal"> | Date | string
    mealType?: StringFilter<"Meal"> | string
    description?: StringFilter<"Meal"> | string
    photoUrl?: StringNullableFilter<"Meal"> | string | null
    calories?: IntFilter<"Meal"> | number
    protein?: FloatNullableFilter<"Meal"> | number | null
    carbs?: FloatNullableFilter<"Meal"> | number | null
    fats?: FloatNullableFilter<"Meal"> | number | null
    createdAt?: DateTimeFilter<"Meal"> | Date | string
    updatedAt?: DateTimeFilter<"Meal"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }

  export type MealOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    mealType?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    calories?: SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
  }

  export type MealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MealWhereInput | MealWhereInput[]
    OR?: MealWhereInput[]
    NOT?: MealWhereInput | MealWhereInput[]
    clientId?: StringFilter<"Meal"> | string
    date?: DateTimeFilter<"Meal"> | Date | string
    mealType?: StringFilter<"Meal"> | string
    description?: StringFilter<"Meal"> | string
    photoUrl?: StringNullableFilter<"Meal"> | string | null
    calories?: IntFilter<"Meal"> | number
    protein?: FloatNullableFilter<"Meal"> | number | null
    carbs?: FloatNullableFilter<"Meal"> | number | null
    fats?: FloatNullableFilter<"Meal"> | number | null
    createdAt?: DateTimeFilter<"Meal"> | Date | string
    updatedAt?: DateTimeFilter<"Meal"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }, "id">

  export type MealOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    mealType?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    calories?: SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fats?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MealCountOrderByAggregateInput
    _avg?: MealAvgOrderByAggregateInput
    _max?: MealMaxOrderByAggregateInput
    _min?: MealMinOrderByAggregateInput
    _sum?: MealSumOrderByAggregateInput
  }

  export type MealScalarWhereWithAggregatesInput = {
    AND?: MealScalarWhereWithAggregatesInput | MealScalarWhereWithAggregatesInput[]
    OR?: MealScalarWhereWithAggregatesInput[]
    NOT?: MealScalarWhereWithAggregatesInput | MealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meal"> | string
    clientId?: StringWithAggregatesFilter<"Meal"> | string
    date?: DateTimeWithAggregatesFilter<"Meal"> | Date | string
    mealType?: StringWithAggregatesFilter<"Meal"> | string
    description?: StringWithAggregatesFilter<"Meal"> | string
    photoUrl?: StringNullableWithAggregatesFilter<"Meal"> | string | null
    calories?: IntWithAggregatesFilter<"Meal"> | number
    protein?: FloatNullableWithAggregatesFilter<"Meal"> | number | null
    carbs?: FloatNullableWithAggregatesFilter<"Meal"> | number | null
    fats?: FloatNullableWithAggregatesFilter<"Meal"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Meal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meal"> | Date | string
  }

  export type DailyStatWhereInput = {
    AND?: DailyStatWhereInput | DailyStatWhereInput[]
    OR?: DailyStatWhereInput[]
    NOT?: DailyStatWhereInput | DailyStatWhereInput[]
    id?: StringFilter<"DailyStat"> | string
    clientId?: StringFilter<"DailyStat"> | string
    date?: DateTimeFilter<"DailyStat"> | Date | string
    sleepHours?: FloatNullableFilter<"DailyStat"> | number | null
    bedTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    wakeTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    waterIntake?: FloatNullableFilter<"DailyStat"> | number | null
    weight?: FloatNullableFilter<"DailyStat"> | number | null
    totalCalories?: IntNullableFilter<"DailyStat"> | number | null
    workoutTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    workoutDuration?: IntNullableFilter<"DailyStat"> | number | null
    notes?: StringNullableFilter<"DailyStat"> | string | null
    createdAt?: DateTimeFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStat"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }

  export type DailyStatOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    bedTime?: SortOrderInput | SortOrder
    wakeTime?: SortOrderInput | SortOrder
    waterIntake?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    totalCalories?: SortOrderInput | SortOrder
    workoutTime?: SortOrderInput | SortOrder
    workoutDuration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientProfileOrderByWithRelationInput
  }

  export type DailyStatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    clientId_date?: DailyStatClientIdDateCompoundUniqueInput
    AND?: DailyStatWhereInput | DailyStatWhereInput[]
    OR?: DailyStatWhereInput[]
    NOT?: DailyStatWhereInput | DailyStatWhereInput[]
    clientId?: StringFilter<"DailyStat"> | string
    sleepHours?: FloatNullableFilter<"DailyStat"> | number | null
    bedTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    wakeTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    waterIntake?: FloatNullableFilter<"DailyStat"> | number | null
    weight?: FloatNullableFilter<"DailyStat"> | number | null
    totalCalories?: IntNullableFilter<"DailyStat"> | number | null
    workoutTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    workoutDuration?: IntNullableFilter<"DailyStat"> | number | null
    notes?: StringNullableFilter<"DailyStat"> | string | null
    createdAt?: DateTimeFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStat"> | Date | string
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }, "id" | "date" | "clientId_date">

  export type DailyStatOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    sleepHours?: SortOrderInput | SortOrder
    bedTime?: SortOrderInput | SortOrder
    wakeTime?: SortOrderInput | SortOrder
    waterIntake?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    totalCalories?: SortOrderInput | SortOrder
    workoutTime?: SortOrderInput | SortOrder
    workoutDuration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyStatCountOrderByAggregateInput
    _avg?: DailyStatAvgOrderByAggregateInput
    _max?: DailyStatMaxOrderByAggregateInput
    _min?: DailyStatMinOrderByAggregateInput
    _sum?: DailyStatSumOrderByAggregateInput
  }

  export type DailyStatScalarWhereWithAggregatesInput = {
    AND?: DailyStatScalarWhereWithAggregatesInput | DailyStatScalarWhereWithAggregatesInput[]
    OR?: DailyStatScalarWhereWithAggregatesInput[]
    NOT?: DailyStatScalarWhereWithAggregatesInput | DailyStatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyStat"> | string
    clientId?: StringWithAggregatesFilter<"DailyStat"> | string
    date?: DateTimeWithAggregatesFilter<"DailyStat"> | Date | string
    sleepHours?: FloatNullableWithAggregatesFilter<"DailyStat"> | number | null
    bedTime?: DateTimeNullableWithAggregatesFilter<"DailyStat"> | Date | string | null
    wakeTime?: DateTimeNullableWithAggregatesFilter<"DailyStat"> | Date | string | null
    waterIntake?: FloatNullableWithAggregatesFilter<"DailyStat"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"DailyStat"> | number | null
    totalCalories?: IntNullableWithAggregatesFilter<"DailyStat"> | number | null
    workoutTime?: DateTimeNullableWithAggregatesFilter<"DailyStat"> | Date | string | null
    workoutDuration?: IntNullableWithAggregatesFilter<"DailyStat"> | number | null
    notes?: StringNullableWithAggregatesFilter<"DailyStat"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyStat"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    sessionId?: StringNullableFilter<"Comment"> | string | null
    clientId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    date?: DateTimeFilter<"Comment"> | Date | string
    isPastComment?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isPastComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    sessionId?: StringNullableFilter<"Comment"> | string | null
    clientId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    date?: DateTimeFilter<"Comment"> | Date | string
    isPastComment?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isPastComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    sessionId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    clientId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    date?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    isPastComment?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    coachId?: StringFilter<"Message"> | string
    clientId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    scheduledTime?: DateTimeNullableFilter<"Message"> | Date | string | null
    isRead?: BoolFilter<"Message"> | boolean
    isSentByCoach?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isSentByCoach?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
    client?: ClientProfileOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    coachId?: StringFilter<"Message"> | string
    clientId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    scheduledTime?: DateTimeNullableFilter<"Message"> | Date | string | null
    isRead?: BoolFilter<"Message"> | boolean
    isSentByCoach?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isSentByCoach?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    coachId?: StringWithAggregatesFilter<"Message"> | string
    clientId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    scheduledTime?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    isSentByCoach?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    coachId?: StringFilter<"Channel"> | string
    title?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    content?: StringFilter<"Channel"> | string
    isPublished?: BoolFilter<"Channel"> | boolean
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    coachId?: StringFilter<"Channel"> | string
    title?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    content?: StringFilter<"Channel"> | string
    isPublished?: BoolFilter<"Channel"> | boolean
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    coachId?: StringWithAggregatesFilter<"Channel"> | string
    title?: StringWithAggregatesFilter<"Channel"> | string
    description?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    content?: StringWithAggregatesFilter<"Channel"> | string
    isPublished?: BoolWithAggregatesFilter<"Channel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    coachId?: StringFilter<"Review"> | string
    clientId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
    client?: ClientProfileOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    coachId_clientId?: ReviewCoachIdClientIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    coachId?: StringFilter<"Review"> | string
    clientId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }, "id" | "coachId_clientId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    coachId?: StringWithAggregatesFilter<"Review"> | string
    clientId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type CoachRequestWhereInput = {
    AND?: CoachRequestWhereInput | CoachRequestWhereInput[]
    OR?: CoachRequestWhereInput[]
    NOT?: CoachRequestWhereInput | CoachRequestWhereInput[]
    id?: StringFilter<"CoachRequest"> | string
    coachId?: StringFilter<"CoachRequest"> | string
    clientId?: StringFilter<"CoachRequest"> | string
    message?: StringFilter<"CoachRequest"> | string
    status?: StringFilter<"CoachRequest"> | string
    createdAt?: DateTimeFilter<"CoachRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CoachRequest"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }

  export type CoachRequestOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
    client?: ClientProfileOrderByWithRelationInput
  }

  export type CoachRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    coachId_clientId?: CoachRequestCoachIdClientIdCompoundUniqueInput
    AND?: CoachRequestWhereInput | CoachRequestWhereInput[]
    OR?: CoachRequestWhereInput[]
    NOT?: CoachRequestWhereInput | CoachRequestWhereInput[]
    coachId?: StringFilter<"CoachRequest"> | string
    clientId?: StringFilter<"CoachRequest"> | string
    message?: StringFilter<"CoachRequest"> | string
    status?: StringFilter<"CoachRequest"> | string
    createdAt?: DateTimeFilter<"CoachRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CoachRequest"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
    client?: XOR<ClientProfileRelationFilter, ClientProfileWhereInput>
  }, "id" | "coachId_clientId">

  export type CoachRequestOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachRequestCountOrderByAggregateInput
    _max?: CoachRequestMaxOrderByAggregateInput
    _min?: CoachRequestMinOrderByAggregateInput
  }

  export type CoachRequestScalarWhereWithAggregatesInput = {
    AND?: CoachRequestScalarWhereWithAggregatesInput | CoachRequestScalarWhereWithAggregatesInput[]
    OR?: CoachRequestScalarWhereWithAggregatesInput[]
    NOT?: CoachRequestScalarWhereWithAggregatesInput | CoachRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachRequest"> | string
    coachId?: StringWithAggregatesFilter<"CoachRequest"> | string
    clientId?: StringWithAggregatesFilter<"CoachRequest"> | string
    message?: StringWithAggregatesFilter<"CoachRequest"> | string
    status?: StringWithAggregatesFilter<"CoachRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CoachRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachRequest"> | Date | string
  }

  export type CoachPostWhereInput = {
    AND?: CoachPostWhereInput | CoachPostWhereInput[]
    OR?: CoachPostWhereInput[]
    NOT?: CoachPostWhereInput | CoachPostWhereInput[]
    id?: StringFilter<"CoachPost"> | string
    coachId?: StringFilter<"CoachPost"> | string
    content?: StringFilter<"CoachPost"> | string
    mediaType?: StringNullableFilter<"CoachPost"> | string | null
    mediaUrl?: StringNullableFilter<"CoachPost"> | string | null
    isPublic?: BoolFilter<"CoachPost"> | boolean
    createdAt?: DateTimeFilter<"CoachPost"> | Date | string
    updatedAt?: DateTimeFilter<"CoachPost"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }

  export type CoachPostOrderByWithRelationInput = {
    id?: SortOrder
    coachId?: SortOrder
    content?: SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coach?: CoachProfileOrderByWithRelationInput
  }

  export type CoachPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoachPostWhereInput | CoachPostWhereInput[]
    OR?: CoachPostWhereInput[]
    NOT?: CoachPostWhereInput | CoachPostWhereInput[]
    coachId?: StringFilter<"CoachPost"> | string
    content?: StringFilter<"CoachPost"> | string
    mediaType?: StringNullableFilter<"CoachPost"> | string | null
    mediaUrl?: StringNullableFilter<"CoachPost"> | string | null
    isPublic?: BoolFilter<"CoachPost"> | boolean
    createdAt?: DateTimeFilter<"CoachPost"> | Date | string
    updatedAt?: DateTimeFilter<"CoachPost"> | Date | string
    coach?: XOR<CoachProfileRelationFilter, CoachProfileWhereInput>
  }, "id">

  export type CoachPostOrderByWithAggregationInput = {
    id?: SortOrder
    coachId?: SortOrder
    content?: SortOrder
    mediaType?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachPostCountOrderByAggregateInput
    _max?: CoachPostMaxOrderByAggregateInput
    _min?: CoachPostMinOrderByAggregateInput
  }

  export type CoachPostScalarWhereWithAggregatesInput = {
    AND?: CoachPostScalarWhereWithAggregatesInput | CoachPostScalarWhereWithAggregatesInput[]
    OR?: CoachPostScalarWhereWithAggregatesInput[]
    NOT?: CoachPostScalarWhereWithAggregatesInput | CoachPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoachPost"> | string
    coachId?: StringWithAggregatesFilter<"CoachPost"> | string
    content?: StringWithAggregatesFilter<"CoachPost"> | string
    mediaType?: StringNullableWithAggregatesFilter<"CoachPost"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"CoachPost"> | string | null
    isPublic?: BoolWithAggregatesFilter<"CoachPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CoachPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachPost"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coachProfile?: CoachProfileCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coachProfile?: CoachProfileUncheckedCreateNestedOneWithoutUserInput
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachProfile?: CoachProfileUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachProfile?: CoachProfileUncheckedUpdateOneWithoutUserNestedInput
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachProfileCreateInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileCreateManyInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileCreateManyInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachCreateInput = {
    id?: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutCoachesInput
    coach: CoachProfileCreateNestedOneWithoutClientCoachesInput
  }

  export type ClientCoachUncheckedCreateInput = {
    id?: string
    clientId: string
    coachId: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCoachUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutCoachesNestedInput
    coach?: CoachProfileUpdateOneRequiredWithoutClientCoachesNestedInput
  }

  export type ClientCoachUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachCreateManyInput = {
    id?: string
    clientId: string
    coachId: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCoachUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutProgramsInput
    sessions?: SessionCreateNestedManyWithoutProgramInput
    mealPlans?: MealPlanCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    coachId: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutProgramsNestedInput
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    mealPlans?: MealPlanUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    coachId: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    cycleDays?: number | null
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutProgramTemplatesInput
  }

  export type ProgramTemplateUncheckedCreateInput = {
    id?: string
    coachId: string
    name: string
    description?: string | null
    cycleDays?: number | null
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutProgramTemplatesNestedInput
  }

  export type ProgramTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramTemplateCreateManyInput = {
    id?: string
    coachId: string
    name: string
    description?: string | null
    cycleDays?: number | null
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomGoalCreateInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutCustomGoalsInput
    completions?: GoalCompletionCreateNestedManyWithoutCustomGoalInput
  }

  export type CustomGoalUncheckedCreateInput = {
    id?: string
    programId: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: GoalCompletionUncheckedCreateNestedManyWithoutCustomGoalInput
  }

  export type CustomGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutCustomGoalsNestedInput
    completions?: GoalCompletionUpdateManyWithoutCustomGoalNestedInput
  }

  export type CustomGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: GoalCompletionUncheckedUpdateManyWithoutCustomGoalNestedInput
  }

  export type CustomGoalCreateManyInput = {
    id?: string
    programId: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCompletionCreateInput = {
    id?: string
    clientId: string
    date: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customGoal: CustomGoalCreateNestedOneWithoutCompletionsInput
  }

  export type GoalCompletionUncheckedCreateInput = {
    id?: string
    customGoalId: string
    clientId: string
    date: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customGoal?: CustomGoalUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type GoalCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customGoalId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCompletionCreateManyInput = {
    id?: string
    customGoalId: string
    clientId: string
    date: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customGoalId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutSessionsInput
    exercises?: ExerciseCreateNestedManyWithoutSessionInput
    comments?: CommentCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    programId: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutSessionInput
    comments?: CommentUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutSessionsNestedInput
    exercises?: ExerciseUpdateManyWithoutSessionNestedInput
    comments?: CommentUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutSessionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    programId: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    id?: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutExercisesInput
    setCompletions?: SetCompletionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    sessionId: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    setCompletions?: SetCompletionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutExercisesNestedInput
    setCompletions?: SetCompletionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setCompletions?: SetCompletionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: string
    sessionId: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SetCompletionCreateInput = {
    id?: string
    setNumber: number
    repsAchieved?: string | null
    weightUsed?: string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutSetCompletionsInput
  }

  export type SetCompletionUncheckedCreateInput = {
    id?: string
    exerciseId: string
    setNumber: number
    repsAchieved?: string | null
    weightUsed?: string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SetCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutSetCompletionsNestedInput
  }

  export type SetCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SetCompletionCreateManyInput = {
    id?: string
    exerciseId: string
    setNumber: number
    repsAchieved?: string | null
    weightUsed?: string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SetCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SetCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealPlanCreateInput = {
    id?: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutMealPlansInput
    menuItems?: MenuItemCreateNestedManyWithoutMealPlanInput
  }

  export type MealPlanUncheckedCreateInput = {
    id?: string
    programId: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutMealPlanInput
  }

  export type MealPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutMealPlansNestedInput
    menuItems?: MenuItemUpdateManyWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutMealPlanNestedInput
  }

  export type MealPlanCreateManyInput = {
    id?: string
    programId: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateInput = {
    id?: string
    mealType: string
    name: string
    description?: string | null
    calories?: number | null
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mealPlan: MealPlanCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateInput = {
    id?: string
    mealPlanId: string
    mealType: string
    name: string
    description?: string | null
    calories?: number | null
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mealPlan?: MealPlanUpdateOneRequiredWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyInput = {
    id?: string
    mealPlanId: string
    mealType: string
    name: string
    description?: string | null
    calories?: number | null
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealCreateInput = {
    id?: string
    date: Date | string
    mealType: string
    description: string
    photoUrl?: string | null
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutMealsInput
  }

  export type MealUncheckedCreateInput = {
    id?: string
    clientId: string
    date: Date | string
    mealType: string
    description: string
    photoUrl?: string | null
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutMealsNestedInput
  }

  export type MealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealCreateManyInput = {
    id?: string
    clientId: string
    date: Date | string
    mealType: string
    description: string
    photoUrl?: string | null
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatCreateInput = {
    id?: string
    date: Date | string
    sleepHours?: number | null
    bedTime?: Date | string | null
    wakeTime?: Date | string | null
    waterIntake?: number | null
    weight?: number | null
    totalCalories?: number | null
    workoutTime?: Date | string | null
    workoutDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutStatsInput
  }

  export type DailyStatUncheckedCreateInput = {
    id?: string
    clientId: string
    date: Date | string
    sleepHours?: number | null
    bedTime?: Date | string | null
    wakeTime?: Date | string | null
    waterIntake?: number | null
    weight?: number | null
    totalCalories?: number | null
    workoutTime?: Date | string | null
    workoutDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutStatsNestedInput
  }

  export type DailyStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatCreateManyInput = {
    id?: string
    clientId: string
    date: Date | string
    sleepHours?: number | null
    bedTime?: Date | string | null
    wakeTime?: Date | string | null
    waterIntake?: number | null
    weight?: number | null
    totalCalories?: number | null
    workoutTime?: Date | string | null
    workoutDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    clientId: string
    content: string
    date: Date | string
    isPastComment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session?: SessionCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    clientId: string
    content: string
    date: Date | string
    isPastComment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    sessionId?: string | null
    clientId: string
    content: string
    date: Date | string
    isPastComment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutSentMessagesInput
    client: ClientProfileCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    coachId: string
    clientId: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutSentMessagesNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    coachId: string
    clientId: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    coachId: string
    title: string
    description?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateManyInput = {
    id?: string
    coachId: string
    title: string
    description?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutReviewsInput
    client: ClientProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    coachId: string
    clientId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutReviewsNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    coachId: string
    clientId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestCreateInput = {
    id?: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutCoachRequestsInput
    client: ClientProfileCreateNestedOneWithoutCoachRequestsInput
  }

  export type CoachRequestUncheckedCreateInput = {
    id?: string
    coachId: string
    clientId: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutCoachRequestsNestedInput
    client?: ClientProfileUpdateOneRequiredWithoutCoachRequestsNestedInput
  }

  export type CoachRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestCreateManyInput = {
    id?: string
    coachId: string
    clientId: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachPostCreateInput = {
    id?: string
    content: string
    mediaType?: string | null
    mediaUrl?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutPostsInput
  }

  export type CoachPostUncheckedCreateInput = {
    id?: string
    coachId: string
    content: string
    mediaType?: string | null
    mediaUrl?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutPostsNestedInput
  }

  export type CoachPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachPostCreateManyInput = {
    id?: string
    coachId: string
    content: string
    mediaType?: string | null
    mediaUrl?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CoachProfileNullableRelationFilter = {
    is?: CoachProfileWhereInput | null
    isNot?: CoachProfileWhereInput | null
  }

  export type ClientProfileNullableRelationFilter = {
    is?: ClientProfileWhereInput | null
    isNot?: ClientProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClientProfileListRelationFilter = {
    every?: ClientProfileWhereInput
    some?: ClientProfileWhereInput
    none?: ClientProfileWhereInput
  }

  export type ClientCoachListRelationFilter = {
    every?: ClientCoachWhereInput
    some?: ClientCoachWhereInput
    none?: ClientCoachWhereInput
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type ProgramTemplateListRelationFilter = {
    every?: ProgramTemplateWhereInput
    some?: ProgramTemplateWhereInput
    none?: ProgramTemplateWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type CoachPostListRelationFilter = {
    every?: CoachPostWhereInput
    some?: CoachPostWhereInput
    none?: CoachPostWhereInput
  }

  export type CoachRequestListRelationFilter = {
    every?: CoachRequestWhereInput
    some?: CoachRequestWhereInput
    none?: CoachRequestWhereInput
  }

  export type ClientProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCoachOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    experience?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    profilePicture?: SortOrder
    city?: SortOrder
    isRemote?: SortOrder
    trainingLocations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachProfileAvgOrderByAggregateInput = {
    rating?: SortOrder
    ratingCount?: SortOrder
  }

  export type CoachProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    experience?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    profilePicture?: SortOrder
    city?: SortOrder
    isRemote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    experience?: SortOrder
    rating?: SortOrder
    ratingCount?: SortOrder
    profilePicture?: SortOrder
    city?: SortOrder
    isRemote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachProfileSumOrderByAggregateInput = {
    rating?: SortOrder
    ratingCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DailyStatListRelationFilter = {
    every?: DailyStatWhereInput
    some?: DailyStatWhereInput
    none?: DailyStatWhereInput
  }

  export type MealListRelationFilter = {
    every?: MealWhereInput
    some?: MealWhereInput
    none?: MealWhereInput
  }

  export type DailyStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    goals?: SortOrder
    level?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileAvgOrderByAggregateInput = {
    weight?: SortOrder
    height?: SortOrder
  }

  export type ClientProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    goals?: SortOrder
    level?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coachId?: SortOrder
    weight?: SortOrder
    height?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    goals?: SortOrder
    level?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientProfileSumOrderByAggregateInput = {
    weight?: SortOrder
    height?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ClientProfileRelationFilter = {
    is?: ClientProfileWhereInput
    isNot?: ClientProfileWhereInput
  }

  export type CoachProfileRelationFilter = {
    is?: CoachProfileWhereInput
    isNot?: CoachProfileWhereInput
  }

  export type ClientCoachClientIdCoachIdCompoundUniqueInput = {
    clientId: string
    coachId: string
  }

  export type ClientCoachCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    coachId?: SortOrder
    isPrimary?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientCoachMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    coachId?: SortOrder
    isPrimary?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientCoachMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    coachId?: SortOrder
    isPrimary?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type MealPlanListRelationFilter = {
    every?: MealPlanWhereInput
    some?: MealPlanWhereInput
    none?: MealPlanWhereInput
  }

  export type CustomGoalListRelationFilter = {
    every?: CustomGoalWhereInput
    some?: CustomGoalWhereInput
    none?: CustomGoalWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cycleDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrder
    targetCalories?: SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    cycleDays?: SortOrder
    targetCalories?: SortOrder
    waterGoal?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cycleDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrder
    targetCalories?: SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cycleDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrder
    targetCalories?: SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    cycleDays?: SortOrder
    targetCalories?: SortOrder
    waterGoal?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProgramTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cycleDays?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrder
    targetCalories?: SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    sessionsData?: SortOrder
    customGoalsData?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramTemplateAvgOrderByAggregateInput = {
    cycleDays?: SortOrder
    targetCalories?: SortOrder
    waterGoal?: SortOrder
  }

  export type ProgramTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cycleDays?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrder
    targetCalories?: SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cycleDays?: SortOrder
    dietEnabled?: SortOrder
    dietType?: SortOrder
    targetCalories?: SortOrder
    waterTrackingEnabled?: SortOrder
    waterGoal?: SortOrder
    sleepTrackingEnabled?: SortOrder
    weightTrackingEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramTemplateSumOrderByAggregateInput = {
    cycleDays?: SortOrder
    targetCalories?: SortOrder
    waterGoal?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type GoalCompletionListRelationFilter = {
    every?: GoalCompletionWhereInput
    some?: GoalCompletionWhereInput
    none?: GoalCompletionWhereInput
  }

  export type GoalCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomGoalCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomGoalAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomGoalMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomGoalSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CustomGoalRelationFilter = {
    is?: CustomGoalWhereInput
    isNot?: CustomGoalWhereInput
  }

  export type GoalCompletionCustomGoalIdClientIdDateCompoundUniqueInput = {
    customGoalId: string
    clientId: string
    date: Date | string
  }

  export type GoalCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    customGoalId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    customGoalId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoalCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    customGoalId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionProgramIdDateCompoundUniqueInput = {
    programId: string
    date: Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isRestDay?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isRestDay?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    isRestDay?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EnumExerciseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseCategory | EnumExerciseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseCategoryFilter<$PrismaModel> | $Enums.ExerciseCategory
  }

  export type SessionRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type SetCompletionListRelationFilter = {
    every?: SetCompletionWhereInput
    some?: SetCompletionWhereInput
    none?: SetCompletionWhereInput
  }

  export type SetCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    restTime?: SortOrder
    videoUrl?: SortOrder
    gifUrl?: SortOrder
    description?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    sets?: SortOrder
    order?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    restTime?: SortOrder
    videoUrl?: SortOrder
    gifUrl?: SortOrder
    description?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    name?: SortOrder
    category?: SortOrder
    sets?: SortOrder
    reps?: SortOrder
    weight?: SortOrder
    restTime?: SortOrder
    videoUrl?: SortOrder
    gifUrl?: SortOrder
    description?: SortOrder
    order?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    sets?: SortOrder
    order?: SortOrder
  }

  export type EnumExerciseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseCategory | EnumExerciseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExerciseCategoryFilter<$PrismaModel>
  }

  export type ExerciseRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type SetCompletionExerciseIdSetNumberCompoundUniqueInput = {
    exerciseId: string
    setNumber: number
  }

  export type SetCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    setNumber?: SortOrder
    repsAchieved?: SortOrder
    weightUsed?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SetCompletionAvgOrderByAggregateInput = {
    setNumber?: SortOrder
  }

  export type SetCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    setNumber?: SortOrder
    repsAchieved?: SortOrder
    weightUsed?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SetCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    setNumber?: SortOrder
    repsAchieved?: SortOrder
    weightUsed?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SetCompletionSumOrderByAggregateInput = {
    setNumber?: SortOrder
  }

  export type MenuItemListRelationFilter = {
    every?: MenuItemWhereInput
    some?: MenuItemWhereInput
    none?: MenuItemWhereInput
  }

  export type MenuItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealPlanCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dailyCalories?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealPlanAvgOrderByAggregateInput = {
    dailyCalories?: SortOrder
  }

  export type MealPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dailyCalories?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealPlanMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    dailyCalories?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealPlanSumOrderByAggregateInput = {
    dailyCalories?: SortOrder
  }

  export type MealPlanRelationFilter = {
    is?: MealPlanWhereInput
    isNot?: MealPlanWhereInput
  }

  export type MenuItemCountOrderByAggregateInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    mealType?: SortOrder
    name?: SortOrder
    description?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type MenuItemMaxOrderByAggregateInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    mealType?: SortOrder
    name?: SortOrder
    description?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemMinOrderByAggregateInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    mealType?: SortOrder
    name?: SortOrder
    description?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type MealCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    mealType?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type MealMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    mealType?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    mealType?: SortOrder
    description?: SortOrder
    photoUrl?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
  }

  export type DailyStatClientIdDateCompoundUniqueInput = {
    clientId: string
    date: Date | string
  }

  export type DailyStatCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    sleepHours?: SortOrder
    bedTime?: SortOrder
    wakeTime?: SortOrder
    waterIntake?: SortOrder
    weight?: SortOrder
    totalCalories?: SortOrder
    workoutTime?: SortOrder
    workoutDuration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatAvgOrderByAggregateInput = {
    sleepHours?: SortOrder
    waterIntake?: SortOrder
    weight?: SortOrder
    totalCalories?: SortOrder
    workoutDuration?: SortOrder
  }

  export type DailyStatMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    sleepHours?: SortOrder
    bedTime?: SortOrder
    wakeTime?: SortOrder
    waterIntake?: SortOrder
    weight?: SortOrder
    totalCalories?: SortOrder
    workoutTime?: SortOrder
    workoutDuration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    sleepHours?: SortOrder
    bedTime?: SortOrder
    wakeTime?: SortOrder
    waterIntake?: SortOrder
    weight?: SortOrder
    totalCalories?: SortOrder
    workoutTime?: SortOrder
    workoutDuration?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatSumOrderByAggregateInput = {
    sleepHours?: SortOrder
    waterIntake?: SortOrder
    weight?: SortOrder
    totalCalories?: SortOrder
    workoutDuration?: SortOrder
  }

  export type SessionNullableRelationFilter = {
    is?: SessionWhereInput | null
    isNot?: SessionWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isPastComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isPastComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    date?: SortOrder
    isPastComment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledTime?: SortOrder
    isRead?: SortOrder
    isSentByCoach?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledTime?: SortOrder
    isRead?: SortOrder
    isSentByCoach?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    scheduledTime?: SortOrder
    isRead?: SortOrder
    isSentByCoach?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewCoachIdClientIdCompoundUniqueInput = {
    coachId: string
    clientId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type CoachRequestCoachIdClientIdCompoundUniqueInput = {
    coachId: string
    clientId: string
  }

  export type CoachRequestCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachRequestMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    clientId?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachPostCountOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    content?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachPostMaxOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    content?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachPostMinOrderByAggregateInput = {
    id?: SortOrder
    coachId?: SortOrder
    content?: SortOrder
    mediaType?: SortOrder
    mediaUrl?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<CoachProfileCreateWithoutUserInput, CoachProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutUserInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type CoachProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CoachProfileCreateWithoutUserInput, CoachProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutUserInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CoachProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<CoachProfileCreateWithoutUserInput, CoachProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutUserInput
    upsert?: CoachProfileUpsertWithoutUserInput
    disconnect?: CoachProfileWhereInput | boolean
    delete?: CoachProfileWhereInput | boolean
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutUserInput, CoachProfileUpdateWithoutUserInput>, CoachProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type CoachProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CoachProfileCreateWithoutUserInput, CoachProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutUserInput
    upsert?: CoachProfileUpsertWithoutUserInput
    disconnect?: CoachProfileWhereInput | boolean
    delete?: CoachProfileWhereInput | boolean
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutUserInput, CoachProfileUpdateWithoutUserInput>, CoachProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutUserInput
    upsert?: ClientProfileUpsertWithoutUserInput
    disconnect?: ClientProfileWhereInput | boolean
    delete?: ClientProfileWhereInput | boolean
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutUserInput, ClientProfileUpdateWithoutUserInput>, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type CoachProfileCreatetrainingLocationsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCoachProfileInput = {
    create?: XOR<UserCreateWithoutCoachProfileInput, UserUncheckedCreateWithoutCoachProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ClientProfileCreateNestedManyWithoutCoachInput = {
    create?: XOR<ClientProfileCreateWithoutCoachInput, ClientProfileUncheckedCreateWithoutCoachInput> | ClientProfileCreateWithoutCoachInput[] | ClientProfileUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachInput | ClientProfileCreateOrConnectWithoutCoachInput[]
    createMany?: ClientProfileCreateManyCoachInputEnvelope
    connect?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
  }

  export type ClientCoachCreateNestedManyWithoutCoachInput = {
    create?: XOR<ClientCoachCreateWithoutCoachInput, ClientCoachUncheckedCreateWithoutCoachInput> | ClientCoachCreateWithoutCoachInput[] | ClientCoachUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutCoachInput | ClientCoachCreateOrConnectWithoutCoachInput[]
    createMany?: ClientCoachCreateManyCoachInputEnvelope
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutCoachInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ProgramTemplateCreateNestedManyWithoutCoachInput = {
    create?: XOR<ProgramTemplateCreateWithoutCoachInput, ProgramTemplateUncheckedCreateWithoutCoachInput> | ProgramTemplateCreateWithoutCoachInput[] | ProgramTemplateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramTemplateCreateOrConnectWithoutCoachInput | ProgramTemplateCreateOrConnectWithoutCoachInput[]
    createMany?: ProgramTemplateCreateManyCoachInputEnvelope
    connect?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutCoachInput = {
    create?: XOR<MessageCreateWithoutCoachInput, MessageUncheckedCreateWithoutCoachInput> | MessageCreateWithoutCoachInput[] | MessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCoachInput | MessageCreateOrConnectWithoutCoachInput[]
    createMany?: MessageCreateManyCoachInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutCoachInput = {
    create?: XOR<ChannelCreateWithoutCoachInput, ChannelUncheckedCreateWithoutCoachInput> | ChannelCreateWithoutCoachInput[] | ChannelUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutCoachInput | ChannelCreateOrConnectWithoutCoachInput[]
    createMany?: ChannelCreateManyCoachInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutCoachInput = {
    create?: XOR<ReviewCreateWithoutCoachInput, ReviewUncheckedCreateWithoutCoachInput> | ReviewCreateWithoutCoachInput[] | ReviewUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCoachInput | ReviewCreateOrConnectWithoutCoachInput[]
    createMany?: ReviewCreateManyCoachInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CoachPostCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachPostCreateWithoutCoachInput, CoachPostUncheckedCreateWithoutCoachInput> | CoachPostCreateWithoutCoachInput[] | CoachPostUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachPostCreateOrConnectWithoutCoachInput | CoachPostCreateOrConnectWithoutCoachInput[]
    createMany?: CoachPostCreateManyCoachInputEnvelope
    connect?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
  }

  export type CoachRequestCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachRequestCreateWithoutCoachInput, CoachRequestUncheckedCreateWithoutCoachInput> | CoachRequestCreateWithoutCoachInput[] | CoachRequestUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutCoachInput | CoachRequestCreateOrConnectWithoutCoachInput[]
    createMany?: CoachRequestCreateManyCoachInputEnvelope
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
  }

  export type ClientProfileUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ClientProfileCreateWithoutCoachInput, ClientProfileUncheckedCreateWithoutCoachInput> | ClientProfileCreateWithoutCoachInput[] | ClientProfileUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachInput | ClientProfileCreateOrConnectWithoutCoachInput[]
    createMany?: ClientProfileCreateManyCoachInputEnvelope
    connect?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
  }

  export type ClientCoachUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ClientCoachCreateWithoutCoachInput, ClientCoachUncheckedCreateWithoutCoachInput> | ClientCoachCreateWithoutCoachInput[] | ClientCoachUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutCoachInput | ClientCoachCreateOrConnectWithoutCoachInput[]
    createMany?: ClientCoachCreateManyCoachInputEnvelope
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ProgramTemplateCreateWithoutCoachInput, ProgramTemplateUncheckedCreateWithoutCoachInput> | ProgramTemplateCreateWithoutCoachInput[] | ProgramTemplateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramTemplateCreateOrConnectWithoutCoachInput | ProgramTemplateCreateOrConnectWithoutCoachInput[]
    createMany?: ProgramTemplateCreateManyCoachInputEnvelope
    connect?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<MessageCreateWithoutCoachInput, MessageUncheckedCreateWithoutCoachInput> | MessageCreateWithoutCoachInput[] | MessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCoachInput | MessageCreateOrConnectWithoutCoachInput[]
    createMany?: MessageCreateManyCoachInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ChannelCreateWithoutCoachInput, ChannelUncheckedCreateWithoutCoachInput> | ChannelCreateWithoutCoachInput[] | ChannelUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutCoachInput | ChannelCreateOrConnectWithoutCoachInput[]
    createMany?: ChannelCreateManyCoachInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<ReviewCreateWithoutCoachInput, ReviewUncheckedCreateWithoutCoachInput> | ReviewCreateWithoutCoachInput[] | ReviewUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCoachInput | ReviewCreateOrConnectWithoutCoachInput[]
    createMany?: ReviewCreateManyCoachInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CoachPostUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachPostCreateWithoutCoachInput, CoachPostUncheckedCreateWithoutCoachInput> | CoachPostCreateWithoutCoachInput[] | CoachPostUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachPostCreateOrConnectWithoutCoachInput | CoachPostCreateOrConnectWithoutCoachInput[]
    createMany?: CoachPostCreateManyCoachInputEnvelope
    connect?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
  }

  export type CoachRequestUncheckedCreateNestedManyWithoutCoachInput = {
    create?: XOR<CoachRequestCreateWithoutCoachInput, CoachRequestUncheckedCreateWithoutCoachInput> | CoachRequestCreateWithoutCoachInput[] | CoachRequestUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutCoachInput | CoachRequestCreateOrConnectWithoutCoachInput[]
    createMany?: CoachRequestCreateManyCoachInputEnvelope
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CoachProfileUpdatetrainingLocationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCoachProfileNestedInput = {
    create?: XOR<UserCreateWithoutCoachProfileInput, UserUncheckedCreateWithoutCoachProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachProfileInput
    upsert?: UserUpsertWithoutCoachProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoachProfileInput, UserUpdateWithoutCoachProfileInput>, UserUncheckedUpdateWithoutCoachProfileInput>
  }

  export type ClientProfileUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ClientProfileCreateWithoutCoachInput, ClientProfileUncheckedCreateWithoutCoachInput> | ClientProfileCreateWithoutCoachInput[] | ClientProfileUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachInput | ClientProfileCreateOrConnectWithoutCoachInput[]
    upsert?: ClientProfileUpsertWithWhereUniqueWithoutCoachInput | ClientProfileUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ClientProfileCreateManyCoachInputEnvelope
    set?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    disconnect?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    delete?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    connect?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    update?: ClientProfileUpdateWithWhereUniqueWithoutCoachInput | ClientProfileUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ClientProfileUpdateManyWithWhereWithoutCoachInput | ClientProfileUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ClientProfileScalarWhereInput | ClientProfileScalarWhereInput[]
  }

  export type ClientCoachUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ClientCoachCreateWithoutCoachInput, ClientCoachUncheckedCreateWithoutCoachInput> | ClientCoachCreateWithoutCoachInput[] | ClientCoachUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutCoachInput | ClientCoachCreateOrConnectWithoutCoachInput[]
    upsert?: ClientCoachUpsertWithWhereUniqueWithoutCoachInput | ClientCoachUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ClientCoachCreateManyCoachInputEnvelope
    set?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    disconnect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    delete?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    update?: ClientCoachUpdateWithWhereUniqueWithoutCoachInput | ClientCoachUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ClientCoachUpdateManyWithWhereWithoutCoachInput | ClientCoachUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ClientCoachScalarWhereInput | ClientCoachScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutCoachInput | ProgramUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutCoachInput | ProgramUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutCoachInput | ProgramUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ProgramTemplateUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ProgramTemplateCreateWithoutCoachInput, ProgramTemplateUncheckedCreateWithoutCoachInput> | ProgramTemplateCreateWithoutCoachInput[] | ProgramTemplateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramTemplateCreateOrConnectWithoutCoachInput | ProgramTemplateCreateOrConnectWithoutCoachInput[]
    upsert?: ProgramTemplateUpsertWithWhereUniqueWithoutCoachInput | ProgramTemplateUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ProgramTemplateCreateManyCoachInputEnvelope
    set?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    disconnect?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    delete?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    connect?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    update?: ProgramTemplateUpdateWithWhereUniqueWithoutCoachInput | ProgramTemplateUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ProgramTemplateUpdateManyWithWhereWithoutCoachInput | ProgramTemplateUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ProgramTemplateScalarWhereInput | ProgramTemplateScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutCoachNestedInput = {
    create?: XOR<MessageCreateWithoutCoachInput, MessageUncheckedCreateWithoutCoachInput> | MessageCreateWithoutCoachInput[] | MessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCoachInput | MessageCreateOrConnectWithoutCoachInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCoachInput | MessageUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: MessageCreateManyCoachInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCoachInput | MessageUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCoachInput | MessageUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ChannelCreateWithoutCoachInput, ChannelUncheckedCreateWithoutCoachInput> | ChannelCreateWithoutCoachInput[] | ChannelUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutCoachInput | ChannelCreateOrConnectWithoutCoachInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutCoachInput | ChannelUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ChannelCreateManyCoachInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutCoachInput | ChannelUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutCoachInput | ChannelUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ReviewCreateWithoutCoachInput, ReviewUncheckedCreateWithoutCoachInput> | ReviewCreateWithoutCoachInput[] | ReviewUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCoachInput | ReviewCreateOrConnectWithoutCoachInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCoachInput | ReviewUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ReviewCreateManyCoachInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCoachInput | ReviewUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCoachInput | ReviewUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CoachPostUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachPostCreateWithoutCoachInput, CoachPostUncheckedCreateWithoutCoachInput> | CoachPostCreateWithoutCoachInput[] | CoachPostUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachPostCreateOrConnectWithoutCoachInput | CoachPostCreateOrConnectWithoutCoachInput[]
    upsert?: CoachPostUpsertWithWhereUniqueWithoutCoachInput | CoachPostUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachPostCreateManyCoachInputEnvelope
    set?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    disconnect?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    delete?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    connect?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    update?: CoachPostUpdateWithWhereUniqueWithoutCoachInput | CoachPostUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachPostUpdateManyWithWhereWithoutCoachInput | CoachPostUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachPostScalarWhereInput | CoachPostScalarWhereInput[]
  }

  export type CoachRequestUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachRequestCreateWithoutCoachInput, CoachRequestUncheckedCreateWithoutCoachInput> | CoachRequestCreateWithoutCoachInput[] | CoachRequestUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutCoachInput | CoachRequestCreateOrConnectWithoutCoachInput[]
    upsert?: CoachRequestUpsertWithWhereUniqueWithoutCoachInput | CoachRequestUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachRequestCreateManyCoachInputEnvelope
    set?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    disconnect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    delete?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    update?: CoachRequestUpdateWithWhereUniqueWithoutCoachInput | CoachRequestUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachRequestUpdateManyWithWhereWithoutCoachInput | CoachRequestUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
  }

  export type ClientProfileUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ClientProfileCreateWithoutCoachInput, ClientProfileUncheckedCreateWithoutCoachInput> | ClientProfileCreateWithoutCoachInput[] | ClientProfileUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachInput | ClientProfileCreateOrConnectWithoutCoachInput[]
    upsert?: ClientProfileUpsertWithWhereUniqueWithoutCoachInput | ClientProfileUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ClientProfileCreateManyCoachInputEnvelope
    set?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    disconnect?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    delete?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    connect?: ClientProfileWhereUniqueInput | ClientProfileWhereUniqueInput[]
    update?: ClientProfileUpdateWithWhereUniqueWithoutCoachInput | ClientProfileUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ClientProfileUpdateManyWithWhereWithoutCoachInput | ClientProfileUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ClientProfileScalarWhereInput | ClientProfileScalarWhereInput[]
  }

  export type ClientCoachUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ClientCoachCreateWithoutCoachInput, ClientCoachUncheckedCreateWithoutCoachInput> | ClientCoachCreateWithoutCoachInput[] | ClientCoachUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutCoachInput | ClientCoachCreateOrConnectWithoutCoachInput[]
    upsert?: ClientCoachUpsertWithWhereUniqueWithoutCoachInput | ClientCoachUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ClientCoachCreateManyCoachInputEnvelope
    set?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    disconnect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    delete?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    update?: ClientCoachUpdateWithWhereUniqueWithoutCoachInput | ClientCoachUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ClientCoachUpdateManyWithWhereWithoutCoachInput | ClientCoachUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ClientCoachScalarWhereInput | ClientCoachScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput> | ProgramCreateWithoutCoachInput[] | ProgramUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutCoachInput | ProgramCreateOrConnectWithoutCoachInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutCoachInput | ProgramUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ProgramCreateManyCoachInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutCoachInput | ProgramUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutCoachInput | ProgramUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ProgramTemplateCreateWithoutCoachInput, ProgramTemplateUncheckedCreateWithoutCoachInput> | ProgramTemplateCreateWithoutCoachInput[] | ProgramTemplateUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ProgramTemplateCreateOrConnectWithoutCoachInput | ProgramTemplateCreateOrConnectWithoutCoachInput[]
    upsert?: ProgramTemplateUpsertWithWhereUniqueWithoutCoachInput | ProgramTemplateUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ProgramTemplateCreateManyCoachInputEnvelope
    set?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    disconnect?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    delete?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    connect?: ProgramTemplateWhereUniqueInput | ProgramTemplateWhereUniqueInput[]
    update?: ProgramTemplateUpdateWithWhereUniqueWithoutCoachInput | ProgramTemplateUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ProgramTemplateUpdateManyWithWhereWithoutCoachInput | ProgramTemplateUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ProgramTemplateScalarWhereInput | ProgramTemplateScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<MessageCreateWithoutCoachInput, MessageUncheckedCreateWithoutCoachInput> | MessageCreateWithoutCoachInput[] | MessageUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutCoachInput | MessageCreateOrConnectWithoutCoachInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutCoachInput | MessageUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: MessageCreateManyCoachInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutCoachInput | MessageUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutCoachInput | MessageUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ChannelCreateWithoutCoachInput, ChannelUncheckedCreateWithoutCoachInput> | ChannelCreateWithoutCoachInput[] | ChannelUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutCoachInput | ChannelCreateOrConnectWithoutCoachInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutCoachInput | ChannelUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ChannelCreateManyCoachInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutCoachInput | ChannelUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutCoachInput | ChannelUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<ReviewCreateWithoutCoachInput, ReviewUncheckedCreateWithoutCoachInput> | ReviewCreateWithoutCoachInput[] | ReviewUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCoachInput | ReviewCreateOrConnectWithoutCoachInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCoachInput | ReviewUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: ReviewCreateManyCoachInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCoachInput | ReviewUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCoachInput | ReviewUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CoachPostUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachPostCreateWithoutCoachInput, CoachPostUncheckedCreateWithoutCoachInput> | CoachPostCreateWithoutCoachInput[] | CoachPostUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachPostCreateOrConnectWithoutCoachInput | CoachPostCreateOrConnectWithoutCoachInput[]
    upsert?: CoachPostUpsertWithWhereUniqueWithoutCoachInput | CoachPostUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachPostCreateManyCoachInputEnvelope
    set?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    disconnect?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    delete?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    connect?: CoachPostWhereUniqueInput | CoachPostWhereUniqueInput[]
    update?: CoachPostUpdateWithWhereUniqueWithoutCoachInput | CoachPostUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachPostUpdateManyWithWhereWithoutCoachInput | CoachPostUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachPostScalarWhereInput | CoachPostScalarWhereInput[]
  }

  export type CoachRequestUncheckedUpdateManyWithoutCoachNestedInput = {
    create?: XOR<CoachRequestCreateWithoutCoachInput, CoachRequestUncheckedCreateWithoutCoachInput> | CoachRequestCreateWithoutCoachInput[] | CoachRequestUncheckedCreateWithoutCoachInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutCoachInput | CoachRequestCreateOrConnectWithoutCoachInput[]
    upsert?: CoachRequestUpsertWithWhereUniqueWithoutCoachInput | CoachRequestUpsertWithWhereUniqueWithoutCoachInput[]
    createMany?: CoachRequestCreateManyCoachInputEnvelope
    set?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    disconnect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    delete?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    update?: CoachRequestUpdateWithWhereUniqueWithoutCoachInput | CoachRequestUpdateWithWhereUniqueWithoutCoachInput[]
    updateMany?: CoachRequestUpdateManyWithWhereWithoutCoachInput | CoachRequestUpdateManyWithWhereWithoutCoachInput[]
    deleteMany?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientProfileInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    connect?: UserWhereUniqueInput
  }

  export type CoachProfileCreateNestedOneWithoutClientsInput = {
    create?: XOR<CoachProfileCreateWithoutClientsInput, CoachProfileUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutClientsInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientCoachCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientCoachCreateWithoutClientInput, ClientCoachUncheckedCreateWithoutClientInput> | ClientCoachCreateWithoutClientInput[] | ClientCoachUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutClientInput | ClientCoachCreateOrConnectWithoutClientInput[]
    createMany?: ClientCoachCreateManyClientInputEnvelope
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
  }

  export type DailyStatCreateNestedManyWithoutClientInput = {
    create?: XOR<DailyStatCreateWithoutClientInput, DailyStatUncheckedCreateWithoutClientInput> | DailyStatCreateWithoutClientInput[] | DailyStatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyStatCreateOrConnectWithoutClientInput | DailyStatCreateOrConnectWithoutClientInput[]
    createMany?: DailyStatCreateManyClientInputEnvelope
    connect?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
  }

  export type MealCreateNestedManyWithoutClientInput = {
    create?: XOR<MealCreateWithoutClientInput, MealUncheckedCreateWithoutClientInput> | MealCreateWithoutClientInput[] | MealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MealCreateOrConnectWithoutClientInput | MealCreateOrConnectWithoutClientInput[]
    createMany?: MealCreateManyClientInputEnvelope
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutClientInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutClientInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CoachRequestCreateNestedManyWithoutClientInput = {
    create?: XOR<CoachRequestCreateWithoutClientInput, CoachRequestUncheckedCreateWithoutClientInput> | CoachRequestCreateWithoutClientInput[] | CoachRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutClientInput | CoachRequestCreateOrConnectWithoutClientInput[]
    createMany?: CoachRequestCreateManyClientInputEnvelope
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
  }

  export type ClientCoachUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientCoachCreateWithoutClientInput, ClientCoachUncheckedCreateWithoutClientInput> | ClientCoachCreateWithoutClientInput[] | ClientCoachUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutClientInput | ClientCoachCreateOrConnectWithoutClientInput[]
    createMany?: ClientCoachCreateManyClientInputEnvelope
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
  }

  export type DailyStatUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DailyStatCreateWithoutClientInput, DailyStatUncheckedCreateWithoutClientInput> | DailyStatCreateWithoutClientInput[] | DailyStatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyStatCreateOrConnectWithoutClientInput | DailyStatCreateOrConnectWithoutClientInput[]
    createMany?: DailyStatCreateManyClientInputEnvelope
    connect?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
  }

  export type MealUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MealCreateWithoutClientInput, MealUncheckedCreateWithoutClientInput> | MealCreateWithoutClientInput[] | MealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MealCreateOrConnectWithoutClientInput | MealCreateOrConnectWithoutClientInput[]
    createMany?: MealCreateManyClientInputEnvelope
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CoachRequestUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CoachRequestCreateWithoutClientInput, CoachRequestUncheckedCreateWithoutClientInput> | CoachRequestCreateWithoutClientInput[] | CoachRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutClientInput | CoachRequestCreateOrConnectWithoutClientInput[]
    createMany?: CoachRequestCreateManyClientInputEnvelope
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutClientProfileNestedInput = {
    create?: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientProfileInput
    upsert?: UserUpsertWithoutClientProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientProfileInput, UserUpdateWithoutClientProfileInput>, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type CoachProfileUpdateOneWithoutClientsNestedInput = {
    create?: XOR<CoachProfileCreateWithoutClientsInput, CoachProfileUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutClientsInput
    upsert?: CoachProfileUpsertWithoutClientsInput
    disconnect?: CoachProfileWhereInput | boolean
    delete?: CoachProfileWhereInput | boolean
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutClientsInput, CoachProfileUpdateWithoutClientsInput>, CoachProfileUncheckedUpdateWithoutClientsInput>
  }

  export type ClientCoachUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientCoachCreateWithoutClientInput, ClientCoachUncheckedCreateWithoutClientInput> | ClientCoachCreateWithoutClientInput[] | ClientCoachUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutClientInput | ClientCoachCreateOrConnectWithoutClientInput[]
    upsert?: ClientCoachUpsertWithWhereUniqueWithoutClientInput | ClientCoachUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientCoachCreateManyClientInputEnvelope
    set?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    disconnect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    delete?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    update?: ClientCoachUpdateWithWhereUniqueWithoutClientInput | ClientCoachUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientCoachUpdateManyWithWhereWithoutClientInput | ClientCoachUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientCoachScalarWhereInput | ClientCoachScalarWhereInput[]
  }

  export type DailyStatUpdateManyWithoutClientNestedInput = {
    create?: XOR<DailyStatCreateWithoutClientInput, DailyStatUncheckedCreateWithoutClientInput> | DailyStatCreateWithoutClientInput[] | DailyStatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyStatCreateOrConnectWithoutClientInput | DailyStatCreateOrConnectWithoutClientInput[]
    upsert?: DailyStatUpsertWithWhereUniqueWithoutClientInput | DailyStatUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DailyStatCreateManyClientInputEnvelope
    set?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    disconnect?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    delete?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    connect?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    update?: DailyStatUpdateWithWhereUniqueWithoutClientInput | DailyStatUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DailyStatUpdateManyWithWhereWithoutClientInput | DailyStatUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DailyStatScalarWhereInput | DailyStatScalarWhereInput[]
  }

  export type MealUpdateManyWithoutClientNestedInput = {
    create?: XOR<MealCreateWithoutClientInput, MealUncheckedCreateWithoutClientInput> | MealCreateWithoutClientInput[] | MealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MealCreateOrConnectWithoutClientInput | MealCreateOrConnectWithoutClientInput[]
    upsert?: MealUpsertWithWhereUniqueWithoutClientInput | MealUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MealCreateManyClientInputEnvelope
    set?: MealWhereUniqueInput | MealWhereUniqueInput[]
    disconnect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    delete?: MealWhereUniqueInput | MealWhereUniqueInput[]
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    update?: MealUpdateWithWhereUniqueWithoutClientInput | MealUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MealUpdateManyWithWhereWithoutClientInput | MealUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MealScalarWhereInput | MealScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutClientNestedInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClientInput | MessageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClientInput | MessageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClientInput | MessageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutClientInput | ReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutClientInput | ReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutClientInput | ReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CoachRequestUpdateManyWithoutClientNestedInput = {
    create?: XOR<CoachRequestCreateWithoutClientInput, CoachRequestUncheckedCreateWithoutClientInput> | CoachRequestCreateWithoutClientInput[] | CoachRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutClientInput | CoachRequestCreateOrConnectWithoutClientInput[]
    upsert?: CoachRequestUpsertWithWhereUniqueWithoutClientInput | CoachRequestUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CoachRequestCreateManyClientInputEnvelope
    set?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    disconnect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    delete?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    update?: CoachRequestUpdateWithWhereUniqueWithoutClientInput | CoachRequestUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CoachRequestUpdateManyWithWhereWithoutClientInput | CoachRequestUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
  }

  export type ClientCoachUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientCoachCreateWithoutClientInput, ClientCoachUncheckedCreateWithoutClientInput> | ClientCoachCreateWithoutClientInput[] | ClientCoachUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientCoachCreateOrConnectWithoutClientInput | ClientCoachCreateOrConnectWithoutClientInput[]
    upsert?: ClientCoachUpsertWithWhereUniqueWithoutClientInput | ClientCoachUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientCoachCreateManyClientInputEnvelope
    set?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    disconnect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    delete?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    connect?: ClientCoachWhereUniqueInput | ClientCoachWhereUniqueInput[]
    update?: ClientCoachUpdateWithWhereUniqueWithoutClientInput | ClientCoachUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientCoachUpdateManyWithWhereWithoutClientInput | ClientCoachUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientCoachScalarWhereInput | ClientCoachScalarWhereInput[]
  }

  export type DailyStatUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DailyStatCreateWithoutClientInput, DailyStatUncheckedCreateWithoutClientInput> | DailyStatCreateWithoutClientInput[] | DailyStatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DailyStatCreateOrConnectWithoutClientInput | DailyStatCreateOrConnectWithoutClientInput[]
    upsert?: DailyStatUpsertWithWhereUniqueWithoutClientInput | DailyStatUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DailyStatCreateManyClientInputEnvelope
    set?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    disconnect?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    delete?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    connect?: DailyStatWhereUniqueInput | DailyStatWhereUniqueInput[]
    update?: DailyStatUpdateWithWhereUniqueWithoutClientInput | DailyStatUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DailyStatUpdateManyWithWhereWithoutClientInput | DailyStatUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DailyStatScalarWhereInput | DailyStatScalarWhereInput[]
  }

  export type MealUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MealCreateWithoutClientInput, MealUncheckedCreateWithoutClientInput> | MealCreateWithoutClientInput[] | MealUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MealCreateOrConnectWithoutClientInput | MealCreateOrConnectWithoutClientInput[]
    upsert?: MealUpsertWithWhereUniqueWithoutClientInput | MealUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MealCreateManyClientInputEnvelope
    set?: MealWhereUniqueInput | MealWhereUniqueInput[]
    disconnect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    delete?: MealWhereUniqueInput | MealWhereUniqueInput[]
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    update?: MealUpdateWithWhereUniqueWithoutClientInput | MealUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MealUpdateManyWithWhereWithoutClientInput | MealUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MealScalarWhereInput | MealScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput> | MessageCreateWithoutClientInput[] | MessageUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutClientInput | MessageCreateOrConnectWithoutClientInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutClientInput | MessageUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MessageCreateManyClientInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutClientInput | MessageUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutClientInput | MessageUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutClientInput | ReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutClientInput | ReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutClientInput | ReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CoachRequestUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CoachRequestCreateWithoutClientInput, CoachRequestUncheckedCreateWithoutClientInput> | CoachRequestCreateWithoutClientInput[] | CoachRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CoachRequestCreateOrConnectWithoutClientInput | CoachRequestCreateOrConnectWithoutClientInput[]
    upsert?: CoachRequestUpsertWithWhereUniqueWithoutClientInput | CoachRequestUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CoachRequestCreateManyClientInputEnvelope
    set?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    disconnect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    delete?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    connect?: CoachRequestWhereUniqueInput | CoachRequestWhereUniqueInput[]
    update?: CoachRequestUpdateWithWhereUniqueWithoutClientInput | CoachRequestUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CoachRequestUpdateManyWithWhereWithoutClientInput | CoachRequestUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
  }

  export type ClientProfileCreateNestedOneWithoutCoachesInput = {
    create?: XOR<ClientProfileCreateWithoutCoachesInput, ClientProfileUncheckedCreateWithoutCoachesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachesInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type CoachProfileCreateNestedOneWithoutClientCoachesInput = {
    create?: XOR<CoachProfileCreateWithoutClientCoachesInput, CoachProfileUncheckedCreateWithoutClientCoachesInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutClientCoachesInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientProfileUpdateOneRequiredWithoutCoachesNestedInput = {
    create?: XOR<ClientProfileCreateWithoutCoachesInput, ClientProfileUncheckedCreateWithoutCoachesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachesInput
    upsert?: ClientProfileUpsertWithoutCoachesInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutCoachesInput, ClientProfileUpdateWithoutCoachesInput>, ClientProfileUncheckedUpdateWithoutCoachesInput>
  }

  export type CoachProfileUpdateOneRequiredWithoutClientCoachesNestedInput = {
    create?: XOR<CoachProfileCreateWithoutClientCoachesInput, CoachProfileUncheckedCreateWithoutClientCoachesInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutClientCoachesInput
    upsert?: CoachProfileUpsertWithoutClientCoachesInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutClientCoachesInput, CoachProfileUpdateWithoutClientCoachesInput>, CoachProfileUncheckedUpdateWithoutClientCoachesInput>
  }

  export type CoachProfileCreateNestedOneWithoutProgramsInput = {
    create?: XOR<CoachProfileCreateWithoutProgramsInput, CoachProfileUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutProgramsInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutProgramInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MealPlanCreateNestedManyWithoutProgramInput = {
    create?: XOR<MealPlanCreateWithoutProgramInput, MealPlanUncheckedCreateWithoutProgramInput> | MealPlanCreateWithoutProgramInput[] | MealPlanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutProgramInput | MealPlanCreateOrConnectWithoutProgramInput[]
    createMany?: MealPlanCreateManyProgramInputEnvelope
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
  }

  export type CustomGoalCreateNestedManyWithoutProgramInput = {
    create?: XOR<CustomGoalCreateWithoutProgramInput, CustomGoalUncheckedCreateWithoutProgramInput> | CustomGoalCreateWithoutProgramInput[] | CustomGoalUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: CustomGoalCreateOrConnectWithoutProgramInput | CustomGoalCreateOrConnectWithoutProgramInput[]
    createMany?: CustomGoalCreateManyProgramInputEnvelope
    connect?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type MealPlanUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<MealPlanCreateWithoutProgramInput, MealPlanUncheckedCreateWithoutProgramInput> | MealPlanCreateWithoutProgramInput[] | MealPlanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutProgramInput | MealPlanCreateOrConnectWithoutProgramInput[]
    createMany?: MealPlanCreateManyProgramInputEnvelope
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
  }

  export type CustomGoalUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<CustomGoalCreateWithoutProgramInput, CustomGoalUncheckedCreateWithoutProgramInput> | CustomGoalCreateWithoutProgramInput[] | CustomGoalUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: CustomGoalCreateOrConnectWithoutProgramInput | CustomGoalCreateOrConnectWithoutProgramInput[]
    createMany?: CustomGoalCreateManyProgramInputEnvelope
    connect?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CoachProfileUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<CoachProfileCreateWithoutProgramsInput, CoachProfileUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutProgramsInput
    upsert?: CoachProfileUpsertWithoutProgramsInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutProgramsInput, CoachProfileUpdateWithoutProgramsInput>, CoachProfileUncheckedUpdateWithoutProgramsInput>
  }

  export type SessionUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProgramInput | SessionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProgramInput | SessionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProgramInput | SessionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MealPlanUpdateManyWithoutProgramNestedInput = {
    create?: XOR<MealPlanCreateWithoutProgramInput, MealPlanUncheckedCreateWithoutProgramInput> | MealPlanCreateWithoutProgramInput[] | MealPlanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutProgramInput | MealPlanCreateOrConnectWithoutProgramInput[]
    upsert?: MealPlanUpsertWithWhereUniqueWithoutProgramInput | MealPlanUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: MealPlanCreateManyProgramInputEnvelope
    set?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    disconnect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    delete?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    update?: MealPlanUpdateWithWhereUniqueWithoutProgramInput | MealPlanUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: MealPlanUpdateManyWithWhereWithoutProgramInput | MealPlanUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
  }

  export type CustomGoalUpdateManyWithoutProgramNestedInput = {
    create?: XOR<CustomGoalCreateWithoutProgramInput, CustomGoalUncheckedCreateWithoutProgramInput> | CustomGoalCreateWithoutProgramInput[] | CustomGoalUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: CustomGoalCreateOrConnectWithoutProgramInput | CustomGoalCreateOrConnectWithoutProgramInput[]
    upsert?: CustomGoalUpsertWithWhereUniqueWithoutProgramInput | CustomGoalUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: CustomGoalCreateManyProgramInputEnvelope
    set?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    disconnect?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    delete?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    connect?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    update?: CustomGoalUpdateWithWhereUniqueWithoutProgramInput | CustomGoalUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: CustomGoalUpdateManyWithWhereWithoutProgramInput | CustomGoalUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: CustomGoalScalarWhereInput | CustomGoalScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput> | SessionCreateWithoutProgramInput[] | SessionUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutProgramInput | SessionCreateOrConnectWithoutProgramInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutProgramInput | SessionUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: SessionCreateManyProgramInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutProgramInput | SessionUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutProgramInput | SessionUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type MealPlanUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<MealPlanCreateWithoutProgramInput, MealPlanUncheckedCreateWithoutProgramInput> | MealPlanCreateWithoutProgramInput[] | MealPlanUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutProgramInput | MealPlanCreateOrConnectWithoutProgramInput[]
    upsert?: MealPlanUpsertWithWhereUniqueWithoutProgramInput | MealPlanUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: MealPlanCreateManyProgramInputEnvelope
    set?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    disconnect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    delete?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    update?: MealPlanUpdateWithWhereUniqueWithoutProgramInput | MealPlanUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: MealPlanUpdateManyWithWhereWithoutProgramInput | MealPlanUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
  }

  export type CustomGoalUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<CustomGoalCreateWithoutProgramInput, CustomGoalUncheckedCreateWithoutProgramInput> | CustomGoalCreateWithoutProgramInput[] | CustomGoalUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: CustomGoalCreateOrConnectWithoutProgramInput | CustomGoalCreateOrConnectWithoutProgramInput[]
    upsert?: CustomGoalUpsertWithWhereUniqueWithoutProgramInput | CustomGoalUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: CustomGoalCreateManyProgramInputEnvelope
    set?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    disconnect?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    delete?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    connect?: CustomGoalWhereUniqueInput | CustomGoalWhereUniqueInput[]
    update?: CustomGoalUpdateWithWhereUniqueWithoutProgramInput | CustomGoalUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: CustomGoalUpdateManyWithWhereWithoutProgramInput | CustomGoalUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: CustomGoalScalarWhereInput | CustomGoalScalarWhereInput[]
  }

  export type CoachProfileCreateNestedOneWithoutProgramTemplatesInput = {
    create?: XOR<CoachProfileCreateWithoutProgramTemplatesInput, CoachProfileUncheckedCreateWithoutProgramTemplatesInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutProgramTemplatesInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type CoachProfileUpdateOneRequiredWithoutProgramTemplatesNestedInput = {
    create?: XOR<CoachProfileCreateWithoutProgramTemplatesInput, CoachProfileUncheckedCreateWithoutProgramTemplatesInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutProgramTemplatesInput
    upsert?: CoachProfileUpsertWithoutProgramTemplatesInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutProgramTemplatesInput, CoachProfileUpdateWithoutProgramTemplatesInput>, CoachProfileUncheckedUpdateWithoutProgramTemplatesInput>
  }

  export type ProgramCreateNestedOneWithoutCustomGoalsInput = {
    create?: XOR<ProgramCreateWithoutCustomGoalsInput, ProgramUncheckedCreateWithoutCustomGoalsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutCustomGoalsInput
    connect?: ProgramWhereUniqueInput
  }

  export type GoalCompletionCreateNestedManyWithoutCustomGoalInput = {
    create?: XOR<GoalCompletionCreateWithoutCustomGoalInput, GoalCompletionUncheckedCreateWithoutCustomGoalInput> | GoalCompletionCreateWithoutCustomGoalInput[] | GoalCompletionUncheckedCreateWithoutCustomGoalInput[]
    connectOrCreate?: GoalCompletionCreateOrConnectWithoutCustomGoalInput | GoalCompletionCreateOrConnectWithoutCustomGoalInput[]
    createMany?: GoalCompletionCreateManyCustomGoalInputEnvelope
    connect?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
  }

  export type GoalCompletionUncheckedCreateNestedManyWithoutCustomGoalInput = {
    create?: XOR<GoalCompletionCreateWithoutCustomGoalInput, GoalCompletionUncheckedCreateWithoutCustomGoalInput> | GoalCompletionCreateWithoutCustomGoalInput[] | GoalCompletionUncheckedCreateWithoutCustomGoalInput[]
    connectOrCreate?: GoalCompletionCreateOrConnectWithoutCustomGoalInput | GoalCompletionCreateOrConnectWithoutCustomGoalInput[]
    createMany?: GoalCompletionCreateManyCustomGoalInputEnvelope
    connect?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
  }

  export type ProgramUpdateOneRequiredWithoutCustomGoalsNestedInput = {
    create?: XOR<ProgramCreateWithoutCustomGoalsInput, ProgramUncheckedCreateWithoutCustomGoalsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutCustomGoalsInput
    upsert?: ProgramUpsertWithoutCustomGoalsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutCustomGoalsInput, ProgramUpdateWithoutCustomGoalsInput>, ProgramUncheckedUpdateWithoutCustomGoalsInput>
  }

  export type GoalCompletionUpdateManyWithoutCustomGoalNestedInput = {
    create?: XOR<GoalCompletionCreateWithoutCustomGoalInput, GoalCompletionUncheckedCreateWithoutCustomGoalInput> | GoalCompletionCreateWithoutCustomGoalInput[] | GoalCompletionUncheckedCreateWithoutCustomGoalInput[]
    connectOrCreate?: GoalCompletionCreateOrConnectWithoutCustomGoalInput | GoalCompletionCreateOrConnectWithoutCustomGoalInput[]
    upsert?: GoalCompletionUpsertWithWhereUniqueWithoutCustomGoalInput | GoalCompletionUpsertWithWhereUniqueWithoutCustomGoalInput[]
    createMany?: GoalCompletionCreateManyCustomGoalInputEnvelope
    set?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    disconnect?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    delete?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    connect?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    update?: GoalCompletionUpdateWithWhereUniqueWithoutCustomGoalInput | GoalCompletionUpdateWithWhereUniqueWithoutCustomGoalInput[]
    updateMany?: GoalCompletionUpdateManyWithWhereWithoutCustomGoalInput | GoalCompletionUpdateManyWithWhereWithoutCustomGoalInput[]
    deleteMany?: GoalCompletionScalarWhereInput | GoalCompletionScalarWhereInput[]
  }

  export type GoalCompletionUncheckedUpdateManyWithoutCustomGoalNestedInput = {
    create?: XOR<GoalCompletionCreateWithoutCustomGoalInput, GoalCompletionUncheckedCreateWithoutCustomGoalInput> | GoalCompletionCreateWithoutCustomGoalInput[] | GoalCompletionUncheckedCreateWithoutCustomGoalInput[]
    connectOrCreate?: GoalCompletionCreateOrConnectWithoutCustomGoalInput | GoalCompletionCreateOrConnectWithoutCustomGoalInput[]
    upsert?: GoalCompletionUpsertWithWhereUniqueWithoutCustomGoalInput | GoalCompletionUpsertWithWhereUniqueWithoutCustomGoalInput[]
    createMany?: GoalCompletionCreateManyCustomGoalInputEnvelope
    set?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    disconnect?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    delete?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    connect?: GoalCompletionWhereUniqueInput | GoalCompletionWhereUniqueInput[]
    update?: GoalCompletionUpdateWithWhereUniqueWithoutCustomGoalInput | GoalCompletionUpdateWithWhereUniqueWithoutCustomGoalInput[]
    updateMany?: GoalCompletionUpdateManyWithWhereWithoutCustomGoalInput | GoalCompletionUpdateManyWithWhereWithoutCustomGoalInput[]
    deleteMany?: GoalCompletionScalarWhereInput | GoalCompletionScalarWhereInput[]
  }

  export type CustomGoalCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<CustomGoalCreateWithoutCompletionsInput, CustomGoalUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: CustomGoalCreateOrConnectWithoutCompletionsInput
    connect?: CustomGoalWhereUniqueInput
  }

  export type CustomGoalUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<CustomGoalCreateWithoutCompletionsInput, CustomGoalUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: CustomGoalCreateOrConnectWithoutCompletionsInput
    upsert?: CustomGoalUpsertWithoutCompletionsInput
    connect?: CustomGoalWhereUniqueInput
    update?: XOR<XOR<CustomGoalUpdateToOneWithWhereWithoutCompletionsInput, CustomGoalUpdateWithoutCompletionsInput>, CustomGoalUncheckedUpdateWithoutCompletionsInput>
  }

  export type ProgramCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionsInput
    connect?: ProgramWhereUniqueInput
  }

  export type ExerciseCreateNestedManyWithoutSessionInput = {
    create?: XOR<ExerciseCreateWithoutSessionInput, ExerciseUncheckedCreateWithoutSessionInput> | ExerciseCreateWithoutSessionInput[] | ExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionInput | ExerciseCreateOrConnectWithoutSessionInput[]
    createMany?: ExerciseCreateManySessionInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutSessionInput = {
    create?: XOR<CommentCreateWithoutSessionInput, CommentUncheckedCreateWithoutSessionInput> | CommentCreateWithoutSessionInput[] | CommentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSessionInput | CommentCreateOrConnectWithoutSessionInput[]
    createMany?: CommentCreateManySessionInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ExerciseCreateWithoutSessionInput, ExerciseUncheckedCreateWithoutSessionInput> | ExerciseCreateWithoutSessionInput[] | ExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionInput | ExerciseCreateOrConnectWithoutSessionInput[]
    createMany?: ExerciseCreateManySessionInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CommentCreateWithoutSessionInput, CommentUncheckedCreateWithoutSessionInput> | CommentCreateWithoutSessionInput[] | CommentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSessionInput | CommentCreateOrConnectWithoutSessionInput[]
    createMany?: CommentCreateManySessionInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type ProgramUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutSessionsInput
    upsert?: ProgramUpsertWithoutSessionsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutSessionsInput, ProgramUpdateWithoutSessionsInput>, ProgramUncheckedUpdateWithoutSessionsInput>
  }

  export type ExerciseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ExerciseCreateWithoutSessionInput, ExerciseUncheckedCreateWithoutSessionInput> | ExerciseCreateWithoutSessionInput[] | ExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionInput | ExerciseCreateOrConnectWithoutSessionInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutSessionInput | ExerciseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ExerciseCreateManySessionInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutSessionInput | ExerciseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutSessionInput | ExerciseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CommentCreateWithoutSessionInput, CommentUncheckedCreateWithoutSessionInput> | CommentCreateWithoutSessionInput[] | CommentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSessionInput | CommentCreateOrConnectWithoutSessionInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutSessionInput | CommentUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CommentCreateManySessionInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutSessionInput | CommentUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutSessionInput | CommentUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ExerciseCreateWithoutSessionInput, ExerciseUncheckedCreateWithoutSessionInput> | ExerciseCreateWithoutSessionInput[] | ExerciseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutSessionInput | ExerciseCreateOrConnectWithoutSessionInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutSessionInput | ExerciseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ExerciseCreateManySessionInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutSessionInput | ExerciseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutSessionInput | ExerciseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CommentCreateWithoutSessionInput, CommentUncheckedCreateWithoutSessionInput> | CommentCreateWithoutSessionInput[] | CommentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutSessionInput | CommentCreateOrConnectWithoutSessionInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutSessionInput | CommentUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CommentCreateManySessionInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutSessionInput | CommentUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutSessionInput | CommentUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutExercisesInput = {
    create?: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutExercisesInput
    connect?: SessionWhereUniqueInput
  }

  export type SetCompletionCreateNestedManyWithoutExerciseInput = {
    create?: XOR<SetCompletionCreateWithoutExerciseInput, SetCompletionUncheckedCreateWithoutExerciseInput> | SetCompletionCreateWithoutExerciseInput[] | SetCompletionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCompletionCreateOrConnectWithoutExerciseInput | SetCompletionCreateOrConnectWithoutExerciseInput[]
    createMany?: SetCompletionCreateManyExerciseInputEnvelope
    connect?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
  }

  export type SetCompletionUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<SetCompletionCreateWithoutExerciseInput, SetCompletionUncheckedCreateWithoutExerciseInput> | SetCompletionCreateWithoutExerciseInput[] | SetCompletionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCompletionCreateOrConnectWithoutExerciseInput | SetCompletionCreateOrConnectWithoutExerciseInput[]
    createMany?: SetCompletionCreateManyExerciseInputEnvelope
    connect?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
  }

  export type EnumExerciseCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExerciseCategory
  }

  export type SessionUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutExercisesInput
    upsert?: SessionUpsertWithoutExercisesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutExercisesInput, SessionUpdateWithoutExercisesInput>, SessionUncheckedUpdateWithoutExercisesInput>
  }

  export type SetCompletionUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<SetCompletionCreateWithoutExerciseInput, SetCompletionUncheckedCreateWithoutExerciseInput> | SetCompletionCreateWithoutExerciseInput[] | SetCompletionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCompletionCreateOrConnectWithoutExerciseInput | SetCompletionCreateOrConnectWithoutExerciseInput[]
    upsert?: SetCompletionUpsertWithWhereUniqueWithoutExerciseInput | SetCompletionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: SetCompletionCreateManyExerciseInputEnvelope
    set?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    disconnect?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    delete?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    connect?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    update?: SetCompletionUpdateWithWhereUniqueWithoutExerciseInput | SetCompletionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: SetCompletionUpdateManyWithWhereWithoutExerciseInput | SetCompletionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: SetCompletionScalarWhereInput | SetCompletionScalarWhereInput[]
  }

  export type SetCompletionUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<SetCompletionCreateWithoutExerciseInput, SetCompletionUncheckedCreateWithoutExerciseInput> | SetCompletionCreateWithoutExerciseInput[] | SetCompletionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCompletionCreateOrConnectWithoutExerciseInput | SetCompletionCreateOrConnectWithoutExerciseInput[]
    upsert?: SetCompletionUpsertWithWhereUniqueWithoutExerciseInput | SetCompletionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: SetCompletionCreateManyExerciseInputEnvelope
    set?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    disconnect?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    delete?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    connect?: SetCompletionWhereUniqueInput | SetCompletionWhereUniqueInput[]
    update?: SetCompletionUpdateWithWhereUniqueWithoutExerciseInput | SetCompletionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: SetCompletionUpdateManyWithWhereWithoutExerciseInput | SetCompletionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: SetCompletionScalarWhereInput | SetCompletionScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutSetCompletionsInput = {
    create?: XOR<ExerciseCreateWithoutSetCompletionsInput, ExerciseUncheckedCreateWithoutSetCompletionsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSetCompletionsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExerciseUpdateOneRequiredWithoutSetCompletionsNestedInput = {
    create?: XOR<ExerciseCreateWithoutSetCompletionsInput, ExerciseUncheckedCreateWithoutSetCompletionsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSetCompletionsInput
    upsert?: ExerciseUpsertWithoutSetCompletionsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutSetCompletionsInput, ExerciseUpdateWithoutSetCompletionsInput>, ExerciseUncheckedUpdateWithoutSetCompletionsInput>
  }

  export type ProgramCreateNestedOneWithoutMealPlansInput = {
    create?: XOR<ProgramCreateWithoutMealPlansInput, ProgramUncheckedCreateWithoutMealPlansInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutMealPlansInput
    connect?: ProgramWhereUniqueInput
  }

  export type MenuItemCreateNestedManyWithoutMealPlanInput = {
    create?: XOR<MenuItemCreateWithoutMealPlanInput, MenuItemUncheckedCreateWithoutMealPlanInput> | MenuItemCreateWithoutMealPlanInput[] | MenuItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMealPlanInput | MenuItemCreateOrConnectWithoutMealPlanInput[]
    createMany?: MenuItemCreateManyMealPlanInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutMealPlanInput = {
    create?: XOR<MenuItemCreateWithoutMealPlanInput, MenuItemUncheckedCreateWithoutMealPlanInput> | MenuItemCreateWithoutMealPlanInput[] | MenuItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMealPlanInput | MenuItemCreateOrConnectWithoutMealPlanInput[]
    createMany?: MenuItemCreateManyMealPlanInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type ProgramUpdateOneRequiredWithoutMealPlansNestedInput = {
    create?: XOR<ProgramCreateWithoutMealPlansInput, ProgramUncheckedCreateWithoutMealPlansInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutMealPlansInput
    upsert?: ProgramUpsertWithoutMealPlansInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutMealPlansInput, ProgramUpdateWithoutMealPlansInput>, ProgramUncheckedUpdateWithoutMealPlansInput>
  }

  export type MenuItemUpdateManyWithoutMealPlanNestedInput = {
    create?: XOR<MenuItemCreateWithoutMealPlanInput, MenuItemUncheckedCreateWithoutMealPlanInput> | MenuItemCreateWithoutMealPlanInput[] | MenuItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMealPlanInput | MenuItemCreateOrConnectWithoutMealPlanInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutMealPlanInput | MenuItemUpsertWithWhereUniqueWithoutMealPlanInput[]
    createMany?: MenuItemCreateManyMealPlanInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutMealPlanInput | MenuItemUpdateWithWhereUniqueWithoutMealPlanInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutMealPlanInput | MenuItemUpdateManyWithWhereWithoutMealPlanInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutMealPlanNestedInput = {
    create?: XOR<MenuItemCreateWithoutMealPlanInput, MenuItemUncheckedCreateWithoutMealPlanInput> | MenuItemCreateWithoutMealPlanInput[] | MenuItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMealPlanInput | MenuItemCreateOrConnectWithoutMealPlanInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutMealPlanInput | MenuItemUpsertWithWhereUniqueWithoutMealPlanInput[]
    createMany?: MenuItemCreateManyMealPlanInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutMealPlanInput | MenuItemUpdateWithWhereUniqueWithoutMealPlanInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutMealPlanInput | MenuItemUpdateManyWithWhereWithoutMealPlanInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MealPlanCreateNestedOneWithoutMenuItemsInput = {
    create?: XOR<MealPlanCreateWithoutMenuItemsInput, MealPlanUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: MealPlanCreateOrConnectWithoutMenuItemsInput
    connect?: MealPlanWhereUniqueInput
  }

  export type MealPlanUpdateOneRequiredWithoutMenuItemsNestedInput = {
    create?: XOR<MealPlanCreateWithoutMenuItemsInput, MealPlanUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: MealPlanCreateOrConnectWithoutMenuItemsInput
    upsert?: MealPlanUpsertWithoutMenuItemsInput
    connect?: MealPlanWhereUniqueInput
    update?: XOR<XOR<MealPlanUpdateToOneWithWhereWithoutMenuItemsInput, MealPlanUpdateWithoutMenuItemsInput>, MealPlanUncheckedUpdateWithoutMenuItemsInput>
  }

  export type ClientProfileCreateNestedOneWithoutMealsInput = {
    create?: XOR<ClientProfileCreateWithoutMealsInput, ClientProfileUncheckedCreateWithoutMealsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutMealsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type ClientProfileUpdateOneRequiredWithoutMealsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutMealsInput, ClientProfileUncheckedCreateWithoutMealsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutMealsInput
    upsert?: ClientProfileUpsertWithoutMealsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutMealsInput, ClientProfileUpdateWithoutMealsInput>, ClientProfileUncheckedUpdateWithoutMealsInput>
  }

  export type ClientProfileCreateNestedOneWithoutStatsInput = {
    create?: XOR<ClientProfileCreateWithoutStatsInput, ClientProfileUncheckedCreateWithoutStatsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutStatsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type ClientProfileUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutStatsInput, ClientProfileUncheckedCreateWithoutStatsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutStatsInput
    upsert?: ClientProfileUpsertWithoutStatsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutStatsInput, ClientProfileUpdateWithoutStatsInput>, ClientProfileUncheckedUpdateWithoutStatsInput>
  }

  export type SessionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SessionCreateWithoutCommentsInput, SessionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutCommentsInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<SessionCreateWithoutCommentsInput, SessionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutCommentsInput
    upsert?: SessionUpsertWithoutCommentsInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutCommentsInput, SessionUpdateWithoutCommentsInput>, SessionUncheckedUpdateWithoutCommentsInput>
  }

  export type CoachProfileCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<CoachProfileCreateWithoutSentMessagesInput, CoachProfileUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutSentMessagesInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<ClientProfileCreateWithoutReceivedMessagesInput, ClientProfileUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutReceivedMessagesInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type CoachProfileUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<CoachProfileCreateWithoutSentMessagesInput, CoachProfileUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutSentMessagesInput
    upsert?: CoachProfileUpsertWithoutSentMessagesInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutSentMessagesInput, CoachProfileUpdateWithoutSentMessagesInput>, CoachProfileUncheckedUpdateWithoutSentMessagesInput>
  }

  export type ClientProfileUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<ClientProfileCreateWithoutReceivedMessagesInput, ClientProfileUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutReceivedMessagesInput
    upsert?: ClientProfileUpsertWithoutReceivedMessagesInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutReceivedMessagesInput, ClientProfileUpdateWithoutReceivedMessagesInput>, ClientProfileUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type CoachProfileCreateNestedOneWithoutChannelsInput = {
    create?: XOR<CoachProfileCreateWithoutChannelsInput, CoachProfileUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutChannelsInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type CoachProfileUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<CoachProfileCreateWithoutChannelsInput, CoachProfileUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutChannelsInput
    upsert?: CoachProfileUpsertWithoutChannelsInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutChannelsInput, CoachProfileUpdateWithoutChannelsInput>, CoachProfileUncheckedUpdateWithoutChannelsInput>
  }

  export type CoachProfileCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CoachProfileCreateWithoutReviewsInput, CoachProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutReviewsInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ClientProfileCreateWithoutReviewsInput, ClientProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutReviewsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type CoachProfileUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CoachProfileCreateWithoutReviewsInput, CoachProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutReviewsInput
    upsert?: CoachProfileUpsertWithoutReviewsInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutReviewsInput, CoachProfileUpdateWithoutReviewsInput>, CoachProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientProfileUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutReviewsInput, ClientProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutReviewsInput
    upsert?: ClientProfileUpsertWithoutReviewsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutReviewsInput, ClientProfileUpdateWithoutReviewsInput>, ClientProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type CoachProfileCreateNestedOneWithoutCoachRequestsInput = {
    create?: XOR<CoachProfileCreateWithoutCoachRequestsInput, CoachProfileUncheckedCreateWithoutCoachRequestsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutCoachRequestsInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type ClientProfileCreateNestedOneWithoutCoachRequestsInput = {
    create?: XOR<ClientProfileCreateWithoutCoachRequestsInput, ClientProfileUncheckedCreateWithoutCoachRequestsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachRequestsInput
    connect?: ClientProfileWhereUniqueInput
  }

  export type CoachProfileUpdateOneRequiredWithoutCoachRequestsNestedInput = {
    create?: XOR<CoachProfileCreateWithoutCoachRequestsInput, CoachProfileUncheckedCreateWithoutCoachRequestsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutCoachRequestsInput
    upsert?: CoachProfileUpsertWithoutCoachRequestsInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutCoachRequestsInput, CoachProfileUpdateWithoutCoachRequestsInput>, CoachProfileUncheckedUpdateWithoutCoachRequestsInput>
  }

  export type ClientProfileUpdateOneRequiredWithoutCoachRequestsNestedInput = {
    create?: XOR<ClientProfileCreateWithoutCoachRequestsInput, ClientProfileUncheckedCreateWithoutCoachRequestsInput>
    connectOrCreate?: ClientProfileCreateOrConnectWithoutCoachRequestsInput
    upsert?: ClientProfileUpsertWithoutCoachRequestsInput
    connect?: ClientProfileWhereUniqueInput
    update?: XOR<XOR<ClientProfileUpdateToOneWithWhereWithoutCoachRequestsInput, ClientProfileUpdateWithoutCoachRequestsInput>, ClientProfileUncheckedUpdateWithoutCoachRequestsInput>
  }

  export type CoachProfileCreateNestedOneWithoutPostsInput = {
    create?: XOR<CoachProfileCreateWithoutPostsInput, CoachProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutPostsInput
    connect?: CoachProfileWhereUniqueInput
  }

  export type CoachProfileUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<CoachProfileCreateWithoutPostsInput, CoachProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CoachProfileCreateOrConnectWithoutPostsInput
    upsert?: CoachProfileUpsertWithoutPostsInput
    connect?: CoachProfileWhereUniqueInput
    update?: XOR<XOR<CoachProfileUpdateToOneWithWhereWithoutPostsInput, CoachProfileUpdateWithoutPostsInput>, CoachProfileUncheckedUpdateWithoutPostsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumExerciseCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseCategory | EnumExerciseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseCategoryFilter<$PrismaModel> | $Enums.ExerciseCategory
  }

  export type NestedEnumExerciseCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExerciseCategory | EnumExerciseCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExerciseCategory[] | ListEnumExerciseCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExerciseCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExerciseCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExerciseCategoryFilter<$PrismaModel>
    _max?: NestedEnumExerciseCategoryFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type CoachProfileCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutUserInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutUserInput, CoachProfileUncheckedCreateWithoutUserInput>
  }

  export type ClientProfileCreateWithoutUserInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutUserInput = {
    id?: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutUserInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
  }

  export type CoachProfileUpsertWithoutUserInput = {
    update: XOR<CoachProfileUpdateWithoutUserInput, CoachProfileUncheckedUpdateWithoutUserInput>
    create: XOR<CoachProfileCreateWithoutUserInput, CoachProfileUncheckedCreateWithoutUserInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutUserInput, CoachProfileUncheckedUpdateWithoutUserInput>
  }

  export type CoachProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ClientProfileUpsertWithoutUserInput = {
    update: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ClientProfileCreateWithoutUserInput, ClientProfileUncheckedCreateWithoutUserInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutUserInput, ClientProfileUncheckedUpdateWithoutUserInput>
  }

  export type ClientProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserCreateWithoutCoachProfileInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoachProfileInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientProfile?: ClientProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoachProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachProfileInput, UserUncheckedCreateWithoutCoachProfileInput>
  }

  export type ClientProfileCreateWithoutCoachInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutCoachInput = {
    id?: string
    userId: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutCoachInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutCoachInput, ClientProfileUncheckedCreateWithoutCoachInput>
  }

  export type ClientProfileCreateManyCoachInputEnvelope = {
    data: ClientProfileCreateManyCoachInput | ClientProfileCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ClientCoachCreateWithoutCoachInput = {
    id?: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutCoachesInput
  }

  export type ClientCoachUncheckedCreateWithoutCoachInput = {
    id?: string
    clientId: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCoachCreateOrConnectWithoutCoachInput = {
    where: ClientCoachWhereUniqueInput
    create: XOR<ClientCoachCreateWithoutCoachInput, ClientCoachUncheckedCreateWithoutCoachInput>
  }

  export type ClientCoachCreateManyCoachInputEnvelope = {
    data: ClientCoachCreateManyCoachInput | ClientCoachCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutCoachInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutProgramInput
    mealPlans?: MealPlanCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutCoachInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutCoachInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput>
  }

  export type ProgramCreateManyCoachInputEnvelope = {
    data: ProgramCreateManyCoachInput | ProgramCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ProgramTemplateCreateWithoutCoachInput = {
    id?: string
    name: string
    description?: string | null
    cycleDays?: number | null
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramTemplateUncheckedCreateWithoutCoachInput = {
    id?: string
    name: string
    description?: string | null
    cycleDays?: number | null
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramTemplateCreateOrConnectWithoutCoachInput = {
    where: ProgramTemplateWhereUniqueInput
    create: XOR<ProgramTemplateCreateWithoutCoachInput, ProgramTemplateUncheckedCreateWithoutCoachInput>
  }

  export type ProgramTemplateCreateManyCoachInputEnvelope = {
    data: ProgramTemplateCreateManyCoachInput | ProgramTemplateCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutCoachInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutCoachInput = {
    id?: string
    clientId: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutCoachInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutCoachInput, MessageUncheckedCreateWithoutCoachInput>
  }

  export type MessageCreateManyCoachInputEnvelope = {
    data: MessageCreateManyCoachInput | MessageCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutCoachInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelUncheckedCreateWithoutCoachInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateOrConnectWithoutCoachInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutCoachInput, ChannelUncheckedCreateWithoutCoachInput>
  }

  export type ChannelCreateManyCoachInputEnvelope = {
    data: ChannelCreateManyCoachInput | ChannelCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutCoachInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutCoachInput = {
    id?: string
    clientId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutCoachInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCoachInput, ReviewUncheckedCreateWithoutCoachInput>
  }

  export type ReviewCreateManyCoachInputEnvelope = {
    data: ReviewCreateManyCoachInput | ReviewCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachPostCreateWithoutCoachInput = {
    id?: string
    content: string
    mediaType?: string | null
    mediaUrl?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachPostUncheckedCreateWithoutCoachInput = {
    id?: string
    content: string
    mediaType?: string | null
    mediaUrl?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachPostCreateOrConnectWithoutCoachInput = {
    where: CoachPostWhereUniqueInput
    create: XOR<CoachPostCreateWithoutCoachInput, CoachPostUncheckedCreateWithoutCoachInput>
  }

  export type CoachPostCreateManyCoachInputEnvelope = {
    data: CoachPostCreateManyCoachInput | CoachPostCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type CoachRequestCreateWithoutCoachInput = {
    id?: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientProfileCreateNestedOneWithoutCoachRequestsInput
  }

  export type CoachRequestUncheckedCreateWithoutCoachInput = {
    id?: string
    clientId: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestCreateOrConnectWithoutCoachInput = {
    where: CoachRequestWhereUniqueInput
    create: XOR<CoachRequestCreateWithoutCoachInput, CoachRequestUncheckedCreateWithoutCoachInput>
  }

  export type CoachRequestCreateManyCoachInputEnvelope = {
    data: CoachRequestCreateManyCoachInput | CoachRequestCreateManyCoachInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoachProfileInput = {
    update: XOR<UserUpdateWithoutCoachProfileInput, UserUncheckedUpdateWithoutCoachProfileInput>
    create: XOR<UserCreateWithoutCoachProfileInput, UserUncheckedCreateWithoutCoachProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoachProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoachProfileInput, UserUncheckedUpdateWithoutCoachProfileInput>
  }

  export type UserUpdateWithoutCoachProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientProfile?: ClientProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ClientProfileUpsertWithWhereUniqueWithoutCoachInput = {
    where: ClientProfileWhereUniqueInput
    update: XOR<ClientProfileUpdateWithoutCoachInput, ClientProfileUncheckedUpdateWithoutCoachInput>
    create: XOR<ClientProfileCreateWithoutCoachInput, ClientProfileUncheckedCreateWithoutCoachInput>
  }

  export type ClientProfileUpdateWithWhereUniqueWithoutCoachInput = {
    where: ClientProfileWhereUniqueInput
    data: XOR<ClientProfileUpdateWithoutCoachInput, ClientProfileUncheckedUpdateWithoutCoachInput>
  }

  export type ClientProfileUpdateManyWithWhereWithoutCoachInput = {
    where: ClientProfileScalarWhereInput
    data: XOR<ClientProfileUpdateManyMutationInput, ClientProfileUncheckedUpdateManyWithoutCoachInput>
  }

  export type ClientProfileScalarWhereInput = {
    AND?: ClientProfileScalarWhereInput | ClientProfileScalarWhereInput[]
    OR?: ClientProfileScalarWhereInput[]
    NOT?: ClientProfileScalarWhereInput | ClientProfileScalarWhereInput[]
    id?: StringFilter<"ClientProfile"> | string
    userId?: StringFilter<"ClientProfile"> | string
    coachId?: StringNullableFilter<"ClientProfile"> | string | null
    weight?: FloatNullableFilter<"ClientProfile"> | number | null
    height?: FloatNullableFilter<"ClientProfile"> | number | null
    dateOfBirth?: DateTimeNullableFilter<"ClientProfile"> | Date | string | null
    gender?: StringNullableFilter<"ClientProfile"> | string | null
    goals?: StringNullableFilter<"ClientProfile"> | string | null
    level?: StringNullableFilter<"ClientProfile"> | string | null
    profilePicture?: StringNullableFilter<"ClientProfile"> | string | null
    createdAt?: DateTimeFilter<"ClientProfile"> | Date | string
    updatedAt?: DateTimeFilter<"ClientProfile"> | Date | string
  }

  export type ClientCoachUpsertWithWhereUniqueWithoutCoachInput = {
    where: ClientCoachWhereUniqueInput
    update: XOR<ClientCoachUpdateWithoutCoachInput, ClientCoachUncheckedUpdateWithoutCoachInput>
    create: XOR<ClientCoachCreateWithoutCoachInput, ClientCoachUncheckedCreateWithoutCoachInput>
  }

  export type ClientCoachUpdateWithWhereUniqueWithoutCoachInput = {
    where: ClientCoachWhereUniqueInput
    data: XOR<ClientCoachUpdateWithoutCoachInput, ClientCoachUncheckedUpdateWithoutCoachInput>
  }

  export type ClientCoachUpdateManyWithWhereWithoutCoachInput = {
    where: ClientCoachScalarWhereInput
    data: XOR<ClientCoachUpdateManyMutationInput, ClientCoachUncheckedUpdateManyWithoutCoachInput>
  }

  export type ClientCoachScalarWhereInput = {
    AND?: ClientCoachScalarWhereInput | ClientCoachScalarWhereInput[]
    OR?: ClientCoachScalarWhereInput[]
    NOT?: ClientCoachScalarWhereInput | ClientCoachScalarWhereInput[]
    id?: StringFilter<"ClientCoach"> | string
    clientId?: StringFilter<"ClientCoach"> | string
    coachId?: StringFilter<"ClientCoach"> | string
    isPrimary?: BoolFilter<"ClientCoach"> | boolean
    startDate?: DateTimeFilter<"ClientCoach"> | Date | string
    endDate?: DateTimeNullableFilter<"ClientCoach"> | Date | string | null
    isActive?: BoolFilter<"ClientCoach"> | boolean
    createdAt?: DateTimeFilter<"ClientCoach"> | Date | string
    updatedAt?: DateTimeFilter<"ClientCoach"> | Date | string
  }

  export type ProgramUpsertWithWhereUniqueWithoutCoachInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutCoachInput, ProgramUncheckedUpdateWithoutCoachInput>
    create: XOR<ProgramCreateWithoutCoachInput, ProgramUncheckedCreateWithoutCoachInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutCoachInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutCoachInput, ProgramUncheckedUpdateWithoutCoachInput>
  }

  export type ProgramUpdateManyWithWhereWithoutCoachInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutCoachInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: StringFilter<"Program"> | string
    coachId?: StringFilter<"Program"> | string
    clientId?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    description?: StringNullableFilter<"Program"> | string | null
    cycleDays?: IntNullableFilter<"Program"> | number | null
    startDate?: DateTimeFilter<"Program"> | Date | string
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    isActive?: BoolFilter<"Program"> | boolean
    dietEnabled?: BoolFilter<"Program"> | boolean
    dietType?: StringNullableFilter<"Program"> | string | null
    targetCalories?: IntNullableFilter<"Program"> | number | null
    waterTrackingEnabled?: BoolFilter<"Program"> | boolean
    waterGoal?: FloatNullableFilter<"Program"> | number | null
    sleepTrackingEnabled?: BoolFilter<"Program"> | boolean
    weightTrackingEnabled?: BoolFilter<"Program"> | boolean
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
  }

  export type ProgramTemplateUpsertWithWhereUniqueWithoutCoachInput = {
    where: ProgramTemplateWhereUniqueInput
    update: XOR<ProgramTemplateUpdateWithoutCoachInput, ProgramTemplateUncheckedUpdateWithoutCoachInput>
    create: XOR<ProgramTemplateCreateWithoutCoachInput, ProgramTemplateUncheckedCreateWithoutCoachInput>
  }

  export type ProgramTemplateUpdateWithWhereUniqueWithoutCoachInput = {
    where: ProgramTemplateWhereUniqueInput
    data: XOR<ProgramTemplateUpdateWithoutCoachInput, ProgramTemplateUncheckedUpdateWithoutCoachInput>
  }

  export type ProgramTemplateUpdateManyWithWhereWithoutCoachInput = {
    where: ProgramTemplateScalarWhereInput
    data: XOR<ProgramTemplateUpdateManyMutationInput, ProgramTemplateUncheckedUpdateManyWithoutCoachInput>
  }

  export type ProgramTemplateScalarWhereInput = {
    AND?: ProgramTemplateScalarWhereInput | ProgramTemplateScalarWhereInput[]
    OR?: ProgramTemplateScalarWhereInput[]
    NOT?: ProgramTemplateScalarWhereInput | ProgramTemplateScalarWhereInput[]
    id?: StringFilter<"ProgramTemplate"> | string
    coachId?: StringFilter<"ProgramTemplate"> | string
    name?: StringFilter<"ProgramTemplate"> | string
    description?: StringNullableFilter<"ProgramTemplate"> | string | null
    cycleDays?: IntNullableFilter<"ProgramTemplate"> | number | null
    dietEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    dietType?: StringNullableFilter<"ProgramTemplate"> | string | null
    targetCalories?: IntNullableFilter<"ProgramTemplate"> | number | null
    waterTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    waterGoal?: FloatNullableFilter<"ProgramTemplate"> | number | null
    sleepTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    weightTrackingEnabled?: BoolFilter<"ProgramTemplate"> | boolean
    sessionsData?: JsonNullableFilter<"ProgramTemplate">
    customGoalsData?: JsonNullableFilter<"ProgramTemplate">
    createdAt?: DateTimeFilter<"ProgramTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ProgramTemplate"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutCoachInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutCoachInput, MessageUncheckedUpdateWithoutCoachInput>
    create: XOR<MessageCreateWithoutCoachInput, MessageUncheckedCreateWithoutCoachInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutCoachInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutCoachInput, MessageUncheckedUpdateWithoutCoachInput>
  }

  export type MessageUpdateManyWithWhereWithoutCoachInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutCoachInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    coachId?: StringFilter<"Message"> | string
    clientId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    scheduledTime?: DateTimeNullableFilter<"Message"> | Date | string | null
    isRead?: BoolFilter<"Message"> | boolean
    isSentByCoach?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ChannelUpsertWithWhereUniqueWithoutCoachInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutCoachInput, ChannelUncheckedUpdateWithoutCoachInput>
    create: XOR<ChannelCreateWithoutCoachInput, ChannelUncheckedCreateWithoutCoachInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutCoachInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutCoachInput, ChannelUncheckedUpdateWithoutCoachInput>
  }

  export type ChannelUpdateManyWithWhereWithoutCoachInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutCoachInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: StringFilter<"Channel"> | string
    coachId?: StringFilter<"Channel"> | string
    title?: StringFilter<"Channel"> | string
    description?: StringNullableFilter<"Channel"> | string | null
    content?: StringFilter<"Channel"> | string
    isPublished?: BoolFilter<"Channel"> | boolean
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    updatedAt?: DateTimeFilter<"Channel"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutCoachInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutCoachInput, ReviewUncheckedUpdateWithoutCoachInput>
    create: XOR<ReviewCreateWithoutCoachInput, ReviewUncheckedCreateWithoutCoachInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutCoachInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutCoachInput, ReviewUncheckedUpdateWithoutCoachInput>
  }

  export type ReviewUpdateManyWithWhereWithoutCoachInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutCoachInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    coachId?: StringFilter<"Review"> | string
    clientId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type CoachPostUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachPostWhereUniqueInput
    update: XOR<CoachPostUpdateWithoutCoachInput, CoachPostUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachPostCreateWithoutCoachInput, CoachPostUncheckedCreateWithoutCoachInput>
  }

  export type CoachPostUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachPostWhereUniqueInput
    data: XOR<CoachPostUpdateWithoutCoachInput, CoachPostUncheckedUpdateWithoutCoachInput>
  }

  export type CoachPostUpdateManyWithWhereWithoutCoachInput = {
    where: CoachPostScalarWhereInput
    data: XOR<CoachPostUpdateManyMutationInput, CoachPostUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachPostScalarWhereInput = {
    AND?: CoachPostScalarWhereInput | CoachPostScalarWhereInput[]
    OR?: CoachPostScalarWhereInput[]
    NOT?: CoachPostScalarWhereInput | CoachPostScalarWhereInput[]
    id?: StringFilter<"CoachPost"> | string
    coachId?: StringFilter<"CoachPost"> | string
    content?: StringFilter<"CoachPost"> | string
    mediaType?: StringNullableFilter<"CoachPost"> | string | null
    mediaUrl?: StringNullableFilter<"CoachPost"> | string | null
    isPublic?: BoolFilter<"CoachPost"> | boolean
    createdAt?: DateTimeFilter<"CoachPost"> | Date | string
    updatedAt?: DateTimeFilter<"CoachPost"> | Date | string
  }

  export type CoachRequestUpsertWithWhereUniqueWithoutCoachInput = {
    where: CoachRequestWhereUniqueInput
    update: XOR<CoachRequestUpdateWithoutCoachInput, CoachRequestUncheckedUpdateWithoutCoachInput>
    create: XOR<CoachRequestCreateWithoutCoachInput, CoachRequestUncheckedCreateWithoutCoachInput>
  }

  export type CoachRequestUpdateWithWhereUniqueWithoutCoachInput = {
    where: CoachRequestWhereUniqueInput
    data: XOR<CoachRequestUpdateWithoutCoachInput, CoachRequestUncheckedUpdateWithoutCoachInput>
  }

  export type CoachRequestUpdateManyWithWhereWithoutCoachInput = {
    where: CoachRequestScalarWhereInput
    data: XOR<CoachRequestUpdateManyMutationInput, CoachRequestUncheckedUpdateManyWithoutCoachInput>
  }

  export type CoachRequestScalarWhereInput = {
    AND?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
    OR?: CoachRequestScalarWhereInput[]
    NOT?: CoachRequestScalarWhereInput | CoachRequestScalarWhereInput[]
    id?: StringFilter<"CoachRequest"> | string
    coachId?: StringFilter<"CoachRequest"> | string
    clientId?: StringFilter<"CoachRequest"> | string
    message?: StringFilter<"CoachRequest"> | string
    status?: StringFilter<"CoachRequest"> | string
    createdAt?: DateTimeFilter<"CoachRequest"> | Date | string
    updatedAt?: DateTimeFilter<"CoachRequest"> | Date | string
  }

  export type UserCreateWithoutClientProfileInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coachProfile?: CoachProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClientProfileInput = {
    id?: string
    email: string
    password: string
    role: $Enums.UserRole
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coachProfile?: CoachProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClientProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
  }

  export type CoachProfileCreateWithoutClientsInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutClientsInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutClientsInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutClientsInput, CoachProfileUncheckedCreateWithoutClientsInput>
  }

  export type ClientCoachCreateWithoutClientInput = {
    id?: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutClientCoachesInput
  }

  export type ClientCoachUncheckedCreateWithoutClientInput = {
    id?: string
    coachId: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCoachCreateOrConnectWithoutClientInput = {
    where: ClientCoachWhereUniqueInput
    create: XOR<ClientCoachCreateWithoutClientInput, ClientCoachUncheckedCreateWithoutClientInput>
  }

  export type ClientCoachCreateManyClientInputEnvelope = {
    data: ClientCoachCreateManyClientInput | ClientCoachCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DailyStatCreateWithoutClientInput = {
    id?: string
    date: Date | string
    sleepHours?: number | null
    bedTime?: Date | string | null
    wakeTime?: Date | string | null
    waterIntake?: number | null
    weight?: number | null
    totalCalories?: number | null
    workoutTime?: Date | string | null
    workoutDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatUncheckedCreateWithoutClientInput = {
    id?: string
    date: Date | string
    sleepHours?: number | null
    bedTime?: Date | string | null
    wakeTime?: Date | string | null
    waterIntake?: number | null
    weight?: number | null
    totalCalories?: number | null
    workoutTime?: Date | string | null
    workoutDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatCreateOrConnectWithoutClientInput = {
    where: DailyStatWhereUniqueInput
    create: XOR<DailyStatCreateWithoutClientInput, DailyStatUncheckedCreateWithoutClientInput>
  }

  export type DailyStatCreateManyClientInputEnvelope = {
    data: DailyStatCreateManyClientInput | DailyStatCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MealCreateWithoutClientInput = {
    id?: string
    date: Date | string
    mealType: string
    description: string
    photoUrl?: string | null
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealUncheckedCreateWithoutClientInput = {
    id?: string
    date: Date | string
    mealType: string
    description: string
    photoUrl?: string | null
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealCreateOrConnectWithoutClientInput = {
    where: MealWhereUniqueInput
    create: XOR<MealCreateWithoutClientInput, MealUncheckedCreateWithoutClientInput>
  }

  export type MealCreateManyClientInputEnvelope = {
    data: MealCreateManyClientInput | MealCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutClientInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutClientInput = {
    id?: string
    coachId: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutClientInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput>
  }

  export type MessageCreateManyClientInputEnvelope = {
    data: MessageCreateManyClientInput | MessageCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutClientInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutClientInput = {
    id?: string
    coachId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutClientInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewCreateManyClientInputEnvelope = {
    data: ReviewCreateManyClientInput | ReviewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CoachRequestCreateWithoutClientInput = {
    id?: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutCoachRequestsInput
  }

  export type CoachRequestUncheckedCreateWithoutClientInput = {
    id?: string
    coachId: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestCreateOrConnectWithoutClientInput = {
    where: CoachRequestWhereUniqueInput
    create: XOR<CoachRequestCreateWithoutClientInput, CoachRequestUncheckedCreateWithoutClientInput>
  }

  export type CoachRequestCreateManyClientInputEnvelope = {
    data: CoachRequestCreateManyClientInput | CoachRequestCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientProfileInput = {
    update: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
    create: XOR<UserCreateWithoutClientProfileInput, UserUncheckedCreateWithoutClientProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientProfileInput, UserUncheckedUpdateWithoutClientProfileInput>
  }

  export type UserUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachProfile?: CoachProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClientProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coachProfile?: CoachProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CoachProfileUpsertWithoutClientsInput = {
    update: XOR<CoachProfileUpdateWithoutClientsInput, CoachProfileUncheckedUpdateWithoutClientsInput>
    create: XOR<CoachProfileCreateWithoutClientsInput, CoachProfileUncheckedCreateWithoutClientsInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutClientsInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutClientsInput, CoachProfileUncheckedUpdateWithoutClientsInput>
  }

  export type CoachProfileUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ClientCoachUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientCoachWhereUniqueInput
    update: XOR<ClientCoachUpdateWithoutClientInput, ClientCoachUncheckedUpdateWithoutClientInput>
    create: XOR<ClientCoachCreateWithoutClientInput, ClientCoachUncheckedCreateWithoutClientInput>
  }

  export type ClientCoachUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientCoachWhereUniqueInput
    data: XOR<ClientCoachUpdateWithoutClientInput, ClientCoachUncheckedUpdateWithoutClientInput>
  }

  export type ClientCoachUpdateManyWithWhereWithoutClientInput = {
    where: ClientCoachScalarWhereInput
    data: XOR<ClientCoachUpdateManyMutationInput, ClientCoachUncheckedUpdateManyWithoutClientInput>
  }

  export type DailyStatUpsertWithWhereUniqueWithoutClientInput = {
    where: DailyStatWhereUniqueInput
    update: XOR<DailyStatUpdateWithoutClientInput, DailyStatUncheckedUpdateWithoutClientInput>
    create: XOR<DailyStatCreateWithoutClientInput, DailyStatUncheckedCreateWithoutClientInput>
  }

  export type DailyStatUpdateWithWhereUniqueWithoutClientInput = {
    where: DailyStatWhereUniqueInput
    data: XOR<DailyStatUpdateWithoutClientInput, DailyStatUncheckedUpdateWithoutClientInput>
  }

  export type DailyStatUpdateManyWithWhereWithoutClientInput = {
    where: DailyStatScalarWhereInput
    data: XOR<DailyStatUpdateManyMutationInput, DailyStatUncheckedUpdateManyWithoutClientInput>
  }

  export type DailyStatScalarWhereInput = {
    AND?: DailyStatScalarWhereInput | DailyStatScalarWhereInput[]
    OR?: DailyStatScalarWhereInput[]
    NOT?: DailyStatScalarWhereInput | DailyStatScalarWhereInput[]
    id?: StringFilter<"DailyStat"> | string
    clientId?: StringFilter<"DailyStat"> | string
    date?: DateTimeFilter<"DailyStat"> | Date | string
    sleepHours?: FloatNullableFilter<"DailyStat"> | number | null
    bedTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    wakeTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    waterIntake?: FloatNullableFilter<"DailyStat"> | number | null
    weight?: FloatNullableFilter<"DailyStat"> | number | null
    totalCalories?: IntNullableFilter<"DailyStat"> | number | null
    workoutTime?: DateTimeNullableFilter<"DailyStat"> | Date | string | null
    workoutDuration?: IntNullableFilter<"DailyStat"> | number | null
    notes?: StringNullableFilter<"DailyStat"> | string | null
    createdAt?: DateTimeFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStat"> | Date | string
  }

  export type MealUpsertWithWhereUniqueWithoutClientInput = {
    where: MealWhereUniqueInput
    update: XOR<MealUpdateWithoutClientInput, MealUncheckedUpdateWithoutClientInput>
    create: XOR<MealCreateWithoutClientInput, MealUncheckedCreateWithoutClientInput>
  }

  export type MealUpdateWithWhereUniqueWithoutClientInput = {
    where: MealWhereUniqueInput
    data: XOR<MealUpdateWithoutClientInput, MealUncheckedUpdateWithoutClientInput>
  }

  export type MealUpdateManyWithWhereWithoutClientInput = {
    where: MealScalarWhereInput
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyWithoutClientInput>
  }

  export type MealScalarWhereInput = {
    AND?: MealScalarWhereInput | MealScalarWhereInput[]
    OR?: MealScalarWhereInput[]
    NOT?: MealScalarWhereInput | MealScalarWhereInput[]
    id?: StringFilter<"Meal"> | string
    clientId?: StringFilter<"Meal"> | string
    date?: DateTimeFilter<"Meal"> | Date | string
    mealType?: StringFilter<"Meal"> | string
    description?: StringFilter<"Meal"> | string
    photoUrl?: StringNullableFilter<"Meal"> | string | null
    calories?: IntFilter<"Meal"> | number
    protein?: FloatNullableFilter<"Meal"> | number | null
    carbs?: FloatNullableFilter<"Meal"> | number | null
    fats?: FloatNullableFilter<"Meal"> | number | null
    createdAt?: DateTimeFilter<"Meal"> | Date | string
    updatedAt?: DateTimeFilter<"Meal"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutClientInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutClientInput, MessageUncheckedUpdateWithoutClientInput>
    create: XOR<MessageCreateWithoutClientInput, MessageUncheckedCreateWithoutClientInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutClientInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutClientInput, MessageUncheckedUpdateWithoutClientInput>
  }

  export type MessageUpdateManyWithWhereWithoutClientInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutClientInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
  }

  export type ReviewUpdateManyWithWhereWithoutClientInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutClientInput>
  }

  export type CoachRequestUpsertWithWhereUniqueWithoutClientInput = {
    where: CoachRequestWhereUniqueInput
    update: XOR<CoachRequestUpdateWithoutClientInput, CoachRequestUncheckedUpdateWithoutClientInput>
    create: XOR<CoachRequestCreateWithoutClientInput, CoachRequestUncheckedCreateWithoutClientInput>
  }

  export type CoachRequestUpdateWithWhereUniqueWithoutClientInput = {
    where: CoachRequestWhereUniqueInput
    data: XOR<CoachRequestUpdateWithoutClientInput, CoachRequestUncheckedUpdateWithoutClientInput>
  }

  export type CoachRequestUpdateManyWithWhereWithoutClientInput = {
    where: CoachRequestScalarWhereInput
    data: XOR<CoachRequestUpdateManyMutationInput, CoachRequestUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientProfileCreateWithoutCoachesInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutCoachesInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutCoachesInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutCoachesInput, ClientProfileUncheckedCreateWithoutCoachesInput>
  }

  export type CoachProfileCreateWithoutClientCoachesInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutClientCoachesInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutClientCoachesInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutClientCoachesInput, CoachProfileUncheckedCreateWithoutClientCoachesInput>
  }

  export type ClientProfileUpsertWithoutCoachesInput = {
    update: XOR<ClientProfileUpdateWithoutCoachesInput, ClientProfileUncheckedUpdateWithoutCoachesInput>
    create: XOR<ClientProfileCreateWithoutCoachesInput, ClientProfileUncheckedCreateWithoutCoachesInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutCoachesInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutCoachesInput, ClientProfileUncheckedUpdateWithoutCoachesInput>
  }

  export type ClientProfileUpdateWithoutCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CoachProfileUpsertWithoutClientCoachesInput = {
    update: XOR<CoachProfileUpdateWithoutClientCoachesInput, CoachProfileUncheckedUpdateWithoutClientCoachesInput>
    create: XOR<CoachProfileCreateWithoutClientCoachesInput, CoachProfileUncheckedCreateWithoutClientCoachesInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutClientCoachesInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutClientCoachesInput, CoachProfileUncheckedUpdateWithoutClientCoachesInput>
  }

  export type CoachProfileUpdateWithoutClientCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutClientCoachesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileCreateWithoutProgramsInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutProgramsInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutProgramsInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutProgramsInput, CoachProfileUncheckedCreateWithoutProgramsInput>
  }

  export type SessionCreateWithoutProgramInput = {
    id?: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseCreateNestedManyWithoutSessionInput
    comments?: CommentCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutProgramInput = {
    id?: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutSessionInput
    comments?: CommentUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutProgramInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
  }

  export type SessionCreateManyProgramInputEnvelope = {
    data: SessionCreateManyProgramInput | SessionCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type MealPlanCreateWithoutProgramInput = {
    id?: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemCreateNestedManyWithoutMealPlanInput
  }

  export type MealPlanUncheckedCreateWithoutProgramInput = {
    id?: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutMealPlanInput
  }

  export type MealPlanCreateOrConnectWithoutProgramInput = {
    where: MealPlanWhereUniqueInput
    create: XOR<MealPlanCreateWithoutProgramInput, MealPlanUncheckedCreateWithoutProgramInput>
  }

  export type MealPlanCreateManyProgramInputEnvelope = {
    data: MealPlanCreateManyProgramInput | MealPlanCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type CustomGoalCreateWithoutProgramInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: GoalCompletionCreateNestedManyWithoutCustomGoalInput
  }

  export type CustomGoalUncheckedCreateWithoutProgramInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: GoalCompletionUncheckedCreateNestedManyWithoutCustomGoalInput
  }

  export type CustomGoalCreateOrConnectWithoutProgramInput = {
    where: CustomGoalWhereUniqueInput
    create: XOR<CustomGoalCreateWithoutProgramInput, CustomGoalUncheckedCreateWithoutProgramInput>
  }

  export type CustomGoalCreateManyProgramInputEnvelope = {
    data: CustomGoalCreateManyProgramInput | CustomGoalCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type CoachProfileUpsertWithoutProgramsInput = {
    update: XOR<CoachProfileUpdateWithoutProgramsInput, CoachProfileUncheckedUpdateWithoutProgramsInput>
    create: XOR<CoachProfileCreateWithoutProgramsInput, CoachProfileUncheckedCreateWithoutProgramsInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutProgramsInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutProgramsInput, CoachProfileUncheckedUpdateWithoutProgramsInput>
  }

  export type CoachProfileUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutProgramInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutProgramInput, SessionUncheckedUpdateWithoutProgramInput>
    create: XOR<SessionCreateWithoutProgramInput, SessionUncheckedCreateWithoutProgramInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutProgramInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutProgramInput, SessionUncheckedUpdateWithoutProgramInput>
  }

  export type SessionUpdateManyWithWhereWithoutProgramInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutProgramInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    programId?: StringFilter<"Session"> | string
    date?: DateTimeFilter<"Session"> | Date | string
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    isRestDay?: BoolFilter<"Session"> | boolean
    notes?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type MealPlanUpsertWithWhereUniqueWithoutProgramInput = {
    where: MealPlanWhereUniqueInput
    update: XOR<MealPlanUpdateWithoutProgramInput, MealPlanUncheckedUpdateWithoutProgramInput>
    create: XOR<MealPlanCreateWithoutProgramInput, MealPlanUncheckedCreateWithoutProgramInput>
  }

  export type MealPlanUpdateWithWhereUniqueWithoutProgramInput = {
    where: MealPlanWhereUniqueInput
    data: XOR<MealPlanUpdateWithoutProgramInput, MealPlanUncheckedUpdateWithoutProgramInput>
  }

  export type MealPlanUpdateManyWithWhereWithoutProgramInput = {
    where: MealPlanScalarWhereInput
    data: XOR<MealPlanUpdateManyMutationInput, MealPlanUncheckedUpdateManyWithoutProgramInput>
  }

  export type MealPlanScalarWhereInput = {
    AND?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
    OR?: MealPlanScalarWhereInput[]
    NOT?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
    id?: StringFilter<"MealPlan"> | string
    programId?: StringFilter<"MealPlan"> | string
    title?: StringFilter<"MealPlan"> | string
    description?: StringNullableFilter<"MealPlan"> | string | null
    dailyCalories?: IntNullableFilter<"MealPlan"> | number | null
    createdAt?: DateTimeFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MealPlan"> | Date | string
  }

  export type CustomGoalUpsertWithWhereUniqueWithoutProgramInput = {
    where: CustomGoalWhereUniqueInput
    update: XOR<CustomGoalUpdateWithoutProgramInput, CustomGoalUncheckedUpdateWithoutProgramInput>
    create: XOR<CustomGoalCreateWithoutProgramInput, CustomGoalUncheckedCreateWithoutProgramInput>
  }

  export type CustomGoalUpdateWithWhereUniqueWithoutProgramInput = {
    where: CustomGoalWhereUniqueInput
    data: XOR<CustomGoalUpdateWithoutProgramInput, CustomGoalUncheckedUpdateWithoutProgramInput>
  }

  export type CustomGoalUpdateManyWithWhereWithoutProgramInput = {
    where: CustomGoalScalarWhereInput
    data: XOR<CustomGoalUpdateManyMutationInput, CustomGoalUncheckedUpdateManyWithoutProgramInput>
  }

  export type CustomGoalScalarWhereInput = {
    AND?: CustomGoalScalarWhereInput | CustomGoalScalarWhereInput[]
    OR?: CustomGoalScalarWhereInput[]
    NOT?: CustomGoalScalarWhereInput | CustomGoalScalarWhereInput[]
    id?: StringFilter<"CustomGoal"> | string
    programId?: StringFilter<"CustomGoal"> | string
    title?: StringFilter<"CustomGoal"> | string
    description?: StringNullableFilter<"CustomGoal"> | string | null
    order?: IntFilter<"CustomGoal"> | number
    createdAt?: DateTimeFilter<"CustomGoal"> | Date | string
    updatedAt?: DateTimeFilter<"CustomGoal"> | Date | string
  }

  export type CoachProfileCreateWithoutProgramTemplatesInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutProgramTemplatesInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutProgramTemplatesInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutProgramTemplatesInput, CoachProfileUncheckedCreateWithoutProgramTemplatesInput>
  }

  export type CoachProfileUpsertWithoutProgramTemplatesInput = {
    update: XOR<CoachProfileUpdateWithoutProgramTemplatesInput, CoachProfileUncheckedUpdateWithoutProgramTemplatesInput>
    create: XOR<CoachProfileCreateWithoutProgramTemplatesInput, CoachProfileUncheckedCreateWithoutProgramTemplatesInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutProgramTemplatesInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutProgramTemplatesInput, CoachProfileUncheckedUpdateWithoutProgramTemplatesInput>
  }

  export type CoachProfileUpdateWithoutProgramTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutProgramTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ProgramCreateWithoutCustomGoalsInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutProgramsInput
    sessions?: SessionCreateNestedManyWithoutProgramInput
    mealPlans?: MealPlanCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutCustomGoalsInput = {
    id?: string
    coachId: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutCustomGoalsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutCustomGoalsInput, ProgramUncheckedCreateWithoutCustomGoalsInput>
  }

  export type GoalCompletionCreateWithoutCustomGoalInput = {
    id?: string
    clientId: string
    date: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCompletionUncheckedCreateWithoutCustomGoalInput = {
    id?: string
    clientId: string
    date: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCompletionCreateOrConnectWithoutCustomGoalInput = {
    where: GoalCompletionWhereUniqueInput
    create: XOR<GoalCompletionCreateWithoutCustomGoalInput, GoalCompletionUncheckedCreateWithoutCustomGoalInput>
  }

  export type GoalCompletionCreateManyCustomGoalInputEnvelope = {
    data: GoalCompletionCreateManyCustomGoalInput | GoalCompletionCreateManyCustomGoalInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutCustomGoalsInput = {
    update: XOR<ProgramUpdateWithoutCustomGoalsInput, ProgramUncheckedUpdateWithoutCustomGoalsInput>
    create: XOR<ProgramCreateWithoutCustomGoalsInput, ProgramUncheckedCreateWithoutCustomGoalsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutCustomGoalsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutCustomGoalsInput, ProgramUncheckedUpdateWithoutCustomGoalsInput>
  }

  export type ProgramUpdateWithoutCustomGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutProgramsNestedInput
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    mealPlans?: MealPlanUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutCustomGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type GoalCompletionUpsertWithWhereUniqueWithoutCustomGoalInput = {
    where: GoalCompletionWhereUniqueInput
    update: XOR<GoalCompletionUpdateWithoutCustomGoalInput, GoalCompletionUncheckedUpdateWithoutCustomGoalInput>
    create: XOR<GoalCompletionCreateWithoutCustomGoalInput, GoalCompletionUncheckedCreateWithoutCustomGoalInput>
  }

  export type GoalCompletionUpdateWithWhereUniqueWithoutCustomGoalInput = {
    where: GoalCompletionWhereUniqueInput
    data: XOR<GoalCompletionUpdateWithoutCustomGoalInput, GoalCompletionUncheckedUpdateWithoutCustomGoalInput>
  }

  export type GoalCompletionUpdateManyWithWhereWithoutCustomGoalInput = {
    where: GoalCompletionScalarWhereInput
    data: XOR<GoalCompletionUpdateManyMutationInput, GoalCompletionUncheckedUpdateManyWithoutCustomGoalInput>
  }

  export type GoalCompletionScalarWhereInput = {
    AND?: GoalCompletionScalarWhereInput | GoalCompletionScalarWhereInput[]
    OR?: GoalCompletionScalarWhereInput[]
    NOT?: GoalCompletionScalarWhereInput | GoalCompletionScalarWhereInput[]
    id?: StringFilter<"GoalCompletion"> | string
    customGoalId?: StringFilter<"GoalCompletion"> | string
    clientId?: StringFilter<"GoalCompletion"> | string
    date?: DateTimeFilter<"GoalCompletion"> | Date | string
    completed?: BoolFilter<"GoalCompletion"> | boolean
    createdAt?: DateTimeFilter<"GoalCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"GoalCompletion"> | Date | string
  }

  export type CustomGoalCreateWithoutCompletionsInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutCustomGoalsInput
  }

  export type CustomGoalUncheckedCreateWithoutCompletionsInput = {
    id?: string
    programId: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomGoalCreateOrConnectWithoutCompletionsInput = {
    where: CustomGoalWhereUniqueInput
    create: XOR<CustomGoalCreateWithoutCompletionsInput, CustomGoalUncheckedCreateWithoutCompletionsInput>
  }

  export type CustomGoalUpsertWithoutCompletionsInput = {
    update: XOR<CustomGoalUpdateWithoutCompletionsInput, CustomGoalUncheckedUpdateWithoutCompletionsInput>
    create: XOR<CustomGoalCreateWithoutCompletionsInput, CustomGoalUncheckedCreateWithoutCompletionsInput>
    where?: CustomGoalWhereInput
  }

  export type CustomGoalUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: CustomGoalWhereInput
    data: XOR<CustomGoalUpdateWithoutCompletionsInput, CustomGoalUncheckedUpdateWithoutCompletionsInput>
  }

  export type CustomGoalUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutCustomGoalsNestedInput
  }

  export type CustomGoalUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateWithoutSessionsInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutProgramsInput
    mealPlans?: MealPlanCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutSessionsInput = {
    id?: string
    coachId: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutSessionsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
  }

  export type ExerciseCreateWithoutSessionInput = {
    id?: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    setCompletions?: SetCompletionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    setCompletions?: SetCompletionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutSessionInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSessionInput, ExerciseUncheckedCreateWithoutSessionInput>
  }

  export type ExerciseCreateManySessionInputEnvelope = {
    data: ExerciseCreateManySessionInput | ExerciseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutSessionInput = {
    id?: string
    clientId: string
    content: string
    date: Date | string
    isPastComment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutSessionInput = {
    id?: string
    clientId: string
    content: string
    date: Date | string
    isPastComment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutSessionInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutSessionInput, CommentUncheckedCreateWithoutSessionInput>
  }

  export type CommentCreateManySessionInputEnvelope = {
    data: CommentCreateManySessionInput | CommentCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutSessionsInput = {
    update: XOR<ProgramUpdateWithoutSessionsInput, ProgramUncheckedUpdateWithoutSessionsInput>
    create: XOR<ProgramCreateWithoutSessionsInput, ProgramUncheckedCreateWithoutSessionsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutSessionsInput, ProgramUncheckedUpdateWithoutSessionsInput>
  }

  export type ProgramUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutProgramsNestedInput
    mealPlans?: MealPlanUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mealPlans?: MealPlanUncheckedUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ExerciseUpsertWithWhereUniqueWithoutSessionInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutSessionInput, ExerciseUncheckedUpdateWithoutSessionInput>
    create: XOR<ExerciseCreateWithoutSessionInput, ExerciseUncheckedCreateWithoutSessionInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutSessionInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutSessionInput, ExerciseUncheckedUpdateWithoutSessionInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutSessionInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutSessionInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: StringFilter<"Exercise"> | string
    sessionId?: StringFilter<"Exercise"> | string
    name?: StringFilter<"Exercise"> | string
    category?: EnumExerciseCategoryFilter<"Exercise"> | $Enums.ExerciseCategory
    sets?: IntNullableFilter<"Exercise"> | number | null
    reps?: StringNullableFilter<"Exercise"> | string | null
    weight?: StringNullableFilter<"Exercise"> | string | null
    restTime?: StringNullableFilter<"Exercise"> | string | null
    videoUrl?: StringNullableFilter<"Exercise"> | string | null
    gifUrl?: StringNullableFilter<"Exercise"> | string | null
    description?: StringNullableFilter<"Exercise"> | string | null
    order?: IntFilter<"Exercise"> | number
    duration?: StringNullableFilter<"Exercise"> | string | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutSessionInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutSessionInput, CommentUncheckedUpdateWithoutSessionInput>
    create: XOR<CommentCreateWithoutSessionInput, CommentUncheckedCreateWithoutSessionInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutSessionInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutSessionInput, CommentUncheckedUpdateWithoutSessionInput>
  }

  export type CommentUpdateManyWithWhereWithoutSessionInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutSessionInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    sessionId?: StringNullableFilter<"Comment"> | string | null
    clientId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    date?: DateTimeFilter<"Comment"> | Date | string
    isPastComment?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type SessionCreateWithoutExercisesInput = {
    id?: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutSessionsInput
    comments?: CommentCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutExercisesInput = {
    id?: string
    programId: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutExercisesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
  }

  export type SetCompletionCreateWithoutExerciseInput = {
    id?: string
    setNumber: number
    repsAchieved?: string | null
    weightUsed?: string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SetCompletionUncheckedCreateWithoutExerciseInput = {
    id?: string
    setNumber: number
    repsAchieved?: string | null
    weightUsed?: string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SetCompletionCreateOrConnectWithoutExerciseInput = {
    where: SetCompletionWhereUniqueInput
    create: XOR<SetCompletionCreateWithoutExerciseInput, SetCompletionUncheckedCreateWithoutExerciseInput>
  }

  export type SetCompletionCreateManyExerciseInputEnvelope = {
    data: SetCompletionCreateManyExerciseInput | SetCompletionCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithoutExercisesInput = {
    update: XOR<SessionUpdateWithoutExercisesInput, SessionUncheckedUpdateWithoutExercisesInput>
    create: XOR<SessionCreateWithoutExercisesInput, SessionUncheckedCreateWithoutExercisesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutExercisesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutExercisesInput, SessionUncheckedUpdateWithoutExercisesInput>
  }

  export type SessionUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutSessionsNestedInput
    comments?: CommentUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SetCompletionUpsertWithWhereUniqueWithoutExerciseInput = {
    where: SetCompletionWhereUniqueInput
    update: XOR<SetCompletionUpdateWithoutExerciseInput, SetCompletionUncheckedUpdateWithoutExerciseInput>
    create: XOR<SetCompletionCreateWithoutExerciseInput, SetCompletionUncheckedCreateWithoutExerciseInput>
  }

  export type SetCompletionUpdateWithWhereUniqueWithoutExerciseInput = {
    where: SetCompletionWhereUniqueInput
    data: XOR<SetCompletionUpdateWithoutExerciseInput, SetCompletionUncheckedUpdateWithoutExerciseInput>
  }

  export type SetCompletionUpdateManyWithWhereWithoutExerciseInput = {
    where: SetCompletionScalarWhereInput
    data: XOR<SetCompletionUpdateManyMutationInput, SetCompletionUncheckedUpdateManyWithoutExerciseInput>
  }

  export type SetCompletionScalarWhereInput = {
    AND?: SetCompletionScalarWhereInput | SetCompletionScalarWhereInput[]
    OR?: SetCompletionScalarWhereInput[]
    NOT?: SetCompletionScalarWhereInput | SetCompletionScalarWhereInput[]
    id?: StringFilter<"SetCompletion"> | string
    exerciseId?: StringFilter<"SetCompletion"> | string
    setNumber?: IntFilter<"SetCompletion"> | number
    repsAchieved?: StringNullableFilter<"SetCompletion"> | string | null
    weightUsed?: StringNullableFilter<"SetCompletion"> | string | null
    completed?: BoolFilter<"SetCompletion"> | boolean
    createdAt?: DateTimeFilter<"SetCompletion"> | Date | string
    updatedAt?: DateTimeFilter<"SetCompletion"> | Date | string
  }

  export type ExerciseCreateWithoutSetCompletionsInput = {
    id?: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutSetCompletionsInput = {
    id?: string
    sessionId: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseCreateOrConnectWithoutSetCompletionsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSetCompletionsInput, ExerciseUncheckedCreateWithoutSetCompletionsInput>
  }

  export type ExerciseUpsertWithoutSetCompletionsInput = {
    update: XOR<ExerciseUpdateWithoutSetCompletionsInput, ExerciseUncheckedUpdateWithoutSetCompletionsInput>
    create: XOR<ExerciseCreateWithoutSetCompletionsInput, ExerciseUncheckedCreateWithoutSetCompletionsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutSetCompletionsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutSetCompletionsInput, ExerciseUncheckedUpdateWithoutSetCompletionsInput>
  }

  export type ExerciseUpdateWithoutSetCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSetCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateWithoutMealPlansInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coach: CoachProfileCreateNestedOneWithoutProgramsInput
    sessions?: SessionCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutMealPlansInput = {
    id?: string
    coachId: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutProgramInput
    customGoals?: CustomGoalUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutMealPlansInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutMealPlansInput, ProgramUncheckedCreateWithoutMealPlansInput>
  }

  export type MenuItemCreateWithoutMealPlanInput = {
    id?: string
    mealType: string
    name: string
    description?: string | null
    calories?: number | null
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUncheckedCreateWithoutMealPlanInput = {
    id?: string
    mealType: string
    name: string
    description?: string | null
    calories?: number | null
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemCreateOrConnectWithoutMealPlanInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutMealPlanInput, MenuItemUncheckedCreateWithoutMealPlanInput>
  }

  export type MenuItemCreateManyMealPlanInputEnvelope = {
    data: MenuItemCreateManyMealPlanInput | MenuItemCreateManyMealPlanInput[]
    skipDuplicates?: boolean
  }

  export type ProgramUpsertWithoutMealPlansInput = {
    update: XOR<ProgramUpdateWithoutMealPlansInput, ProgramUncheckedUpdateWithoutMealPlansInput>
    create: XOR<ProgramCreateWithoutMealPlansInput, ProgramUncheckedCreateWithoutMealPlansInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutMealPlansInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutMealPlansInput, ProgramUncheckedUpdateWithoutMealPlansInput>
  }

  export type ProgramUpdateWithoutMealPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutProgramsNestedInput
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutMealPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type MenuItemUpsertWithWhereUniqueWithoutMealPlanInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutMealPlanInput, MenuItemUncheckedUpdateWithoutMealPlanInput>
    create: XOR<MenuItemCreateWithoutMealPlanInput, MenuItemUncheckedCreateWithoutMealPlanInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutMealPlanInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutMealPlanInput, MenuItemUncheckedUpdateWithoutMealPlanInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutMealPlanInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutMealPlanInput>
  }

  export type MenuItemScalarWhereInput = {
    AND?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    OR?: MenuItemScalarWhereInput[]
    NOT?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    mealPlanId?: StringFilter<"MenuItem"> | string
    mealType?: StringFilter<"MenuItem"> | string
    name?: StringFilter<"MenuItem"> | string
    description?: StringNullableFilter<"MenuItem"> | string | null
    calories?: IntNullableFilter<"MenuItem"> | number | null
    protein?: FloatNullableFilter<"MenuItem"> | number | null
    carbs?: FloatNullableFilter<"MenuItem"> | number | null
    fats?: FloatNullableFilter<"MenuItem"> | number | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
  }

  export type MealPlanCreateWithoutMenuItemsInput = {
    id?: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutMealPlansInput
  }

  export type MealPlanUncheckedCreateWithoutMenuItemsInput = {
    id?: string
    programId: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealPlanCreateOrConnectWithoutMenuItemsInput = {
    where: MealPlanWhereUniqueInput
    create: XOR<MealPlanCreateWithoutMenuItemsInput, MealPlanUncheckedCreateWithoutMenuItemsInput>
  }

  export type MealPlanUpsertWithoutMenuItemsInput = {
    update: XOR<MealPlanUpdateWithoutMenuItemsInput, MealPlanUncheckedUpdateWithoutMenuItemsInput>
    create: XOR<MealPlanCreateWithoutMenuItemsInput, MealPlanUncheckedCreateWithoutMenuItemsInput>
    where?: MealPlanWhereInput
  }

  export type MealPlanUpdateToOneWithWhereWithoutMenuItemsInput = {
    where?: MealPlanWhereInput
    data: XOR<MealPlanUpdateWithoutMenuItemsInput, MealPlanUncheckedUpdateWithoutMenuItemsInput>
  }

  export type MealPlanUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutMealPlansNestedInput
  }

  export type MealPlanUncheckedUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientProfileCreateWithoutMealsInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutMealsInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutMealsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutMealsInput, ClientProfileUncheckedCreateWithoutMealsInput>
  }

  export type ClientProfileUpsertWithoutMealsInput = {
    update: XOR<ClientProfileUpdateWithoutMealsInput, ClientProfileUncheckedUpdateWithoutMealsInput>
    create: XOR<ClientProfileCreateWithoutMealsInput, ClientProfileUncheckedCreateWithoutMealsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutMealsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutMealsInput, ClientProfileUncheckedUpdateWithoutMealsInput>
  }

  export type ClientProfileUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileCreateWithoutStatsInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutStatsInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutStatsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutStatsInput, ClientProfileUncheckedCreateWithoutStatsInput>
  }

  export type ClientProfileUpsertWithoutStatsInput = {
    update: XOR<ClientProfileUpdateWithoutStatsInput, ClientProfileUncheckedUpdateWithoutStatsInput>
    create: XOR<ClientProfileCreateWithoutStatsInput, ClientProfileUncheckedCreateWithoutStatsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutStatsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutStatsInput, ClientProfileUncheckedUpdateWithoutStatsInput>
  }

  export type ClientProfileUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type SessionCreateWithoutCommentsInput = {
    id?: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    program: ProgramCreateNestedOneWithoutSessionsInput
    exercises?: ExerciseCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCommentsInput = {
    id?: string
    programId: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutCommentsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCommentsInput, SessionUncheckedCreateWithoutCommentsInput>
  }

  export type SessionUpsertWithoutCommentsInput = {
    update: XOR<SessionUpdateWithoutCommentsInput, SessionUncheckedUpdateWithoutCommentsInput>
    create: XOR<SessionCreateWithoutCommentsInput, SessionUncheckedCreateWithoutCommentsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutCommentsInput, SessionUncheckedUpdateWithoutCommentsInput>
  }

  export type SessionUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutSessionsNestedInput
    exercises?: ExerciseUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CoachProfileCreateWithoutSentMessagesInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutSentMessagesInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutSentMessagesInput, CoachProfileUncheckedCreateWithoutSentMessagesInput>
  }

  export type ClientProfileCreateWithoutReceivedMessagesInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutReceivedMessagesInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutReceivedMessagesInput, ClientProfileUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type CoachProfileUpsertWithoutSentMessagesInput = {
    update: XOR<CoachProfileUpdateWithoutSentMessagesInput, CoachProfileUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<CoachProfileCreateWithoutSentMessagesInput, CoachProfileUncheckedCreateWithoutSentMessagesInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutSentMessagesInput, CoachProfileUncheckedUpdateWithoutSentMessagesInput>
  }

  export type CoachProfileUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ClientProfileUpsertWithoutReceivedMessagesInput = {
    update: XOR<ClientProfileUpdateWithoutReceivedMessagesInput, ClientProfileUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<ClientProfileCreateWithoutReceivedMessagesInput, ClientProfileUncheckedCreateWithoutReceivedMessagesInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutReceivedMessagesInput, ClientProfileUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type ClientProfileUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CoachProfileCreateWithoutChannelsInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutChannelsInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutChannelsInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutChannelsInput, CoachProfileUncheckedCreateWithoutChannelsInput>
  }

  export type CoachProfileUpsertWithoutChannelsInput = {
    update: XOR<CoachProfileUpdateWithoutChannelsInput, CoachProfileUncheckedUpdateWithoutChannelsInput>
    create: XOR<CoachProfileCreateWithoutChannelsInput, CoachProfileUncheckedCreateWithoutChannelsInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutChannelsInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutChannelsInput, CoachProfileUncheckedUpdateWithoutChannelsInput>
  }

  export type CoachProfileUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileCreateWithoutReviewsInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutReviewsInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutReviewsInput, CoachProfileUncheckedCreateWithoutReviewsInput>
  }

  export type ClientProfileCreateWithoutReviewsInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutReviewsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutReviewsInput, ClientProfileUncheckedCreateWithoutReviewsInput>
  }

  export type CoachProfileUpsertWithoutReviewsInput = {
    update: XOR<CoachProfileUpdateWithoutReviewsInput, CoachProfileUncheckedUpdateWithoutReviewsInput>
    create: XOR<CoachProfileCreateWithoutReviewsInput, CoachProfileUncheckedCreateWithoutReviewsInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutReviewsInput, CoachProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type CoachProfileUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ClientProfileUpsertWithoutReviewsInput = {
    update: XOR<ClientProfileUpdateWithoutReviewsInput, ClientProfileUncheckedUpdateWithoutReviewsInput>
    create: XOR<ClientProfileCreateWithoutReviewsInput, ClientProfileUncheckedCreateWithoutReviewsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutReviewsInput, ClientProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientProfileUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CoachProfileCreateWithoutCoachRequestsInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    posts?: CoachPostCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutCoachRequestsInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    posts?: CoachPostUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutCoachRequestsInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutCoachRequestsInput, CoachProfileUncheckedCreateWithoutCoachRequestsInput>
  }

  export type ClientProfileCreateWithoutCoachRequestsInput = {
    id?: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClientProfileInput
    coach?: CoachProfileCreateNestedOneWithoutClientsInput
    coaches?: ClientCoachCreateNestedManyWithoutClientInput
    stats?: DailyStatCreateNestedManyWithoutClientInput
    meals?: MealCreateNestedManyWithoutClientInput
    receivedMessages?: MessageCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
  }

  export type ClientProfileUncheckedCreateWithoutCoachRequestsInput = {
    id?: string
    userId: string
    coachId?: string | null
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    coaches?: ClientCoachUncheckedCreateNestedManyWithoutClientInput
    stats?: DailyStatUncheckedCreateNestedManyWithoutClientInput
    meals?: MealUncheckedCreateNestedManyWithoutClientInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientProfileCreateOrConnectWithoutCoachRequestsInput = {
    where: ClientProfileWhereUniqueInput
    create: XOR<ClientProfileCreateWithoutCoachRequestsInput, ClientProfileUncheckedCreateWithoutCoachRequestsInput>
  }

  export type CoachProfileUpsertWithoutCoachRequestsInput = {
    update: XOR<CoachProfileUpdateWithoutCoachRequestsInput, CoachProfileUncheckedUpdateWithoutCoachRequestsInput>
    create: XOR<CoachProfileCreateWithoutCoachRequestsInput, CoachProfileUncheckedCreateWithoutCoachRequestsInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutCoachRequestsInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutCoachRequestsInput, CoachProfileUncheckedUpdateWithoutCoachRequestsInput>
  }

  export type CoachProfileUpdateWithoutCoachRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutCoachRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    posts?: CoachPostUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ClientProfileUpsertWithoutCoachRequestsInput = {
    update: XOR<ClientProfileUpdateWithoutCoachRequestsInput, ClientProfileUncheckedUpdateWithoutCoachRequestsInput>
    create: XOR<ClientProfileCreateWithoutCoachRequestsInput, ClientProfileUncheckedCreateWithoutCoachRequestsInput>
    where?: ClientProfileWhereInput
  }

  export type ClientProfileUpdateToOneWithWhereWithoutCoachRequestsInput = {
    where?: ClientProfileWhereInput
    data: XOR<ClientProfileUpdateWithoutCoachRequestsInput, ClientProfileUncheckedUpdateWithoutCoachRequestsInput>
  }

  export type ClientProfileUpdateWithoutCoachRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coach?: CoachProfileUpdateOneWithoutClientsNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutCoachRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coachId?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
  }

  export type CoachProfileCreateWithoutPostsInput = {
    id?: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachProfileInput
    clients?: ClientProfileCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachCreateNestedManyWithoutCoachInput
    programs?: ProgramCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateCreateNestedManyWithoutCoachInput
    sentMessages?: MessageCreateNestedManyWithoutCoachInput
    channels?: ChannelCreateNestedManyWithoutCoachInput
    reviews?: ReviewCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileUncheckedCreateWithoutPostsInput = {
    id?: string
    userId: string
    bio?: string | null
    experience?: string | null
    rating?: number
    ratingCount?: number
    profilePicture?: string | null
    city?: string | null
    isRemote?: boolean
    trainingLocations?: CoachProfileCreatetrainingLocationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: ClientProfileUncheckedCreateNestedManyWithoutCoachInput
    clientCoaches?: ClientCoachUncheckedCreateNestedManyWithoutCoachInput
    programs?: ProgramUncheckedCreateNestedManyWithoutCoachInput
    programTemplates?: ProgramTemplateUncheckedCreateNestedManyWithoutCoachInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutCoachInput
    channels?: ChannelUncheckedCreateNestedManyWithoutCoachInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutCoachInput
    coachRequests?: CoachRequestUncheckedCreateNestedManyWithoutCoachInput
  }

  export type CoachProfileCreateOrConnectWithoutPostsInput = {
    where: CoachProfileWhereUniqueInput
    create: XOR<CoachProfileCreateWithoutPostsInput, CoachProfileUncheckedCreateWithoutPostsInput>
  }

  export type CoachProfileUpsertWithoutPostsInput = {
    update: XOR<CoachProfileUpdateWithoutPostsInput, CoachProfileUncheckedUpdateWithoutPostsInput>
    create: XOR<CoachProfileCreateWithoutPostsInput, CoachProfileUncheckedCreateWithoutPostsInput>
    where?: CoachProfileWhereInput
  }

  export type CoachProfileUpdateToOneWithWhereWithoutPostsInput = {
    where?: CoachProfileWhereInput
    data: XOR<CoachProfileUpdateWithoutPostsInput, CoachProfileUncheckedUpdateWithoutPostsInput>
  }

  export type CoachProfileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachProfileNestedInput
    clients?: ClientProfileUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUpdateManyWithoutCoachNestedInput
    programs?: ProgramUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUpdateManyWithoutCoachNestedInput
    channels?: ChannelUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutCoachNestedInput
  }

  export type CoachProfileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    ratingCount?: IntFieldUpdateOperationsInput | number
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isRemote?: BoolFieldUpdateOperationsInput | boolean
    trainingLocations?: CoachProfileUpdatetrainingLocationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: ClientProfileUncheckedUpdateManyWithoutCoachNestedInput
    clientCoaches?: ClientCoachUncheckedUpdateManyWithoutCoachNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutCoachNestedInput
    programTemplates?: ProgramTemplateUncheckedUpdateManyWithoutCoachNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutCoachNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutCoachNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutCoachNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutCoachNestedInput
  }

  export type ClientProfileCreateManyCoachInput = {
    id?: string
    userId: string
    weight?: number | null
    height?: number | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    goals?: string | null
    level?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCoachCreateManyCoachInput = {
    id?: string
    clientId: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCreateManyCoachInput = {
    id?: string
    clientId: string
    title: string
    description?: string | null
    cycleDays?: number | null
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramTemplateCreateManyCoachInput = {
    id?: string
    name: string
    description?: string | null
    cycleDays?: number | null
    dietEnabled?: boolean
    dietType?: string | null
    targetCalories?: number | null
    waterTrackingEnabled?: boolean
    waterGoal?: number | null
    sleepTrackingEnabled?: boolean
    weightTrackingEnabled?: boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyCoachInput = {
    id?: string
    clientId: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateManyCoachInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyCoachInput = {
    id?: string
    clientId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachPostCreateManyCoachInput = {
    id?: string
    content: string
    mediaType?: string | null
    mediaUrl?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestCreateManyCoachInput = {
    id?: string
    clientId: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientProfileUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientProfileNestedInput
    coaches?: ClientCoachUpdateManyWithoutClientNestedInput
    stats?: DailyStatUpdateManyWithoutClientNestedInput
    meals?: MealUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coaches?: ClientCoachUncheckedUpdateManyWithoutClientNestedInput
    stats?: DailyStatUncheckedUpdateManyWithoutClientNestedInput
    meals?: MealUncheckedUpdateManyWithoutClientNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    coachRequests?: CoachRequestUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientProfileUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutCoachesNestedInput
  }

  export type ClientCoachUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutProgramNestedInput
    mealPlans?: MealPlanUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutProgramNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutProgramNestedInput
    customGoals?: CustomGoalUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramTemplateUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramTemplateUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramTemplateUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cycleDays?: NullableIntFieldUpdateOperationsInput | number | null
    dietEnabled?: BoolFieldUpdateOperationsInput | boolean
    dietType?: NullableStringFieldUpdateOperationsInput | string | null
    targetCalories?: NullableIntFieldUpdateOperationsInput | number | null
    waterTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    waterGoal?: NullableFloatFieldUpdateOperationsInput | number | null
    sleepTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    weightTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    sessionsData?: NullableJsonNullValueInput | InputJsonValue
    customGoalsData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachPostUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachPostUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachPostUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    mediaType?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientProfileUpdateOneRequiredWithoutCoachRequestsNestedInput
  }

  export type CoachRequestUncheckedUpdateWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUncheckedUpdateManyWithoutCoachInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachCreateManyClientInput = {
    id?: string
    coachId: string
    isPrimary?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatCreateManyClientInput = {
    id?: string
    date: Date | string
    sleepHours?: number | null
    bedTime?: Date | string | null
    wakeTime?: Date | string | null
    waterIntake?: number | null
    weight?: number | null
    totalCalories?: number | null
    workoutTime?: Date | string | null
    workoutDuration?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealCreateManyClientInput = {
    id?: string
    date: Date | string
    mealType: string
    description: string
    photoUrl?: string | null
    calories: number
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyClientInput = {
    id?: string
    coachId: string
    content: string
    type?: $Enums.MessageType
    scheduledTime?: Date | string | null
    isRead?: boolean
    isSentByCoach?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyClientInput = {
    id?: string
    coachId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachRequestCreateManyClientInput = {
    id?: string
    coachId: string
    message: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCoachUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutClientCoachesNestedInput
  }

  export type ClientCoachUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCoachUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepHours?: NullableFloatFieldUpdateOperationsInput | number | null
    bedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    waterIntake?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalories?: NullableIntFieldUpdateOperationsInput | number | null
    workoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workoutDuration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mealType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: IntFieldUpdateOperationsInput | number
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isSentByCoach?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coach?: CoachProfileUpdateOneRequiredWithoutCoachRequestsNestedInput
  }

  export type CoachRequestUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachRequestUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    coachId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyProgramInput = {
    id?: string
    date: Date | string
    status?: $Enums.SessionStatus
    isRestDay?: boolean
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealPlanCreateManyProgramInput = {
    id?: string
    title: string
    description?: string | null
    dailyCalories?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomGoalCreateManyProgramInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUpdateManyWithoutSessionNestedInput
    comments?: CommentUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercises?: ExerciseUncheckedUpdateManyWithoutSessionNestedInput
    comments?: CommentUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    isRestDay?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealPlanUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUpdateManyWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dailyCalories?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomGoalUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: GoalCompletionUpdateManyWithoutCustomGoalNestedInput
  }

  export type CustomGoalUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: GoalCompletionUncheckedUpdateManyWithoutCustomGoalNestedInput
  }

  export type CustomGoalUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCompletionCreateManyCustomGoalInput = {
    id?: string
    clientId: string
    date: Date | string
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoalCompletionUpdateWithoutCustomGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCompletionUncheckedUpdateWithoutCustomGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoalCompletionUncheckedUpdateManyWithoutCustomGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateManySessionInput = {
    id?: string
    name: string
    category: $Enums.ExerciseCategory
    sets?: number | null
    reps?: string | null
    weight?: string | null
    restTime?: string | null
    videoUrl?: string | null
    gifUrl?: string | null
    description?: string | null
    order?: number
    duration?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManySessionInput = {
    id?: string
    clientId: string
    content: string
    date: Date | string
    isPastComment?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setCompletions?: SetCompletionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    setCompletions?: SetCompletionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumExerciseCategoryFieldUpdateOperationsInput | $Enums.ExerciseCategory
    sets?: NullableIntFieldUpdateOperationsInput | number | null
    reps?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableStringFieldUpdateOperationsInput | string | null
    restTime?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gifUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPastComment?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SetCompletionCreateManyExerciseInput = {
    id?: string
    setNumber: number
    repsAchieved?: string | null
    weightUsed?: string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SetCompletionUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SetCompletionUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SetCompletionUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    setNumber?: IntFieldUpdateOperationsInput | number
    repsAchieved?: NullableStringFieldUpdateOperationsInput | string | null
    weightUsed?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyMealPlanInput = {
    id?: string
    mealType: string
    name: string
    description?: string | null
    calories?: number | null
    protein?: number | null
    carbs?: number | null
    fats?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbs?: NullableFloatFieldUpdateOperationsInput | number | null
    fats?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CoachProfileCountOutputTypeDefaultArgs instead
     */
    export type CoachProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileCountOutputTypeDefaultArgs instead
     */
    export type ClientProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCountOutputTypeDefaultArgs instead
     */
    export type ProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomGoalCountOutputTypeDefaultArgs instead
     */
    export type CustomGoalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomGoalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionCountOutputTypeDefaultArgs instead
     */
    export type SessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseCountOutputTypeDefaultArgs instead
     */
    export type ExerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MealPlanCountOutputTypeDefaultArgs instead
     */
    export type MealPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MealPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachProfileDefaultArgs instead
     */
    export type CoachProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientProfileDefaultArgs instead
     */
    export type ClientProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCoachDefaultArgs instead
     */
    export type ClientCoachArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCoachDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramDefaultArgs instead
     */
    export type ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramTemplateDefaultArgs instead
     */
    export type ProgramTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomGoalDefaultArgs instead
     */
    export type CustomGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomGoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GoalCompletionDefaultArgs instead
     */
    export type GoalCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GoalCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseDefaultArgs instead
     */
    export type ExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SetCompletionDefaultArgs instead
     */
    export type SetCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SetCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MealPlanDefaultArgs instead
     */
    export type MealPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MealPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuItemDefaultArgs instead
     */
    export type MenuItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MealDefaultArgs instead
     */
    export type MealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyStatDefaultArgs instead
     */
    export type DailyStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyStatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChannelDefaultArgs instead
     */
    export type ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachRequestDefaultArgs instead
     */
    export type CoachRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachPostDefaultArgs instead
     */
    export type CoachPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachPostDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}